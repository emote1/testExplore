[{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\codegen.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\apollo-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\CollectionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\NftGallery.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\NftImage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\NftMediaViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\TransactionHistoryWithBlocks.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\TransactionTableWithTanStack.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\preview-playback.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":51,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":51,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\ninterface PreviewPlaybackContext {\n  register: (el: HTMLVideoElement) => void;\n  unregister: (el: HTMLVideoElement) => void;\n  ensureExclusive: (el: HTMLVideoElement) => void;\n  pauseAll: () => void;\n}\n\nconst Ctx = React.createContext<PreviewPlaybackContext | null>(null);\n\nexport function PreviewPlaybackProvider({ children, maxConcurrent = 1 }: { children: React.ReactNode; maxConcurrent?: number }) {\n  const elementsRef = React.useRef<Set<HTMLVideoElement>>(new Set());\n\n  const register = React.useCallback((el: HTMLVideoElement) => {\n    elementsRef.current.add(el);\n  }, []);\n\n  const unregister = React.useCallback((el: HTMLVideoElement) => {\n    elementsRef.current.delete(el);\n    try { el.pause(); } catch (e) { void e; }\n  }, []);\n\n  const pauseAll = React.useCallback(() => {\n    elementsRef.current.forEach((v) => { try { v.pause(); } catch (e) { void e; } });\n  }, []);\n\n  const ensureExclusive = React.useCallback((el: HTMLVideoElement) => {\n    // If maxConcurrent > 1, allow up to N, otherwise pause others.\n    if (maxConcurrent <= 1) {\n      elementsRef.current.forEach((v) => { if (v !== el) { try { v.pause(); } catch (e) { void e; } } });\n      return;\n    }\n    // For N>1, keep the provided el and up to N-1 others; pause the rest.\n    let kept = 1;\n    elementsRef.current.forEach((v) => {\n      if (v === el) return;\n      if (kept < maxConcurrent) {\n        kept += 1;\n      } else {\n        try { v.pause(); } catch (e) { void e; }\n      }\n    });\n  }, [maxConcurrent]);\n\n  const value = React.useMemo(() => ({ register, unregister, ensureExclusive, pauseAll }), [register, unregister, ensureExclusive, pauseAll]);\n\n  return <Ctx.Provider value={value}>{children}</Ctx.Provider>;\n}\n\nexport function usePreviewPlayback(): PreviewPlaybackContext {\n  const ctx = React.useContext(Ctx);\n  if (ctx) return ctx;\n  return {\n    register: (el: HTMLVideoElement) => { void el; },\n    unregister: (el: HTMLVideoElement) => { void el; },\n    ensureExclusive: (el: HTMLVideoElement) => { void el; },\n    pauseAll: () => { /* noop */ },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\transaction-columns.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","line":10,"column":7,"nodeType":"Identifier","messageId":"localComponents","endLine":10,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ColumnDef } from '@tanstack/react-table';\nimport { UiTransfer } from '../data/transfer-mapper';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from './ui/tooltip';\nimport { ArrowUpDown } from 'lucide-react';\nimport { formatTimestamp, shortenHash, formatTokenAmount } from '../utils/formatters';\nimport { Button } from './ui/button';\nimport { ExternalLink } from './ui/external-link';\nimport { Badge } from './ui/badge';\n\nconst AddressDisplay = ({ address }: { address: string }) => (\n  <TooltipProvider>\n    <Tooltip>\n      <TooltipTrigger asChild>\n        <span className=\"cursor-pointer\">{shortenHash(address, 6, 6)}</span>\n      </TooltipTrigger>\n      <TooltipContent>\n        <p>{address}</p>\n      </TooltipContent>\n    </Tooltip>\n  </TooltipProvider>\n);\n\nexport const transactionColumns: ColumnDef<UiTransfer>[] = [\n  {\n    accessorKey: 'type',\n    header: 'TYPE',\n    cell: ({ row }) => {\n      const type = row.getValue('type') as string;\n      const isIncoming = type === 'INCOMING';\n\n      return (\n        <Badge\n          className={`font-semibold ${isIncoming\n              ? 'bg-green-100 text-green-800 hover:bg-green-100/80'\n              : 'bg-yellow-100 text-yellow-800 hover:bg-yellow-100/80'\n            }`}\n        >\n          {type.toUpperCase()}\n        </Badge>\n      );\n    },\n  },\n  {\n    accessorKey: 'timestamp',\n    header: ({ column }) => (\n      <Button\n        variant=\"ghost\"\n        onClick={() => column.toggleSorting(column.getIsSorted() === 'asc')}\n      >\n        TIMESTAMP\n        <ArrowUpDown className=\"ml-2 h-4 w-4\" />\n      </Button>\n    ),\n    cell: ({ row }) => formatTimestamp(row.getValue('timestamp')),\n  },\n  {\n    accessorKey: 'from',\n    header: 'FROM',\n    cell: ({ row }) => <AddressDisplay address={row.getValue('from')} />,\n  },\n  {\n    accessorKey: 'to',\n    header: 'TO',\n    cell: ({ row }) => <AddressDisplay address={row.getValue('to')} />,\n  },\n  {\n    accessorKey: 'amount',\n    header: 'AMOUNT',\n    cell: ({ row }) => {\n      const transfer = row.original;\n      const formattedAmount = formatTokenAmount(\n        transfer.amount,\n        transfer.token.decimals,\n        transfer.token.name\n      );\n      return <span>{formattedAmount}</span>;\n    },\n  },\n  {\n    accessorKey: 'feeAmount',\n    header: 'FEE',\n    cell: ({ row }) => {\n      const transfer = row.original;\n      const formattedFee = formatTokenAmount(\n        transfer.feeAmount || '0',\n        18, // REEF decimals\n        'REEF'\n      );\n      return <span>{formattedFee}</span>;\n    },\n  },\n  {\n    id: 'actions',\n    cell: ({ row }) => (\n      <ExternalLink href={`https://reefscan.com/extrinsic/${row.original.extrinsicHash}`} />\n    ),\n  },\n  {\n    accessorKey: 'success',\n    header: 'Status',\n    cell: ({ row }) => {\n      const success = row.getValue('success') as boolean;\n      const statusText = success ? 'Success' : 'Failed';\n      \n      return (\n        <span\n          className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${\n            success\n              ? 'bg-green-100 text-green-800'\n              : 'bg-red-100 text-red-800'\n          }`}\n        >\n          {statusText}\n        </span>\n      );\n    },\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\ui\\badge.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":36,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":36,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/utils/ui\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\ui\\button.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":57,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":57,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/utils/ui\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground shadow hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-9 px-4 py-2\",\n        sm: \"h-8 rounded-md px-3 text-xs\",\n        lg: \"h-10 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\ui\\external-link.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\ui\\scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\ui\\skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\components\\ui\\tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\constants\\pagination.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\data\\addresses.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\data\\cache-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\data\\nfts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\data\\transfer-mapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\data\\transfers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\gql\\fragment-masking.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_fragment' is defined but never used.","line":69,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\gql\\gql.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":1,"column":1,"severity":1,"nodeType":null,"fix":{"range":[0,20],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/* eslint-disable */\nimport * as types from './graphql';\nimport type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n/**\n * Map of all GraphQL operations in the project.\n *\n * This map has several performance disadvantages:\n * 1. It is not tree-shakeable, so it will include all operations in the project.\n * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.\n * 3. It does not support dead code elimination, so it will add unused operations.\n *\n * Therefore it is highly recommended to use the babel or swc plugin for production.\n * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size\n */\ntype Documents = {\n    \"\\n  query GetAccountByEvm($evmAddress: String!) {\\n    accounts(where: { evmAddress_eq: $evmAddress }, limit: 1) {\\n      id\\n      evmAddress\\n    }\\n  }\\n\": typeof types.GetAccountByEvmDocument,\n    \"\\n  query GetAccountByNative($nativeAddress: String!) {\\n    accounts(where: { id_eq: $nativeAddress }, limit: 1) {\\n      id\\n      evmAddress\\n    }\\n  }\\n\": typeof types.GetAccountByNativeDocument,\n    \"\\n  query NftsByOwner($owner: String!) {\\n    tokenHolders(\\n      where: { \\n        signer: { evmAddress_eq: $owner },\\n        balance_gt: \\\"0\\\",\\n        token: { type_in: [ERC721, ERC1155] }\\n      }\\n      limit: 300\\n    ) {\\n      id\\n      balance\\n      type\\n      nftId\\n      token {\\n        id\\n        type\\n      }\\n    }\\n  }\\n\": typeof types.NftsByOwnerDocument,\n    \"\\n  query NftsByOwnerPaged($owner: String!, $limit: Int!, $offset: Int!) {\\n    tokenHolders(\\n      where: { signer: { evmAddress_eq: $owner }, balance_gt: \\\"0\\\", token: { type_in: [ERC721, ERC1155] } }\\n      limit: $limit\\n      offset: $offset\\n    ) {\\n      id\\n      balance\\n      nftId\\n      token { id type }\\n    }\\n  }\\n\": typeof types.NftsByOwnerPagedDocument,\n    \"\\n  query ExtrinsicFeeQuery($extrinsicHash: String!) {\\n    extrinsics(where: { hash_eq: $extrinsicHash }, limit: 1) {\\n      events(where: {section_eq: \\\"transactionpayment\\\", method_eq: \\\"TransactionFeePaid\\\"}) {\\n        data\\n      }\\n    }\\n  }\\n\": typeof types.ExtrinsicFeeQueryDocument,\n    \"\\n  query TransfersFeeQuery($first: Int!, $after: String, $where: TransferWhereInput, $orderBy: [TransferOrderByInput!]!) {\\n    transfersConnection(orderBy: $orderBy, first: $first, after: $after, where: $where) {\\n      edges {\\n        node {\\n          id\\n          amount\\n          timestamp\\n          success\\n          type\\n          extrinsicHash\\n          from {\\n            id\\n          }\\n          to {\\n            id\\n          }\\n          token {\\n            id\\n            name\\n            contractData\\n          }\\n\\n        }\\n      }\\n      pageInfo {\\n        hasNextPage\\n        endCursor\\n      }\\n      totalCount\\n    }\\n  }\\n\": typeof types.TransfersFeeQueryDocument,\n    \"\\n  query NftTokenIdQuery($ids: [String!]) {\\n    extrinsics(where: { id_in: $ids }) {\\n      id\\n      hash\\n      events(where: { section_eq: \\\"uniques\\\", method_eq: \\\"Transferred\\\" }) {\\n        id\\n        section\\n        method\\n        data\\n      }\\n    }\\n  }\\n\": typeof types.NftTokenIdQueryDocument,\n    \"\\n  query TransfersPollingQuery($where: TransferWhereInput, $orderBy: [TransferOrderByInput!], $offset: Int, $limit: Int) {\\n    transfers(where: $where, orderBy: $orderBy, offset: $offset, limit: $limit) {\\n      id\\n      amount\\n      timestamp\\n      success\\n      type\\n      extrinsicHash\\n      extrinsicId\\n      from {\\n        id\\n      }\\n      to {\\n        id\\n      }\\n      token {\\n        id\\n        name\\n        contractData\\n      }\\n    }\\n  }\\n\": typeof types.TransfersPollingQueryDocument,\n    \"\\n          query TokenHoldersByCollection($collectionId: String!, $limit: Int!, $offset: Int!) {\\n            tokenHolders(\\n              where: { token: { id_eq: $collectionId }, balance_gt: \\\"0\\\" }\\n              limit: $limit\\n              offset: $offset\\n            ) {\\n              nftId\\n            }\\n          }\\n        \": typeof types.TokenHoldersByCollectionDocument,\n};\nconst documents: Documents = {\n    \"\\n  query GetAccountByEvm($evmAddress: String!) {\\n    accounts(where: { evmAddress_eq: $evmAddress }, limit: 1) {\\n      id\\n      evmAddress\\n    }\\n  }\\n\": types.GetAccountByEvmDocument,\n    \"\\n  query GetAccountByNative($nativeAddress: String!) {\\n    accounts(where: { id_eq: $nativeAddress }, limit: 1) {\\n      id\\n      evmAddress\\n    }\\n  }\\n\": types.GetAccountByNativeDocument,\n    \"\\n  query NftsByOwner($owner: String!) {\\n    tokenHolders(\\n      where: { \\n        signer: { evmAddress_eq: $owner },\\n        balance_gt: \\\"0\\\",\\n        token: { type_in: [ERC721, ERC1155] }\\n      }\\n      limit: 300\\n    ) {\\n      id\\n      balance\\n      type\\n      nftId\\n      token {\\n        id\\n        type\\n      }\\n    }\\n  }\\n\": types.NftsByOwnerDocument,\n    \"\\n  query NftsByOwnerPaged($owner: String!, $limit: Int!, $offset: Int!) {\\n    tokenHolders(\\n      where: { signer: { evmAddress_eq: $owner }, balance_gt: \\\"0\\\", token: { type_in: [ERC721, ERC1155] } }\\n      limit: $limit\\n      offset: $offset\\n    ) {\\n      id\\n      balance\\n      nftId\\n      token { id type }\\n    }\\n  }\\n\": types.NftsByOwnerPagedDocument,\n    \"\\n  query ExtrinsicFeeQuery($extrinsicHash: String!) {\\n    extrinsics(where: { hash_eq: $extrinsicHash }, limit: 1) {\\n      events(where: {section_eq: \\\"transactionpayment\\\", method_eq: \\\"TransactionFeePaid\\\"}) {\\n        data\\n      }\\n    }\\n  }\\n\": types.ExtrinsicFeeQueryDocument,\n    \"\\n  query TransfersFeeQuery($first: Int!, $after: String, $where: TransferWhereInput, $orderBy: [TransferOrderByInput!]!) {\\n    transfersConnection(orderBy: $orderBy, first: $first, after: $after, where: $where) {\\n      edges {\\n        node {\\n          id\\n          amount\\n          timestamp\\n          success\\n          type\\n          extrinsicHash\\n          from {\\n            id\\n          }\\n          to {\\n            id\\n          }\\n          token {\\n            id\\n            name\\n            contractData\\n          }\\n\\n        }\\n      }\\n      pageInfo {\\n        hasNextPage\\n        endCursor\\n      }\\n      totalCount\\n    }\\n  }\\n\": types.TransfersFeeQueryDocument,\n    \"\\n  query NftTokenIdQuery($ids: [String!]) {\\n    extrinsics(where: { id_in: $ids }) {\\n      id\\n      hash\\n      events(where: { section_eq: \\\"uniques\\\", method_eq: \\\"Transferred\\\" }) {\\n        id\\n        section\\n        method\\n        data\\n      }\\n    }\\n  }\\n\": types.NftTokenIdQueryDocument,\n    \"\\n  query TransfersPollingQuery($where: TransferWhereInput, $orderBy: [TransferOrderByInput!], $offset: Int, $limit: Int) {\\n    transfers(where: $where, orderBy: $orderBy, offset: $offset, limit: $limit) {\\n      id\\n      amount\\n      timestamp\\n      success\\n      type\\n      extrinsicHash\\n      extrinsicId\\n      from {\\n        id\\n      }\\n      to {\\n        id\\n      }\\n      token {\\n        id\\n        name\\n        contractData\\n      }\\n    }\\n  }\\n\": types.TransfersPollingQueryDocument,\n    \"\\n          query TokenHoldersByCollection($collectionId: String!, $limit: Int!, $offset: Int!) {\\n            tokenHolders(\\n              where: { token: { id_eq: $collectionId }, balance_gt: \\\"0\\\" }\\n              limit: $limit\\n              offset: $offset\\n            ) {\\n              nftId\\n            }\\n          }\\n        \": types.TokenHoldersByCollectionDocument,\n};\n\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n *\n *\n * @example\n * ```ts\n * const query = graphql(`query GetUser($id: ID!) { user(id: $id) { name } }`);\n * ```\n *\n * The query argument is unknown!\n * Please regenerate the types.\n */\nexport function graphql(source: string): unknown;\n\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  query GetAccountByEvm($evmAddress: String!) {\\n    accounts(where: { evmAddress_eq: $evmAddress }, limit: 1) {\\n      id\\n      evmAddress\\n    }\\n  }\\n\"): (typeof documents)[\"\\n  query GetAccountByEvm($evmAddress: String!) {\\n    accounts(where: { evmAddress_eq: $evmAddress }, limit: 1) {\\n      id\\n      evmAddress\\n    }\\n  }\\n\"];\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  query GetAccountByNative($nativeAddress: String!) {\\n    accounts(where: { id_eq: $nativeAddress }, limit: 1) {\\n      id\\n      evmAddress\\n    }\\n  }\\n\"): (typeof documents)[\"\\n  query GetAccountByNative($nativeAddress: String!) {\\n    accounts(where: { id_eq: $nativeAddress }, limit: 1) {\\n      id\\n      evmAddress\\n    }\\n  }\\n\"];\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  query NftsByOwner($owner: String!) {\\n    tokenHolders(\\n      where: { \\n        signer: { evmAddress_eq: $owner },\\n        balance_gt: \\\"0\\\",\\n        token: { type_in: [ERC721, ERC1155] }\\n      }\\n      limit: 300\\n    ) {\\n      id\\n      balance\\n      type\\n      nftId\\n      token {\\n        id\\n        type\\n      }\\n    }\\n  }\\n\"): (typeof documents)[\"\\n  query NftsByOwner($owner: String!) {\\n    tokenHolders(\\n      where: { \\n        signer: { evmAddress_eq: $owner },\\n        balance_gt: \\\"0\\\",\\n        token: { type_in: [ERC721, ERC1155] }\\n      }\\n      limit: 300\\n    ) {\\n      id\\n      balance\\n      type\\n      nftId\\n      token {\\n        id\\n        type\\n      }\\n    }\\n  }\\n\"];\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  query NftsByOwnerPaged($owner: String!, $limit: Int!, $offset: Int!) {\\n    tokenHolders(\\n      where: { signer: { evmAddress_eq: $owner }, balance_gt: \\\"0\\\", token: { type_in: [ERC721, ERC1155] } }\\n      limit: $limit\\n      offset: $offset\\n    ) {\\n      id\\n      balance\\n      nftId\\n      token { id type }\\n    }\\n  }\\n\"): (typeof documents)[\"\\n  query NftsByOwnerPaged($owner: String!, $limit: Int!, $offset: Int!) {\\n    tokenHolders(\\n      where: { signer: { evmAddress_eq: $owner }, balance_gt: \\\"0\\\", token: { type_in: [ERC721, ERC1155] } }\\n      limit: $limit\\n      offset: $offset\\n    ) {\\n      id\\n      balance\\n      nftId\\n      token { id type }\\n    }\\n  }\\n\"];\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  query ExtrinsicFeeQuery($extrinsicHash: String!) {\\n    extrinsics(where: { hash_eq: $extrinsicHash }, limit: 1) {\\n      events(where: {section_eq: \\\"transactionpayment\\\", method_eq: \\\"TransactionFeePaid\\\"}) {\\n        data\\n      }\\n    }\\n  }\\n\"): (typeof documents)[\"\\n  query ExtrinsicFeeQuery($extrinsicHash: String!) {\\n    extrinsics(where: { hash_eq: $extrinsicHash }, limit: 1) {\\n      events(where: {section_eq: \\\"transactionpayment\\\", method_eq: \\\"TransactionFeePaid\\\"}) {\\n        data\\n      }\\n    }\\n  }\\n\"];\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  query TransfersFeeQuery($first: Int!, $after: String, $where: TransferWhereInput, $orderBy: [TransferOrderByInput!]!) {\\n    transfersConnection(orderBy: $orderBy, first: $first, after: $after, where: $where) {\\n      edges {\\n        node {\\n          id\\n          amount\\n          timestamp\\n          success\\n          type\\n          extrinsicHash\\n          from {\\n            id\\n          }\\n          to {\\n            id\\n          }\\n          token {\\n            id\\n            name\\n            contractData\\n          }\\n\\n        }\\n      }\\n      pageInfo {\\n        hasNextPage\\n        endCursor\\n      }\\n      totalCount\\n    }\\n  }\\n\"): (typeof documents)[\"\\n  query TransfersFeeQuery($first: Int!, $after: String, $where: TransferWhereInput, $orderBy: [TransferOrderByInput!]!) {\\n    transfersConnection(orderBy: $orderBy, first: $first, after: $after, where: $where) {\\n      edges {\\n        node {\\n          id\\n          amount\\n          timestamp\\n          success\\n          type\\n          extrinsicHash\\n          from {\\n            id\\n          }\\n          to {\\n            id\\n          }\\n          token {\\n            id\\n            name\\n            contractData\\n          }\\n\\n        }\\n      }\\n      pageInfo {\\n        hasNextPage\\n        endCursor\\n      }\\n      totalCount\\n    }\\n  }\\n\"];\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  query NftTokenIdQuery($ids: [String!]) {\\n    extrinsics(where: { id_in: $ids }) {\\n      id\\n      hash\\n      events(where: { section_eq: \\\"uniques\\\", method_eq: \\\"Transferred\\\" }) {\\n        id\\n        section\\n        method\\n        data\\n      }\\n    }\\n  }\\n\"): (typeof documents)[\"\\n  query NftTokenIdQuery($ids: [String!]) {\\n    extrinsics(where: { id_in: $ids }) {\\n      id\\n      hash\\n      events(where: { section_eq: \\\"uniques\\\", method_eq: \\\"Transferred\\\" }) {\\n        id\\n        section\\n        method\\n        data\\n      }\\n    }\\n  }\\n\"];\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n  query TransfersPollingQuery($where: TransferWhereInput, $orderBy: [TransferOrderByInput!], $offset: Int, $limit: Int) {\\n    transfers(where: $where, orderBy: $orderBy, offset: $offset, limit: $limit) {\\n      id\\n      amount\\n      timestamp\\n      success\\n      type\\n      extrinsicHash\\n      extrinsicId\\n      from {\\n        id\\n      }\\n      to {\\n        id\\n      }\\n      token {\\n        id\\n        name\\n        contractData\\n      }\\n    }\\n  }\\n\"): (typeof documents)[\"\\n  query TransfersPollingQuery($where: TransferWhereInput, $orderBy: [TransferOrderByInput!], $offset: Int, $limit: Int) {\\n    transfers(where: $where, orderBy: $orderBy, offset: $offset, limit: $limit) {\\n      id\\n      amount\\n      timestamp\\n      success\\n      type\\n      extrinsicHash\\n      extrinsicId\\n      from {\\n        id\\n      }\\n      to {\\n        id\\n      }\\n      token {\\n        id\\n        name\\n        contractData\\n      }\\n    }\\n  }\\n\"];\n/**\n * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.\n */\nexport function graphql(source: \"\\n          query TokenHoldersByCollection($collectionId: String!, $limit: Int!, $offset: Int!) {\\n            tokenHolders(\\n              where: { token: { id_eq: $collectionId }, balance_gt: \\\"0\\\" }\\n              limit: $limit\\n              offset: $offset\\n            ) {\\n              nftId\\n            }\\n          }\\n        \"): (typeof documents)[\"\\n          query TokenHoldersByCollection($collectionId: String!, $limit: Int!, $offset: Int!) {\\n            tokenHolders(\\n              where: { token: { id_eq: $collectionId }, balance_gt: \\\"0\\\" }\\n              limit: $limit\\n              offset: $offset\\n            ) {\\n              nftId\\n            }\\n          }\\n        \"];\n\nexport function graphql(source: string) {\n  return (documents as any)[source] ?? {};\n}\n\nexport type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\gql\\graphql.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":1,"column":1,"severity":1,"nodeType":null,"fix":{"range":[0,20],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/* eslint-disable */\nimport type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: { input: string; output: string; }\n  String: { input: string; output: string; }\n  Boolean: { input: boolean; output: boolean; }\n  Int: { input: number; output: number; }\n  Float: { input: number; output: number; }\n  /** Big number integer */\n  BigInt: { input: any; output: any; }\n  /** A date-time string in simplified extended ISO 8601 format (YYYY-MM-DDTHH:mm:ss.sssZ) */\n  DateTime: { input: any; output: any; }\n  /** A scalar that can represent any JSON value */\n  JSON: { input: any; output: any; }\n};\n\nexport type Account = {\n  __typename?: 'Account';\n  active: Scalars['Boolean']['output'];\n  availableBalance: Scalars['BigInt']['output'];\n  block: Block;\n  contracts: Array<Contract>;\n  evmAddress?: Maybe<Scalars['String']['output']>;\n  evmNonce: Scalars['Int']['output'];\n  freeBalance: Scalars['BigInt']['output'];\n  /** Native address */\n  id: Scalars['String']['output'];\n  identity?: Maybe<Scalars['JSON']['output']>;\n  lockedBalance: Scalars['BigInt']['output'];\n  nonce: Scalars['Int']['output'];\n  reservedBalance: Scalars['BigInt']['output'];\n  timestamp: Scalars['DateTime']['output'];\n  vestedBalance: Scalars['BigInt']['output'];\n  votingBalance: Scalars['BigInt']['output'];\n};\n\n\nexport type AccountContractsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ContractOrderByInput>>;\n  where?: InputMaybe<ContractWhereInput>;\n};\n\nexport type AccountEdge = {\n  __typename?: 'AccountEdge';\n  cursor: Scalars['String']['output'];\n  node: Account;\n};\n\nexport type AccountOrderByInput =\n  | 'active_ASC'\n  | 'active_ASC_NULLS_FIRST'\n  | 'active_DESC'\n  | 'active_DESC_NULLS_LAST'\n  | 'availableBalance_ASC'\n  | 'availableBalance_ASC_NULLS_FIRST'\n  | 'availableBalance_DESC'\n  | 'availableBalance_DESC_NULLS_LAST'\n  | 'block_author_ASC'\n  | 'block_author_ASC_NULLS_FIRST'\n  | 'block_author_DESC'\n  | 'block_author_DESC_NULLS_LAST'\n  | 'block_extrinsicRoot_ASC'\n  | 'block_extrinsicRoot_ASC_NULLS_FIRST'\n  | 'block_extrinsicRoot_DESC'\n  | 'block_extrinsicRoot_DESC_NULLS_LAST'\n  | 'block_finalized_ASC'\n  | 'block_finalized_ASC_NULLS_FIRST'\n  | 'block_finalized_DESC'\n  | 'block_finalized_DESC_NULLS_LAST'\n  | 'block_hash_ASC'\n  | 'block_hash_ASC_NULLS_FIRST'\n  | 'block_hash_DESC'\n  | 'block_hash_DESC_NULLS_LAST'\n  | 'block_height_ASC'\n  | 'block_height_ASC_NULLS_FIRST'\n  | 'block_height_DESC'\n  | 'block_height_DESC_NULLS_LAST'\n  | 'block_id_ASC'\n  | 'block_id_ASC_NULLS_FIRST'\n  | 'block_id_DESC'\n  | 'block_id_DESC_NULLS_LAST'\n  | 'block_parentHash_ASC'\n  | 'block_parentHash_ASC_NULLS_FIRST'\n  | 'block_parentHash_DESC'\n  | 'block_parentHash_DESC_NULLS_LAST'\n  | 'block_processorTimestamp_ASC'\n  | 'block_processorTimestamp_ASC_NULLS_FIRST'\n  | 'block_processorTimestamp_DESC'\n  | 'block_processorTimestamp_DESC_NULLS_LAST'\n  | 'block_stateRoot_ASC'\n  | 'block_stateRoot_ASC_NULLS_FIRST'\n  | 'block_stateRoot_DESC'\n  | 'block_stateRoot_DESC_NULLS_LAST'\n  | 'block_timestamp_ASC'\n  | 'block_timestamp_ASC_NULLS_FIRST'\n  | 'block_timestamp_DESC'\n  | 'block_timestamp_DESC_NULLS_LAST'\n  | 'evmAddress_ASC'\n  | 'evmAddress_ASC_NULLS_FIRST'\n  | 'evmAddress_DESC'\n  | 'evmAddress_DESC_NULLS_LAST'\n  | 'evmNonce_ASC'\n  | 'evmNonce_ASC_NULLS_FIRST'\n  | 'evmNonce_DESC'\n  | 'evmNonce_DESC_NULLS_LAST'\n  | 'freeBalance_ASC'\n  | 'freeBalance_ASC_NULLS_FIRST'\n  | 'freeBalance_DESC'\n  | 'freeBalance_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'lockedBalance_ASC'\n  | 'lockedBalance_ASC_NULLS_FIRST'\n  | 'lockedBalance_DESC'\n  | 'lockedBalance_DESC_NULLS_LAST'\n  | 'nonce_ASC'\n  | 'nonce_ASC_NULLS_FIRST'\n  | 'nonce_DESC'\n  | 'nonce_DESC_NULLS_LAST'\n  | 'reservedBalance_ASC'\n  | 'reservedBalance_ASC_NULLS_FIRST'\n  | 'reservedBalance_DESC'\n  | 'reservedBalance_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST'\n  | 'vestedBalance_ASC'\n  | 'vestedBalance_ASC_NULLS_FIRST'\n  | 'vestedBalance_DESC'\n  | 'vestedBalance_DESC_NULLS_LAST'\n  | 'votingBalance_ASC'\n  | 'votingBalance_ASC_NULLS_FIRST'\n  | 'votingBalance_DESC'\n  | 'votingBalance_DESC_NULLS_LAST';\n\nexport type AccountWhereInput = {\n  AND?: InputMaybe<Array<AccountWhereInput>>;\n  OR?: InputMaybe<Array<AccountWhereInput>>;\n  active_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  active_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  active_not_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  availableBalance_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  availableBalance_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  availableBalance_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  availableBalance_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  availableBalance_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  availableBalance_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  availableBalance_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  availableBalance_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  availableBalance_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  block?: InputMaybe<BlockWhereInput>;\n  block_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  contracts_every?: InputMaybe<ContractWhereInput>;\n  contracts_none?: InputMaybe<ContractWhereInput>;\n  contracts_some?: InputMaybe<ContractWhereInput>;\n  evmAddress_contains?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_endsWith?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_eq?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_gt?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_gte?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  evmAddress_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  evmAddress_lt?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_lte?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_contains?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_eq?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  evmAddress_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_startsWith?: InputMaybe<Scalars['String']['input']>;\n  evmNonce_eq?: InputMaybe<Scalars['Int']['input']>;\n  evmNonce_gt?: InputMaybe<Scalars['Int']['input']>;\n  evmNonce_gte?: InputMaybe<Scalars['Int']['input']>;\n  evmNonce_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  evmNonce_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  evmNonce_lt?: InputMaybe<Scalars['Int']['input']>;\n  evmNonce_lte?: InputMaybe<Scalars['Int']['input']>;\n  evmNonce_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  evmNonce_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  freeBalance_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  freeBalance_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  freeBalance_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  freeBalance_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  freeBalance_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  freeBalance_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  freeBalance_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  freeBalance_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  freeBalance_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  identity_eq?: InputMaybe<Scalars['JSON']['input']>;\n  identity_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  identity_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  identity_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  identity_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  lockedBalance_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  lockedBalance_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  lockedBalance_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  lockedBalance_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  lockedBalance_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  lockedBalance_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  lockedBalance_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  lockedBalance_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  lockedBalance_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  nonce_eq?: InputMaybe<Scalars['Int']['input']>;\n  nonce_gt?: InputMaybe<Scalars['Int']['input']>;\n  nonce_gte?: InputMaybe<Scalars['Int']['input']>;\n  nonce_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  nonce_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  nonce_lt?: InputMaybe<Scalars['Int']['input']>;\n  nonce_lte?: InputMaybe<Scalars['Int']['input']>;\n  nonce_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  nonce_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  reservedBalance_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  reservedBalance_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  reservedBalance_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  reservedBalance_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  reservedBalance_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  reservedBalance_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  reservedBalance_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  reservedBalance_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  reservedBalance_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  vestedBalance_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  vestedBalance_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  vestedBalance_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  vestedBalance_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  vestedBalance_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  vestedBalance_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  vestedBalance_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  vestedBalance_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  vestedBalance_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  votingBalance_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  votingBalance_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  votingBalance_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  votingBalance_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  votingBalance_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  votingBalance_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  votingBalance_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  votingBalance_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  votingBalance_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n};\n\nexport type AccountsConnection = {\n  __typename?: 'AccountsConnection';\n  edges: Array<AccountEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type Block = {\n  __typename?: 'Block';\n  accounts: Array<Account>;\n  author: Scalars['String']['output'];\n  events: Array<Event>;\n  extrinsicRoot: Scalars['String']['output'];\n  extrinsics: Array<Extrinsic>;\n  finalized: Scalars['Boolean']['output'];\n  hash: Scalars['String']['output'];\n  height: Scalars['Int']['output'];\n  /** 000000..00<blockNum>-<shorthash> */\n  id: Scalars['String']['output'];\n  parentHash: Scalars['String']['output'];\n  processorTimestamp?: Maybe<Scalars['DateTime']['output']>;\n  stateRoot: Scalars['String']['output'];\n  timestamp: Scalars['DateTime']['output'];\n};\n\n\nexport type BlockAccountsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AccountOrderByInput>>;\n  where?: InputMaybe<AccountWhereInput>;\n};\n\n\nexport type BlockEventsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EventOrderByInput>>;\n  where?: InputMaybe<EventWhereInput>;\n};\n\n\nexport type BlockExtrinsicsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ExtrinsicOrderByInput>>;\n  where?: InputMaybe<ExtrinsicWhereInput>;\n};\n\nexport type BlockEdge = {\n  __typename?: 'BlockEdge';\n  cursor: Scalars['String']['output'];\n  node: Block;\n};\n\nexport type BlockOrderByInput =\n  | 'author_ASC'\n  | 'author_ASC_NULLS_FIRST'\n  | 'author_DESC'\n  | 'author_DESC_NULLS_LAST'\n  | 'extrinsicRoot_ASC'\n  | 'extrinsicRoot_ASC_NULLS_FIRST'\n  | 'extrinsicRoot_DESC'\n  | 'extrinsicRoot_DESC_NULLS_LAST'\n  | 'finalized_ASC'\n  | 'finalized_ASC_NULLS_FIRST'\n  | 'finalized_DESC'\n  | 'finalized_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC'\n  | 'hash_DESC_NULLS_LAST'\n  | 'height_ASC'\n  | 'height_ASC_NULLS_FIRST'\n  | 'height_DESC'\n  | 'height_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'parentHash_ASC'\n  | 'parentHash_ASC_NULLS_FIRST'\n  | 'parentHash_DESC'\n  | 'parentHash_DESC_NULLS_LAST'\n  | 'processorTimestamp_ASC'\n  | 'processorTimestamp_ASC_NULLS_FIRST'\n  | 'processorTimestamp_DESC'\n  | 'processorTimestamp_DESC_NULLS_LAST'\n  | 'stateRoot_ASC'\n  | 'stateRoot_ASC_NULLS_FIRST'\n  | 'stateRoot_DESC'\n  | 'stateRoot_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST';\n\nexport type BlockWhereInput = {\n  AND?: InputMaybe<Array<BlockWhereInput>>;\n  OR?: InputMaybe<Array<BlockWhereInput>>;\n  accounts_every?: InputMaybe<AccountWhereInput>;\n  accounts_none?: InputMaybe<AccountWhereInput>;\n  accounts_some?: InputMaybe<AccountWhereInput>;\n  author_contains?: InputMaybe<Scalars['String']['input']>;\n  author_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  author_endsWith?: InputMaybe<Scalars['String']['input']>;\n  author_eq?: InputMaybe<Scalars['String']['input']>;\n  author_gt?: InputMaybe<Scalars['String']['input']>;\n  author_gte?: InputMaybe<Scalars['String']['input']>;\n  author_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  author_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  author_lt?: InputMaybe<Scalars['String']['input']>;\n  author_lte?: InputMaybe<Scalars['String']['input']>;\n  author_not_contains?: InputMaybe<Scalars['String']['input']>;\n  author_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  author_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  author_not_eq?: InputMaybe<Scalars['String']['input']>;\n  author_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  author_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  author_startsWith?: InputMaybe<Scalars['String']['input']>;\n  events_every?: InputMaybe<EventWhereInput>;\n  events_none?: InputMaybe<EventWhereInput>;\n  events_some?: InputMaybe<EventWhereInput>;\n  extrinsicRoot_contains?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_endsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_eq?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_gt?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_gte?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  extrinsicRoot_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  extrinsicRoot_lt?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_lte?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_not_contains?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_not_eq?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  extrinsicRoot_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicRoot_startsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsics_every?: InputMaybe<ExtrinsicWhereInput>;\n  extrinsics_none?: InputMaybe<ExtrinsicWhereInput>;\n  extrinsics_some?: InputMaybe<ExtrinsicWhereInput>;\n  finalized_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  finalized_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  finalized_not_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  hash_contains?: InputMaybe<Scalars['String']['input']>;\n  hash_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  hash_endsWith?: InputMaybe<Scalars['String']['input']>;\n  hash_eq?: InputMaybe<Scalars['String']['input']>;\n  hash_gt?: InputMaybe<Scalars['String']['input']>;\n  hash_gte?: InputMaybe<Scalars['String']['input']>;\n  hash_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  hash_lt?: InputMaybe<Scalars['String']['input']>;\n  hash_lte?: InputMaybe<Scalars['String']['input']>;\n  hash_not_contains?: InputMaybe<Scalars['String']['input']>;\n  hash_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  hash_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  hash_not_eq?: InputMaybe<Scalars['String']['input']>;\n  hash_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  hash_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  hash_startsWith?: InputMaybe<Scalars['String']['input']>;\n  height_eq?: InputMaybe<Scalars['Int']['input']>;\n  height_gt?: InputMaybe<Scalars['Int']['input']>;\n  height_gte?: InputMaybe<Scalars['Int']['input']>;\n  height_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  height_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  height_lt?: InputMaybe<Scalars['Int']['input']>;\n  height_lte?: InputMaybe<Scalars['Int']['input']>;\n  height_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  height_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  parentHash_contains?: InputMaybe<Scalars['String']['input']>;\n  parentHash_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  parentHash_endsWith?: InputMaybe<Scalars['String']['input']>;\n  parentHash_eq?: InputMaybe<Scalars['String']['input']>;\n  parentHash_gt?: InputMaybe<Scalars['String']['input']>;\n  parentHash_gte?: InputMaybe<Scalars['String']['input']>;\n  parentHash_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  parentHash_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  parentHash_lt?: InputMaybe<Scalars['String']['input']>;\n  parentHash_lte?: InputMaybe<Scalars['String']['input']>;\n  parentHash_not_contains?: InputMaybe<Scalars['String']['input']>;\n  parentHash_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  parentHash_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  parentHash_not_eq?: InputMaybe<Scalars['String']['input']>;\n  parentHash_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  parentHash_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  parentHash_startsWith?: InputMaybe<Scalars['String']['input']>;\n  processorTimestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  processorTimestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  processorTimestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  processorTimestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  processorTimestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  processorTimestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  processorTimestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  processorTimestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  processorTimestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  stateRoot_contains?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_endsWith?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_eq?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_gt?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_gte?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  stateRoot_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  stateRoot_lt?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_lte?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_not_contains?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_not_eq?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  stateRoot_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  stateRoot_startsWith?: InputMaybe<Scalars['String']['input']>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n};\n\nexport type BlocksConnection = {\n  __typename?: 'BlocksConnection';\n  edges: Array<BlockEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type ChainInfo = {\n  __typename?: 'ChainInfo';\n  count: Scalars['Int']['output'];\n  /** Name */\n  id: Scalars['String']['output'];\n};\n\nexport type ChainInfoEdge = {\n  __typename?: 'ChainInfoEdge';\n  cursor: Scalars['String']['output'];\n  node: ChainInfo;\n};\n\nexport type ChainInfoOrderByInput =\n  | 'count_ASC'\n  | 'count_ASC_NULLS_FIRST'\n  | 'count_DESC'\n  | 'count_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST';\n\nexport type ChainInfoWhereInput = {\n  AND?: InputMaybe<Array<ChainInfoWhereInput>>;\n  OR?: InputMaybe<Array<ChainInfoWhereInput>>;\n  count_eq?: InputMaybe<Scalars['Int']['input']>;\n  count_gt?: InputMaybe<Scalars['Int']['input']>;\n  count_gte?: InputMaybe<Scalars['Int']['input']>;\n  count_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  count_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  count_lt?: InputMaybe<Scalars['Int']['input']>;\n  count_lte?: InputMaybe<Scalars['Int']['input']>;\n  count_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  count_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n};\n\nexport type ChainInfosConnection = {\n  __typename?: 'ChainInfosConnection';\n  edges: Array<ChainInfoEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type Contract = {\n  __typename?: 'Contract';\n  bytecode: Scalars['String']['output'];\n  bytecodeArguments: Scalars['String']['output'];\n  bytecodeContext: Scalars['String']['output'];\n  extrinsic: Extrinsic;\n  gasLimit: Scalars['BigInt']['output'];\n  /** Address */\n  id: Scalars['String']['output'];\n  signer: Account;\n  storageLimit: Scalars['BigInt']['output'];\n  timestamp: Scalars['DateTime']['output'];\n};\n\nexport type ContractEdge = {\n  __typename?: 'ContractEdge';\n  cursor: Scalars['String']['output'];\n  node: Contract;\n};\n\nexport type ContractEntity = {\n  __typename?: 'ContractEntity';\n  address: Scalars['String']['output'];\n  args?: Maybe<Scalars['JSON']['output']>;\n  bytecode: Scalars['String']['output'];\n  compiledData?: Maybe<Scalars['JSON']['output']>;\n  filename?: Maybe<Scalars['String']['output']>;\n  name?: Maybe<Scalars['String']['output']>;\n  source?: Maybe<Scalars['JSON']['output']>;\n};\n\nexport type ContractOrderByInput =\n  | 'bytecodeArguments_ASC'\n  | 'bytecodeArguments_ASC_NULLS_FIRST'\n  | 'bytecodeArguments_DESC'\n  | 'bytecodeArguments_DESC_NULLS_LAST'\n  | 'bytecodeContext_ASC'\n  | 'bytecodeContext_ASC_NULLS_FIRST'\n  | 'bytecodeContext_DESC'\n  | 'bytecodeContext_DESC_NULLS_LAST'\n  | 'bytecode_ASC'\n  | 'bytecode_ASC_NULLS_FIRST'\n  | 'bytecode_DESC'\n  | 'bytecode_DESC_NULLS_LAST'\n  | 'extrinsic_docs_ASC'\n  | 'extrinsic_docs_ASC_NULLS_FIRST'\n  | 'extrinsic_docs_DESC'\n  | 'extrinsic_docs_DESC_NULLS_LAST'\n  | 'extrinsic_errorMessage_ASC'\n  | 'extrinsic_errorMessage_ASC_NULLS_FIRST'\n  | 'extrinsic_errorMessage_DESC'\n  | 'extrinsic_errorMessage_DESC_NULLS_LAST'\n  | 'extrinsic_hash_ASC'\n  | 'extrinsic_hash_ASC_NULLS_FIRST'\n  | 'extrinsic_hash_DESC'\n  | 'extrinsic_hash_DESC_NULLS_LAST'\n  | 'extrinsic_id_ASC'\n  | 'extrinsic_id_ASC_NULLS_FIRST'\n  | 'extrinsic_id_DESC'\n  | 'extrinsic_id_DESC_NULLS_LAST'\n  | 'extrinsic_index_ASC'\n  | 'extrinsic_index_ASC_NULLS_FIRST'\n  | 'extrinsic_index_DESC'\n  | 'extrinsic_index_DESC_NULLS_LAST'\n  | 'extrinsic_method_ASC'\n  | 'extrinsic_method_ASC_NULLS_FIRST'\n  | 'extrinsic_method_DESC'\n  | 'extrinsic_method_DESC_NULLS_LAST'\n  | 'extrinsic_section_ASC'\n  | 'extrinsic_section_ASC_NULLS_FIRST'\n  | 'extrinsic_section_DESC'\n  | 'extrinsic_section_DESC_NULLS_LAST'\n  | 'extrinsic_signer_ASC'\n  | 'extrinsic_signer_ASC_NULLS_FIRST'\n  | 'extrinsic_signer_DESC'\n  | 'extrinsic_signer_DESC_NULLS_LAST'\n  | 'extrinsic_status_ASC'\n  | 'extrinsic_status_ASC_NULLS_FIRST'\n  | 'extrinsic_status_DESC'\n  | 'extrinsic_status_DESC_NULLS_LAST'\n  | 'extrinsic_timestamp_ASC'\n  | 'extrinsic_timestamp_ASC_NULLS_FIRST'\n  | 'extrinsic_timestamp_DESC'\n  | 'extrinsic_timestamp_DESC_NULLS_LAST'\n  | 'extrinsic_type_ASC'\n  | 'extrinsic_type_ASC_NULLS_FIRST'\n  | 'extrinsic_type_DESC'\n  | 'extrinsic_type_DESC_NULLS_LAST'\n  | 'gasLimit_ASC'\n  | 'gasLimit_ASC_NULLS_FIRST'\n  | 'gasLimit_DESC'\n  | 'gasLimit_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'signer_active_ASC'\n  | 'signer_active_ASC_NULLS_FIRST'\n  | 'signer_active_DESC'\n  | 'signer_active_DESC_NULLS_LAST'\n  | 'signer_availableBalance_ASC'\n  | 'signer_availableBalance_ASC_NULLS_FIRST'\n  | 'signer_availableBalance_DESC'\n  | 'signer_availableBalance_DESC_NULLS_LAST'\n  | 'signer_evmAddress_ASC'\n  | 'signer_evmAddress_ASC_NULLS_FIRST'\n  | 'signer_evmAddress_DESC'\n  | 'signer_evmAddress_DESC_NULLS_LAST'\n  | 'signer_evmNonce_ASC'\n  | 'signer_evmNonce_ASC_NULLS_FIRST'\n  | 'signer_evmNonce_DESC'\n  | 'signer_evmNonce_DESC_NULLS_LAST'\n  | 'signer_freeBalance_ASC'\n  | 'signer_freeBalance_ASC_NULLS_FIRST'\n  | 'signer_freeBalance_DESC'\n  | 'signer_freeBalance_DESC_NULLS_LAST'\n  | 'signer_id_ASC'\n  | 'signer_id_ASC_NULLS_FIRST'\n  | 'signer_id_DESC'\n  | 'signer_id_DESC_NULLS_LAST'\n  | 'signer_lockedBalance_ASC'\n  | 'signer_lockedBalance_ASC_NULLS_FIRST'\n  | 'signer_lockedBalance_DESC'\n  | 'signer_lockedBalance_DESC_NULLS_LAST'\n  | 'signer_nonce_ASC'\n  | 'signer_nonce_ASC_NULLS_FIRST'\n  | 'signer_nonce_DESC'\n  | 'signer_nonce_DESC_NULLS_LAST'\n  | 'signer_reservedBalance_ASC'\n  | 'signer_reservedBalance_ASC_NULLS_FIRST'\n  | 'signer_reservedBalance_DESC'\n  | 'signer_reservedBalance_DESC_NULLS_LAST'\n  | 'signer_timestamp_ASC'\n  | 'signer_timestamp_ASC_NULLS_FIRST'\n  | 'signer_timestamp_DESC'\n  | 'signer_timestamp_DESC_NULLS_LAST'\n  | 'signer_vestedBalance_ASC'\n  | 'signer_vestedBalance_ASC_NULLS_FIRST'\n  | 'signer_vestedBalance_DESC'\n  | 'signer_vestedBalance_DESC_NULLS_LAST'\n  | 'signer_votingBalance_ASC'\n  | 'signer_votingBalance_ASC_NULLS_FIRST'\n  | 'signer_votingBalance_DESC'\n  | 'signer_votingBalance_DESC_NULLS_LAST'\n  | 'storageLimit_ASC'\n  | 'storageLimit_ASC_NULLS_FIRST'\n  | 'storageLimit_DESC'\n  | 'storageLimit_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST';\n\nexport type ContractType =\n  | 'ERC20'\n  | 'ERC721'\n  | 'ERC1155'\n  | 'other';\n\nexport type ContractWhereInput = {\n  AND?: InputMaybe<Array<ContractWhereInput>>;\n  OR?: InputMaybe<Array<ContractWhereInput>>;\n  bytecodeArguments_contains?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_endsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_eq?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_gt?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_gte?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  bytecodeArguments_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  bytecodeArguments_lt?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_lte?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_not_contains?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_not_eq?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  bytecodeArguments_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecodeArguments_startsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_contains?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_endsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_eq?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_gt?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_gte?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  bytecodeContext_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  bytecodeContext_lt?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_lte?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_not_contains?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_not_eq?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  bytecodeContext_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecodeContext_startsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecode_contains?: InputMaybe<Scalars['String']['input']>;\n  bytecode_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  bytecode_endsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecode_eq?: InputMaybe<Scalars['String']['input']>;\n  bytecode_gt?: InputMaybe<Scalars['String']['input']>;\n  bytecode_gte?: InputMaybe<Scalars['String']['input']>;\n  bytecode_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  bytecode_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  bytecode_lt?: InputMaybe<Scalars['String']['input']>;\n  bytecode_lte?: InputMaybe<Scalars['String']['input']>;\n  bytecode_not_contains?: InputMaybe<Scalars['String']['input']>;\n  bytecode_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  bytecode_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecode_not_eq?: InputMaybe<Scalars['String']['input']>;\n  bytecode_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  bytecode_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  bytecode_startsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsic?: InputMaybe<ExtrinsicWhereInput>;\n  extrinsic_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  gasLimit_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  gasLimit_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  gasLimit_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  gasLimit_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  gasLimit_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  gasLimit_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  gasLimit_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  gasLimit_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  gasLimit_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  signer?: InputMaybe<AccountWhereInput>;\n  signer_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  storageLimit_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  storageLimit_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  storageLimit_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  storageLimit_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  storageLimit_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  storageLimit_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  storageLimit_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  storageLimit_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  storageLimit_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n};\n\nexport type ContractsConnection = {\n  __typename?: 'ContractsConnection';\n  edges: Array<ContractEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type EraValidatorInfo = {\n  __typename?: 'EraValidatorInfo';\n  address: Scalars['String']['output'];\n  era: Scalars['Int']['output'];\n  /** <eventId>-<address> */\n  id: Scalars['String']['output'];\n  others: Array<Maybe<IndividualExposure>>;\n  othersWho: Scalars['String']['output'];\n  own: Scalars['BigInt']['output'];\n  total: Scalars['BigInt']['output'];\n};\n\nexport type EraValidatorInfoEdge = {\n  __typename?: 'EraValidatorInfoEdge';\n  cursor: Scalars['String']['output'];\n  node: EraValidatorInfo;\n};\n\nexport type EraValidatorInfoOrderByInput =\n  | 'address_ASC'\n  | 'address_ASC_NULLS_FIRST'\n  | 'address_DESC'\n  | 'address_DESC_NULLS_LAST'\n  | 'era_ASC'\n  | 'era_ASC_NULLS_FIRST'\n  | 'era_DESC'\n  | 'era_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'othersWho_ASC'\n  | 'othersWho_ASC_NULLS_FIRST'\n  | 'othersWho_DESC'\n  | 'othersWho_DESC_NULLS_LAST'\n  | 'own_ASC'\n  | 'own_ASC_NULLS_FIRST'\n  | 'own_DESC'\n  | 'own_DESC_NULLS_LAST'\n  | 'total_ASC'\n  | 'total_ASC_NULLS_FIRST'\n  | 'total_DESC'\n  | 'total_DESC_NULLS_LAST';\n\nexport type EraValidatorInfoWhereInput = {\n  AND?: InputMaybe<Array<EraValidatorInfoWhereInput>>;\n  OR?: InputMaybe<Array<EraValidatorInfoWhereInput>>;\n  address_contains?: InputMaybe<Scalars['String']['input']>;\n  address_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  address_endsWith?: InputMaybe<Scalars['String']['input']>;\n  address_eq?: InputMaybe<Scalars['String']['input']>;\n  address_gt?: InputMaybe<Scalars['String']['input']>;\n  address_gte?: InputMaybe<Scalars['String']['input']>;\n  address_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  address_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  address_lt?: InputMaybe<Scalars['String']['input']>;\n  address_lte?: InputMaybe<Scalars['String']['input']>;\n  address_not_contains?: InputMaybe<Scalars['String']['input']>;\n  address_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  address_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  address_not_eq?: InputMaybe<Scalars['String']['input']>;\n  address_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  address_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  address_startsWith?: InputMaybe<Scalars['String']['input']>;\n  era_eq?: InputMaybe<Scalars['Int']['input']>;\n  era_gt?: InputMaybe<Scalars['Int']['input']>;\n  era_gte?: InputMaybe<Scalars['Int']['input']>;\n  era_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  era_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  era_lt?: InputMaybe<Scalars['Int']['input']>;\n  era_lte?: InputMaybe<Scalars['Int']['input']>;\n  era_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  era_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  othersWho_contains?: InputMaybe<Scalars['String']['input']>;\n  othersWho_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  othersWho_endsWith?: InputMaybe<Scalars['String']['input']>;\n  othersWho_eq?: InputMaybe<Scalars['String']['input']>;\n  othersWho_gt?: InputMaybe<Scalars['String']['input']>;\n  othersWho_gte?: InputMaybe<Scalars['String']['input']>;\n  othersWho_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  othersWho_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  othersWho_lt?: InputMaybe<Scalars['String']['input']>;\n  othersWho_lte?: InputMaybe<Scalars['String']['input']>;\n  othersWho_not_contains?: InputMaybe<Scalars['String']['input']>;\n  othersWho_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  othersWho_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  othersWho_not_eq?: InputMaybe<Scalars['String']['input']>;\n  othersWho_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  othersWho_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  othersWho_startsWith?: InputMaybe<Scalars['String']['input']>;\n  others_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  own_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  own_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  own_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  own_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  own_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  own_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  own_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  own_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  own_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  total_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  total_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  total_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  total_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  total_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  total_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  total_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  total_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  total_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n};\n\nexport type EraValidatorInfosConnection = {\n  __typename?: 'EraValidatorInfosConnection';\n  edges: Array<EraValidatorInfoEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type Event = {\n  __typename?: 'Event';\n  block: Block;\n  data: Scalars['JSON']['output'];\n  extrinsic: Extrinsic;\n  /** 000000..00<blockNum>-<shorthash>-000<index> */\n  id: Scalars['String']['output'];\n  index: Scalars['Int']['output'];\n  method: Scalars['String']['output'];\n  phase: Scalars['String']['output'];\n  section: Scalars['String']['output'];\n  timestamp: Scalars['DateTime']['output'];\n};\n\nexport type EventEdge = {\n  __typename?: 'EventEdge';\n  cursor: Scalars['String']['output'];\n  node: Event;\n};\n\nexport type EventOrderByInput =\n  | 'block_author_ASC'\n  | 'block_author_ASC_NULLS_FIRST'\n  | 'block_author_DESC'\n  | 'block_author_DESC_NULLS_LAST'\n  | 'block_extrinsicRoot_ASC'\n  | 'block_extrinsicRoot_ASC_NULLS_FIRST'\n  | 'block_extrinsicRoot_DESC'\n  | 'block_extrinsicRoot_DESC_NULLS_LAST'\n  | 'block_finalized_ASC'\n  | 'block_finalized_ASC_NULLS_FIRST'\n  | 'block_finalized_DESC'\n  | 'block_finalized_DESC_NULLS_LAST'\n  | 'block_hash_ASC'\n  | 'block_hash_ASC_NULLS_FIRST'\n  | 'block_hash_DESC'\n  | 'block_hash_DESC_NULLS_LAST'\n  | 'block_height_ASC'\n  | 'block_height_ASC_NULLS_FIRST'\n  | 'block_height_DESC'\n  | 'block_height_DESC_NULLS_LAST'\n  | 'block_id_ASC'\n  | 'block_id_ASC_NULLS_FIRST'\n  | 'block_id_DESC'\n  | 'block_id_DESC_NULLS_LAST'\n  | 'block_parentHash_ASC'\n  | 'block_parentHash_ASC_NULLS_FIRST'\n  | 'block_parentHash_DESC'\n  | 'block_parentHash_DESC_NULLS_LAST'\n  | 'block_processorTimestamp_ASC'\n  | 'block_processorTimestamp_ASC_NULLS_FIRST'\n  | 'block_processorTimestamp_DESC'\n  | 'block_processorTimestamp_DESC_NULLS_LAST'\n  | 'block_stateRoot_ASC'\n  | 'block_stateRoot_ASC_NULLS_FIRST'\n  | 'block_stateRoot_DESC'\n  | 'block_stateRoot_DESC_NULLS_LAST'\n  | 'block_timestamp_ASC'\n  | 'block_timestamp_ASC_NULLS_FIRST'\n  | 'block_timestamp_DESC'\n  | 'block_timestamp_DESC_NULLS_LAST'\n  | 'extrinsic_docs_ASC'\n  | 'extrinsic_docs_ASC_NULLS_FIRST'\n  | 'extrinsic_docs_DESC'\n  | 'extrinsic_docs_DESC_NULLS_LAST'\n  | 'extrinsic_errorMessage_ASC'\n  | 'extrinsic_errorMessage_ASC_NULLS_FIRST'\n  | 'extrinsic_errorMessage_DESC'\n  | 'extrinsic_errorMessage_DESC_NULLS_LAST'\n  | 'extrinsic_hash_ASC'\n  | 'extrinsic_hash_ASC_NULLS_FIRST'\n  | 'extrinsic_hash_DESC'\n  | 'extrinsic_hash_DESC_NULLS_LAST'\n  | 'extrinsic_id_ASC'\n  | 'extrinsic_id_ASC_NULLS_FIRST'\n  | 'extrinsic_id_DESC'\n  | 'extrinsic_id_DESC_NULLS_LAST'\n  | 'extrinsic_index_ASC'\n  | 'extrinsic_index_ASC_NULLS_FIRST'\n  | 'extrinsic_index_DESC'\n  | 'extrinsic_index_DESC_NULLS_LAST'\n  | 'extrinsic_method_ASC'\n  | 'extrinsic_method_ASC_NULLS_FIRST'\n  | 'extrinsic_method_DESC'\n  | 'extrinsic_method_DESC_NULLS_LAST'\n  | 'extrinsic_section_ASC'\n  | 'extrinsic_section_ASC_NULLS_FIRST'\n  | 'extrinsic_section_DESC'\n  | 'extrinsic_section_DESC_NULLS_LAST'\n  | 'extrinsic_signer_ASC'\n  | 'extrinsic_signer_ASC_NULLS_FIRST'\n  | 'extrinsic_signer_DESC'\n  | 'extrinsic_signer_DESC_NULLS_LAST'\n  | 'extrinsic_status_ASC'\n  | 'extrinsic_status_ASC_NULLS_FIRST'\n  | 'extrinsic_status_DESC'\n  | 'extrinsic_status_DESC_NULLS_LAST'\n  | 'extrinsic_timestamp_ASC'\n  | 'extrinsic_timestamp_ASC_NULLS_FIRST'\n  | 'extrinsic_timestamp_DESC'\n  | 'extrinsic_timestamp_DESC_NULLS_LAST'\n  | 'extrinsic_type_ASC'\n  | 'extrinsic_type_ASC_NULLS_FIRST'\n  | 'extrinsic_type_DESC'\n  | 'extrinsic_type_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'index_ASC'\n  | 'index_ASC_NULLS_FIRST'\n  | 'index_DESC'\n  | 'index_DESC_NULLS_LAST'\n  | 'method_ASC'\n  | 'method_ASC_NULLS_FIRST'\n  | 'method_DESC'\n  | 'method_DESC_NULLS_LAST'\n  | 'phase_ASC'\n  | 'phase_ASC_NULLS_FIRST'\n  | 'phase_DESC'\n  | 'phase_DESC_NULLS_LAST'\n  | 'section_ASC'\n  | 'section_ASC_NULLS_FIRST'\n  | 'section_DESC'\n  | 'section_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST';\n\nexport type EventWhereInput = {\n  AND?: InputMaybe<Array<EventWhereInput>>;\n  OR?: InputMaybe<Array<EventWhereInput>>;\n  block?: InputMaybe<BlockWhereInput>;\n  block_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  data_eq?: InputMaybe<Scalars['JSON']['input']>;\n  data_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  data_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  data_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  data_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  extrinsic?: InputMaybe<ExtrinsicWhereInput>;\n  extrinsic_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  index_eq?: InputMaybe<Scalars['Int']['input']>;\n  index_gt?: InputMaybe<Scalars['Int']['input']>;\n  index_gte?: InputMaybe<Scalars['Int']['input']>;\n  index_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  index_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  index_lt?: InputMaybe<Scalars['Int']['input']>;\n  index_lte?: InputMaybe<Scalars['Int']['input']>;\n  index_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  index_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  method_contains?: InputMaybe<Scalars['String']['input']>;\n  method_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  method_endsWith?: InputMaybe<Scalars['String']['input']>;\n  method_eq?: InputMaybe<Scalars['String']['input']>;\n  method_gt?: InputMaybe<Scalars['String']['input']>;\n  method_gte?: InputMaybe<Scalars['String']['input']>;\n  method_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  method_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  method_lt?: InputMaybe<Scalars['String']['input']>;\n  method_lte?: InputMaybe<Scalars['String']['input']>;\n  method_not_contains?: InputMaybe<Scalars['String']['input']>;\n  method_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  method_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  method_not_eq?: InputMaybe<Scalars['String']['input']>;\n  method_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  method_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  method_startsWith?: InputMaybe<Scalars['String']['input']>;\n  phase_contains?: InputMaybe<Scalars['String']['input']>;\n  phase_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  phase_endsWith?: InputMaybe<Scalars['String']['input']>;\n  phase_eq?: InputMaybe<Scalars['String']['input']>;\n  phase_gt?: InputMaybe<Scalars['String']['input']>;\n  phase_gte?: InputMaybe<Scalars['String']['input']>;\n  phase_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  phase_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  phase_lt?: InputMaybe<Scalars['String']['input']>;\n  phase_lte?: InputMaybe<Scalars['String']['input']>;\n  phase_not_contains?: InputMaybe<Scalars['String']['input']>;\n  phase_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  phase_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  phase_not_eq?: InputMaybe<Scalars['String']['input']>;\n  phase_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  phase_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  phase_startsWith?: InputMaybe<Scalars['String']['input']>;\n  section_contains?: InputMaybe<Scalars['String']['input']>;\n  section_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  section_endsWith?: InputMaybe<Scalars['String']['input']>;\n  section_eq?: InputMaybe<Scalars['String']['input']>;\n  section_gt?: InputMaybe<Scalars['String']['input']>;\n  section_gte?: InputMaybe<Scalars['String']['input']>;\n  section_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  section_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  section_lt?: InputMaybe<Scalars['String']['input']>;\n  section_lte?: InputMaybe<Scalars['String']['input']>;\n  section_not_contains?: InputMaybe<Scalars['String']['input']>;\n  section_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  section_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  section_not_eq?: InputMaybe<Scalars['String']['input']>;\n  section_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  section_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  section_startsWith?: InputMaybe<Scalars['String']['input']>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n};\n\nexport type EventsConnection = {\n  __typename?: 'EventsConnection';\n  edges: Array<EventEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type EvmEvent = {\n  __typename?: 'EvmEvent';\n  blockHash: Scalars['String']['output'];\n  blockHeight: Scalars['Int']['output'];\n  contractAddress: Scalars['String']['output'];\n  dataParsed: Scalars['JSON']['output'];\n  dataRaw: Scalars['JSON']['output'];\n  eventIndex: Scalars['Int']['output'];\n  extrinsicHash: Scalars['String']['output'];\n  extrinsicIndex: Scalars['Int']['output'];\n  finalized: Scalars['Boolean']['output'];\n  /** 000000..00<blockNum>-<shorthash>-000<index> */\n  id: Scalars['String']['output'];\n  method: Scalars['String']['output'];\n  status: EvmEventStatus;\n  timestamp: Scalars['DateTime']['output'];\n  topic0?: Maybe<Scalars['String']['output']>;\n  topic1?: Maybe<Scalars['String']['output']>;\n  topic2?: Maybe<Scalars['String']['output']>;\n  topic3?: Maybe<Scalars['String']['output']>;\n  type: EvmEventType;\n};\n\nexport type EvmEventDataParsedInput = {\n  dataParsed: Scalars['String']['input'];\n  id: Scalars['String']['input'];\n};\n\nexport type EvmEventEdge = {\n  __typename?: 'EvmEventEdge';\n  cursor: Scalars['String']['output'];\n  node: EvmEvent;\n};\n\nexport type EvmEventEntity = {\n  __typename?: 'EvmEventEntity';\n  blockHash: Scalars['String']['output'];\n  blockHeight: Scalars['Int']['output'];\n  extrinsicHash: Scalars['String']['output'];\n  extrinsicId: Scalars['String']['output'];\n  extrinsicIndex: Scalars['Int']['output'];\n  finalized: Scalars['Boolean']['output'];\n  id: Scalars['String']['output'];\n  rawData: Scalars['JSON']['output'];\n  signedData?: Maybe<Scalars['JSON']['output']>;\n  timestamp: Scalars['DateTime']['output'];\n};\n\nexport type EvmEventOrderByInput =\n  | 'blockHash_ASC'\n  | 'blockHash_ASC_NULLS_FIRST'\n  | 'blockHash_DESC'\n  | 'blockHash_DESC_NULLS_LAST'\n  | 'blockHeight_ASC'\n  | 'blockHeight_ASC_NULLS_FIRST'\n  | 'blockHeight_DESC'\n  | 'blockHeight_DESC_NULLS_LAST'\n  | 'contractAddress_ASC'\n  | 'contractAddress_ASC_NULLS_FIRST'\n  | 'contractAddress_DESC'\n  | 'contractAddress_DESC_NULLS_LAST'\n  | 'eventIndex_ASC'\n  | 'eventIndex_ASC_NULLS_FIRST'\n  | 'eventIndex_DESC'\n  | 'eventIndex_DESC_NULLS_LAST'\n  | 'extrinsicHash_ASC'\n  | 'extrinsicHash_ASC_NULLS_FIRST'\n  | 'extrinsicHash_DESC'\n  | 'extrinsicHash_DESC_NULLS_LAST'\n  | 'extrinsicIndex_ASC'\n  | 'extrinsicIndex_ASC_NULLS_FIRST'\n  | 'extrinsicIndex_DESC'\n  | 'extrinsicIndex_DESC_NULLS_LAST'\n  | 'finalized_ASC'\n  | 'finalized_ASC_NULLS_FIRST'\n  | 'finalized_DESC'\n  | 'finalized_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'method_ASC'\n  | 'method_ASC_NULLS_FIRST'\n  | 'method_DESC'\n  | 'method_DESC_NULLS_LAST'\n  | 'status_ASC'\n  | 'status_ASC_NULLS_FIRST'\n  | 'status_DESC'\n  | 'status_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST'\n  | 'topic0_ASC'\n  | 'topic0_ASC_NULLS_FIRST'\n  | 'topic0_DESC'\n  | 'topic0_DESC_NULLS_LAST'\n  | 'topic1_ASC'\n  | 'topic1_ASC_NULLS_FIRST'\n  | 'topic1_DESC'\n  | 'topic1_DESC_NULLS_LAST'\n  | 'topic2_ASC'\n  | 'topic2_ASC_NULLS_FIRST'\n  | 'topic2_DESC'\n  | 'topic2_DESC_NULLS_LAST'\n  | 'topic3_ASC'\n  | 'topic3_ASC_NULLS_FIRST'\n  | 'topic3_DESC'\n  | 'topic3_DESC_NULLS_LAST'\n  | 'type_ASC'\n  | 'type_ASC_NULLS_FIRST'\n  | 'type_DESC'\n  | 'type_DESC_NULLS_LAST';\n\nexport type EvmEventStatus =\n  | 'Error'\n  | 'Success';\n\nexport type EvmEventType =\n  | 'Unverified'\n  | 'Verified';\n\nexport type EvmEventWhereInput = {\n  AND?: InputMaybe<Array<EvmEventWhereInput>>;\n  OR?: InputMaybe<Array<EvmEventWhereInput>>;\n  blockHash_contains?: InputMaybe<Scalars['String']['input']>;\n  blockHash_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  blockHash_endsWith?: InputMaybe<Scalars['String']['input']>;\n  blockHash_eq?: InputMaybe<Scalars['String']['input']>;\n  blockHash_gt?: InputMaybe<Scalars['String']['input']>;\n  blockHash_gte?: InputMaybe<Scalars['String']['input']>;\n  blockHash_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  blockHash_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  blockHash_lt?: InputMaybe<Scalars['String']['input']>;\n  blockHash_lte?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_contains?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_eq?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  blockHash_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  blockHash_startsWith?: InputMaybe<Scalars['String']['input']>;\n  blockHeight_eq?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_gt?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_gte?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  blockHeight_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  blockHeight_lt?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_lte?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  contractAddress_contains?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_endsWith?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_eq?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_gt?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_gte?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  contractAddress_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  contractAddress_lt?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_lte?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_not_contains?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_not_eq?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  contractAddress_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  contractAddress_startsWith?: InputMaybe<Scalars['String']['input']>;\n  dataParsed_eq?: InputMaybe<Scalars['JSON']['input']>;\n  dataParsed_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  dataParsed_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  dataParsed_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  dataParsed_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  dataRaw_eq?: InputMaybe<Scalars['JSON']['input']>;\n  dataRaw_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  dataRaw_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  dataRaw_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  dataRaw_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  eventIndex_eq?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_gt?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_gte?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  eventIndex_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  eventIndex_lt?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_lte?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  extrinsicHash_contains?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_endsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_eq?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_gt?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_gte?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  extrinsicHash_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  extrinsicHash_lt?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_lte?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_contains?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_eq?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  extrinsicHash_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_startsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicIndex_eq?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_gt?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_gte?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  extrinsicIndex_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  extrinsicIndex_lt?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_lte?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  finalized_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  finalized_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  finalized_not_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  method_contains?: InputMaybe<Scalars['String']['input']>;\n  method_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  method_endsWith?: InputMaybe<Scalars['String']['input']>;\n  method_eq?: InputMaybe<Scalars['String']['input']>;\n  method_gt?: InputMaybe<Scalars['String']['input']>;\n  method_gte?: InputMaybe<Scalars['String']['input']>;\n  method_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  method_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  method_lt?: InputMaybe<Scalars['String']['input']>;\n  method_lte?: InputMaybe<Scalars['String']['input']>;\n  method_not_contains?: InputMaybe<Scalars['String']['input']>;\n  method_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  method_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  method_not_eq?: InputMaybe<Scalars['String']['input']>;\n  method_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  method_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  method_startsWith?: InputMaybe<Scalars['String']['input']>;\n  status_eq?: InputMaybe<EvmEventStatus>;\n  status_in?: InputMaybe<Array<EvmEventStatus>>;\n  status_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  status_not_eq?: InputMaybe<EvmEventStatus>;\n  status_not_in?: InputMaybe<Array<EvmEventStatus>>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  topic0_contains?: InputMaybe<Scalars['String']['input']>;\n  topic0_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  topic0_endsWith?: InputMaybe<Scalars['String']['input']>;\n  topic0_eq?: InputMaybe<Scalars['String']['input']>;\n  topic0_gt?: InputMaybe<Scalars['String']['input']>;\n  topic0_gte?: InputMaybe<Scalars['String']['input']>;\n  topic0_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  topic0_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  topic0_lt?: InputMaybe<Scalars['String']['input']>;\n  topic0_lte?: InputMaybe<Scalars['String']['input']>;\n  topic0_not_contains?: InputMaybe<Scalars['String']['input']>;\n  topic0_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  topic0_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  topic0_not_eq?: InputMaybe<Scalars['String']['input']>;\n  topic0_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  topic0_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  topic0_startsWith?: InputMaybe<Scalars['String']['input']>;\n  topic1_contains?: InputMaybe<Scalars['String']['input']>;\n  topic1_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  topic1_endsWith?: InputMaybe<Scalars['String']['input']>;\n  topic1_eq?: InputMaybe<Scalars['String']['input']>;\n  topic1_gt?: InputMaybe<Scalars['String']['input']>;\n  topic1_gte?: InputMaybe<Scalars['String']['input']>;\n  topic1_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  topic1_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  topic1_lt?: InputMaybe<Scalars['String']['input']>;\n  topic1_lte?: InputMaybe<Scalars['String']['input']>;\n  topic1_not_contains?: InputMaybe<Scalars['String']['input']>;\n  topic1_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  topic1_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  topic1_not_eq?: InputMaybe<Scalars['String']['input']>;\n  topic1_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  topic1_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  topic1_startsWith?: InputMaybe<Scalars['String']['input']>;\n  topic2_contains?: InputMaybe<Scalars['String']['input']>;\n  topic2_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  topic2_endsWith?: InputMaybe<Scalars['String']['input']>;\n  topic2_eq?: InputMaybe<Scalars['String']['input']>;\n  topic2_gt?: InputMaybe<Scalars['String']['input']>;\n  topic2_gte?: InputMaybe<Scalars['String']['input']>;\n  topic2_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  topic2_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  topic2_lt?: InputMaybe<Scalars['String']['input']>;\n  topic2_lte?: InputMaybe<Scalars['String']['input']>;\n  topic2_not_contains?: InputMaybe<Scalars['String']['input']>;\n  topic2_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  topic2_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  topic2_not_eq?: InputMaybe<Scalars['String']['input']>;\n  topic2_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  topic2_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  topic2_startsWith?: InputMaybe<Scalars['String']['input']>;\n  topic3_contains?: InputMaybe<Scalars['String']['input']>;\n  topic3_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  topic3_endsWith?: InputMaybe<Scalars['String']['input']>;\n  topic3_eq?: InputMaybe<Scalars['String']['input']>;\n  topic3_gt?: InputMaybe<Scalars['String']['input']>;\n  topic3_gte?: InputMaybe<Scalars['String']['input']>;\n  topic3_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  topic3_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  topic3_lt?: InputMaybe<Scalars['String']['input']>;\n  topic3_lte?: InputMaybe<Scalars['String']['input']>;\n  topic3_not_contains?: InputMaybe<Scalars['String']['input']>;\n  topic3_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  topic3_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  topic3_not_eq?: InputMaybe<Scalars['String']['input']>;\n  topic3_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  topic3_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  topic3_startsWith?: InputMaybe<Scalars['String']['input']>;\n  type_eq?: InputMaybe<EvmEventType>;\n  type_in?: InputMaybe<Array<EvmEventType>>;\n  type_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  type_not_eq?: InputMaybe<EvmEventType>;\n  type_not_in?: InputMaybe<Array<EvmEventType>>;\n};\n\nexport type EvmEventsConnection = {\n  __typename?: 'EvmEventsConnection';\n  edges: Array<EvmEventEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type Extrinsic = {\n  __typename?: 'Extrinsic';\n  args: Scalars['JSON']['output'];\n  block: Block;\n  contracts: Array<Contract>;\n  docs: Scalars['String']['output'];\n  errorMessage?: Maybe<Scalars['String']['output']>;\n  events: Array<Event>;\n  hash: Scalars['String']['output'];\n  /** 000000..00<blockNum>-<shorthash>-000<index> */\n  id: Scalars['String']['output'];\n  index: Scalars['Int']['output'];\n  method: Scalars['String']['output'];\n  section: Scalars['String']['output'];\n  signedData?: Maybe<Scalars['JSON']['output']>;\n  signer: Scalars['String']['output'];\n  status: ExtrinsicStatus;\n  timestamp: Scalars['DateTime']['output'];\n  type: ExtrinsicType;\n};\n\n\nexport type ExtrinsicContractsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ContractOrderByInput>>;\n  where?: InputMaybe<ContractWhereInput>;\n};\n\n\nexport type ExtrinsicEventsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EventOrderByInput>>;\n  where?: InputMaybe<EventWhereInput>;\n};\n\nexport type ExtrinsicEdge = {\n  __typename?: 'ExtrinsicEdge';\n  cursor: Scalars['String']['output'];\n  node: Extrinsic;\n};\n\nexport type ExtrinsicOrderByInput =\n  | 'block_author_ASC'\n  | 'block_author_ASC_NULLS_FIRST'\n  | 'block_author_DESC'\n  | 'block_author_DESC_NULLS_LAST'\n  | 'block_extrinsicRoot_ASC'\n  | 'block_extrinsicRoot_ASC_NULLS_FIRST'\n  | 'block_extrinsicRoot_DESC'\n  | 'block_extrinsicRoot_DESC_NULLS_LAST'\n  | 'block_finalized_ASC'\n  | 'block_finalized_ASC_NULLS_FIRST'\n  | 'block_finalized_DESC'\n  | 'block_finalized_DESC_NULLS_LAST'\n  | 'block_hash_ASC'\n  | 'block_hash_ASC_NULLS_FIRST'\n  | 'block_hash_DESC'\n  | 'block_hash_DESC_NULLS_LAST'\n  | 'block_height_ASC'\n  | 'block_height_ASC_NULLS_FIRST'\n  | 'block_height_DESC'\n  | 'block_height_DESC_NULLS_LAST'\n  | 'block_id_ASC'\n  | 'block_id_ASC_NULLS_FIRST'\n  | 'block_id_DESC'\n  | 'block_id_DESC_NULLS_LAST'\n  | 'block_parentHash_ASC'\n  | 'block_parentHash_ASC_NULLS_FIRST'\n  | 'block_parentHash_DESC'\n  | 'block_parentHash_DESC_NULLS_LAST'\n  | 'block_processorTimestamp_ASC'\n  | 'block_processorTimestamp_ASC_NULLS_FIRST'\n  | 'block_processorTimestamp_DESC'\n  | 'block_processorTimestamp_DESC_NULLS_LAST'\n  | 'block_stateRoot_ASC'\n  | 'block_stateRoot_ASC_NULLS_FIRST'\n  | 'block_stateRoot_DESC'\n  | 'block_stateRoot_DESC_NULLS_LAST'\n  | 'block_timestamp_ASC'\n  | 'block_timestamp_ASC_NULLS_FIRST'\n  | 'block_timestamp_DESC'\n  | 'block_timestamp_DESC_NULLS_LAST'\n  | 'docs_ASC'\n  | 'docs_ASC_NULLS_FIRST'\n  | 'docs_DESC'\n  | 'docs_DESC_NULLS_LAST'\n  | 'errorMessage_ASC'\n  | 'errorMessage_ASC_NULLS_FIRST'\n  | 'errorMessage_DESC'\n  | 'errorMessage_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC'\n  | 'hash_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'index_ASC'\n  | 'index_ASC_NULLS_FIRST'\n  | 'index_DESC'\n  | 'index_DESC_NULLS_LAST'\n  | 'method_ASC'\n  | 'method_ASC_NULLS_FIRST'\n  | 'method_DESC'\n  | 'method_DESC_NULLS_LAST'\n  | 'section_ASC'\n  | 'section_ASC_NULLS_FIRST'\n  | 'section_DESC'\n  | 'section_DESC_NULLS_LAST'\n  | 'signer_ASC'\n  | 'signer_ASC_NULLS_FIRST'\n  | 'signer_DESC'\n  | 'signer_DESC_NULLS_LAST'\n  | 'status_ASC'\n  | 'status_ASC_NULLS_FIRST'\n  | 'status_DESC'\n  | 'status_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST'\n  | 'type_ASC'\n  | 'type_ASC_NULLS_FIRST'\n  | 'type_DESC'\n  | 'type_DESC_NULLS_LAST';\n\nexport type ExtrinsicStatus =\n  | 'error'\n  | 'success'\n  | 'unknown';\n\nexport type ExtrinsicType =\n  | 'inherent'\n  | 'signed'\n  | 'unsigned';\n\nexport type ExtrinsicWhereInput = {\n  AND?: InputMaybe<Array<ExtrinsicWhereInput>>;\n  OR?: InputMaybe<Array<ExtrinsicWhereInput>>;\n  args_eq?: InputMaybe<Scalars['JSON']['input']>;\n  args_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  args_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  args_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  args_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  block?: InputMaybe<BlockWhereInput>;\n  block_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  contracts_every?: InputMaybe<ContractWhereInput>;\n  contracts_none?: InputMaybe<ContractWhereInput>;\n  contracts_some?: InputMaybe<ContractWhereInput>;\n  docs_contains?: InputMaybe<Scalars['String']['input']>;\n  docs_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  docs_endsWith?: InputMaybe<Scalars['String']['input']>;\n  docs_eq?: InputMaybe<Scalars['String']['input']>;\n  docs_gt?: InputMaybe<Scalars['String']['input']>;\n  docs_gte?: InputMaybe<Scalars['String']['input']>;\n  docs_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  docs_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  docs_lt?: InputMaybe<Scalars['String']['input']>;\n  docs_lte?: InputMaybe<Scalars['String']['input']>;\n  docs_not_contains?: InputMaybe<Scalars['String']['input']>;\n  docs_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  docs_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  docs_not_eq?: InputMaybe<Scalars['String']['input']>;\n  docs_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  docs_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  docs_startsWith?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_contains?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_endsWith?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_eq?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_gt?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_gte?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  errorMessage_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  errorMessage_lt?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_lte?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_contains?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_eq?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  errorMessage_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_startsWith?: InputMaybe<Scalars['String']['input']>;\n  events_every?: InputMaybe<EventWhereInput>;\n  events_none?: InputMaybe<EventWhereInput>;\n  events_some?: InputMaybe<EventWhereInput>;\n  hash_contains?: InputMaybe<Scalars['String']['input']>;\n  hash_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  hash_endsWith?: InputMaybe<Scalars['String']['input']>;\n  hash_eq?: InputMaybe<Scalars['String']['input']>;\n  hash_gt?: InputMaybe<Scalars['String']['input']>;\n  hash_gte?: InputMaybe<Scalars['String']['input']>;\n  hash_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  hash_lt?: InputMaybe<Scalars['String']['input']>;\n  hash_lte?: InputMaybe<Scalars['String']['input']>;\n  hash_not_contains?: InputMaybe<Scalars['String']['input']>;\n  hash_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  hash_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  hash_not_eq?: InputMaybe<Scalars['String']['input']>;\n  hash_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  hash_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  hash_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  index_eq?: InputMaybe<Scalars['Int']['input']>;\n  index_gt?: InputMaybe<Scalars['Int']['input']>;\n  index_gte?: InputMaybe<Scalars['Int']['input']>;\n  index_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  index_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  index_lt?: InputMaybe<Scalars['Int']['input']>;\n  index_lte?: InputMaybe<Scalars['Int']['input']>;\n  index_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  index_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  method_contains?: InputMaybe<Scalars['String']['input']>;\n  method_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  method_endsWith?: InputMaybe<Scalars['String']['input']>;\n  method_eq?: InputMaybe<Scalars['String']['input']>;\n  method_gt?: InputMaybe<Scalars['String']['input']>;\n  method_gte?: InputMaybe<Scalars['String']['input']>;\n  method_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  method_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  method_lt?: InputMaybe<Scalars['String']['input']>;\n  method_lte?: InputMaybe<Scalars['String']['input']>;\n  method_not_contains?: InputMaybe<Scalars['String']['input']>;\n  method_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  method_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  method_not_eq?: InputMaybe<Scalars['String']['input']>;\n  method_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  method_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  method_startsWith?: InputMaybe<Scalars['String']['input']>;\n  section_contains?: InputMaybe<Scalars['String']['input']>;\n  section_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  section_endsWith?: InputMaybe<Scalars['String']['input']>;\n  section_eq?: InputMaybe<Scalars['String']['input']>;\n  section_gt?: InputMaybe<Scalars['String']['input']>;\n  section_gte?: InputMaybe<Scalars['String']['input']>;\n  section_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  section_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  section_lt?: InputMaybe<Scalars['String']['input']>;\n  section_lte?: InputMaybe<Scalars['String']['input']>;\n  section_not_contains?: InputMaybe<Scalars['String']['input']>;\n  section_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  section_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  section_not_eq?: InputMaybe<Scalars['String']['input']>;\n  section_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  section_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  section_startsWith?: InputMaybe<Scalars['String']['input']>;\n  signedData_eq?: InputMaybe<Scalars['JSON']['input']>;\n  signedData_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  signedData_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  signedData_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  signedData_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  signer_contains?: InputMaybe<Scalars['String']['input']>;\n  signer_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  signer_endsWith?: InputMaybe<Scalars['String']['input']>;\n  signer_eq?: InputMaybe<Scalars['String']['input']>;\n  signer_gt?: InputMaybe<Scalars['String']['input']>;\n  signer_gte?: InputMaybe<Scalars['String']['input']>;\n  signer_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  signer_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  signer_lt?: InputMaybe<Scalars['String']['input']>;\n  signer_lte?: InputMaybe<Scalars['String']['input']>;\n  signer_not_contains?: InputMaybe<Scalars['String']['input']>;\n  signer_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  signer_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  signer_not_eq?: InputMaybe<Scalars['String']['input']>;\n  signer_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  signer_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  signer_startsWith?: InputMaybe<Scalars['String']['input']>;\n  status_eq?: InputMaybe<ExtrinsicStatus>;\n  status_in?: InputMaybe<Array<ExtrinsicStatus>>;\n  status_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  status_not_eq?: InputMaybe<ExtrinsicStatus>;\n  status_not_in?: InputMaybe<Array<ExtrinsicStatus>>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  type_eq?: InputMaybe<ExtrinsicType>;\n  type_in?: InputMaybe<Array<ExtrinsicType>>;\n  type_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  type_not_eq?: InputMaybe<ExtrinsicType>;\n  type_not_in?: InputMaybe<Array<ExtrinsicType>>;\n};\n\nexport type ExtrinsicsConnection = {\n  __typename?: 'ExtrinsicsConnection';\n  edges: Array<ExtrinsicEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type IndividualExposure = {\n  __typename?: 'IndividualExposure';\n  value: Scalars['String']['output'];\n  who: Scalars['String']['output'];\n};\n\nexport type Mutation = {\n  __typename?: 'Mutation';\n  deleteNewlyVerifiedContractQueue: Scalars['Boolean']['output'];\n  newFinalizedBlock: Scalars['Boolean']['output'];\n  saveContract: Scalars['Boolean']['output'];\n  saveTokenHolders: Scalars['Boolean']['output'];\n  saveTransfers: Scalars['Boolean']['output'];\n  saveVerificationRequest: Scalars['Boolean']['output'];\n  saveVerifiedContract: Scalars['Boolean']['output'];\n  updateEvmEventsDataParsed: Scalars['Boolean']['output'];\n  updateVerifiedContractApproved: Scalars['Boolean']['output'];\n  updateVerifiedContractData: Scalars['Boolean']['output'];\n};\n\n\nexport type MutationDeleteNewlyVerifiedContractQueueArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type MutationNewFinalizedBlockArgs = {\n  height: Scalars['Float']['input'];\n};\n\n\nexport type MutationSaveContractArgs = {\n  bytecode: Scalars['String']['input'];\n  bytecodeArguments: Scalars['String']['input'];\n  bytecodeContext: Scalars['String']['input'];\n  extrinsicId: Scalars['String']['input'];\n  gasLimit: Scalars['String']['input'];\n  id: Scalars['String']['input'];\n  signerAddress: Scalars['String']['input'];\n  storageLimit: Scalars['String']['input'];\n  timestamp: Scalars['Float']['input'];\n};\n\n\nexport type MutationSaveTokenHoldersArgs = {\n  tokenHolders: Array<TokenHolderInput>;\n};\n\n\nexport type MutationSaveTransfersArgs = {\n  transfers: Array<TransferInput>;\n};\n\n\nexport type MutationSaveVerificationRequestArgs = {\n  args: Scalars['String']['input'];\n  compilerVersion: Scalars['String']['input'];\n  filename: Scalars['String']['input'];\n  id: Scalars['String']['input'];\n  license: Scalars['String']['input'];\n  message: Scalars['String']['input'];\n  name: Scalars['String']['input'];\n  optimization: Scalars['Boolean']['input'];\n  runs: Scalars['Float']['input'];\n  source: Scalars['String']['input'];\n  success: Scalars['Boolean']['input'];\n  target: Scalars['String']['input'];\n  timestamp: Scalars['Float']['input'];\n};\n\n\nexport type MutationSaveVerifiedContractArgs = {\n  approved: Scalars['Boolean']['input'];\n  args: Scalars['String']['input'];\n  compiledData: Scalars['String']['input'];\n  compilerVersion: Scalars['String']['input'];\n  contractData: Scalars['String']['input'];\n  filename: Scalars['String']['input'];\n  id: Scalars['String']['input'];\n  license: Scalars['String']['input'];\n  name: Scalars['String']['input'];\n  optimization: Scalars['Boolean']['input'];\n  runs: Scalars['Float']['input'];\n  source: Scalars['String']['input'];\n  target: Scalars['String']['input'];\n  timestamp: Scalars['Float']['input'];\n  type: Scalars['String']['input'];\n};\n\n\nexport type MutationUpdateEvmEventsDataParsedArgs = {\n  evmEvents: Array<EvmEventDataParsedInput>;\n};\n\n\nexport type MutationUpdateVerifiedContractApprovedArgs = {\n  approved: Scalars['Boolean']['input'];\n  id: Scalars['String']['input'];\n};\n\n\nexport type MutationUpdateVerifiedContractDataArgs = {\n  contractData: Scalars['String']['input'];\n  id: Scalars['String']['input'];\n};\n\nexport type NewlyVerifiedContractQueue = {\n  __typename?: 'NewlyVerifiedContractQueue';\n  id: Scalars['String']['output'];\n};\n\nexport type NewlyVerifiedContractQueueEdge = {\n  __typename?: 'NewlyVerifiedContractQueueEdge';\n  cursor: Scalars['String']['output'];\n  node: NewlyVerifiedContractQueue;\n};\n\nexport type NewlyVerifiedContractQueueOrderByInput =\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST';\n\nexport type NewlyVerifiedContractQueueWhereInput = {\n  AND?: InputMaybe<Array<NewlyVerifiedContractQueueWhereInput>>;\n  OR?: InputMaybe<Array<NewlyVerifiedContractQueueWhereInput>>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n};\n\nexport type NewlyVerifiedContractQueuesConnection = {\n  __typename?: 'NewlyVerifiedContractQueuesConnection';\n  edges: Array<NewlyVerifiedContractQueueEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type PageInfo = {\n  __typename?: 'PageInfo';\n  endCursor: Scalars['String']['output'];\n  hasNextPage: Scalars['Boolean']['output'];\n  hasPreviousPage: Scalars['Boolean']['output'];\n  startCursor: Scalars['String']['output'];\n};\n\nexport type Ping = {\n  __typename?: 'Ping';\n  message: Scalars['String']['output'];\n};\n\nexport type Query = {\n  __typename?: 'Query';\n  accountById?: Maybe<Account>;\n  /** @deprecated Use accountById */\n  accountByUniqueInput?: Maybe<Account>;\n  accounts: Array<Account>;\n  accountsConnection: AccountsConnection;\n  blockById?: Maybe<Block>;\n  /** @deprecated Use blockById */\n  blockByUniqueInput?: Maybe<Block>;\n  blocks: Array<Block>;\n  blocksConnection: BlocksConnection;\n  chainInfoById?: Maybe<ChainInfo>;\n  /** @deprecated Use chainInfoById */\n  chainInfoByUniqueInput?: Maybe<ChainInfo>;\n  chainInfos: Array<ChainInfo>;\n  chainInfosConnection: ChainInfosConnection;\n  contractById?: Maybe<Contract>;\n  /** @deprecated Use contractById */\n  contractByUniqueInput?: Maybe<Contract>;\n  contracts: Array<Contract>;\n  contractsConnection: ContractsConnection;\n  eraValidatorInfoById?: Maybe<EraValidatorInfo>;\n  /** @deprecated Use eraValidatorInfoById */\n  eraValidatorInfoByUniqueInput?: Maybe<EraValidatorInfo>;\n  eraValidatorInfos: Array<EraValidatorInfo>;\n  eraValidatorInfosConnection: EraValidatorInfosConnection;\n  eventById?: Maybe<Event>;\n  /** @deprecated Use eventById */\n  eventByUniqueInput?: Maybe<Event>;\n  events: Array<Event>;\n  eventsConnection: EventsConnection;\n  evmEventById?: Maybe<EvmEvent>;\n  /** @deprecated Use evmEventById */\n  evmEventByUniqueInput?: Maybe<EvmEvent>;\n  evmEvents: Array<EvmEvent>;\n  evmEventsConnection: EvmEventsConnection;\n  extrinsicById?: Maybe<Extrinsic>;\n  /** @deprecated Use extrinsicById */\n  extrinsicByUniqueInput?: Maybe<Extrinsic>;\n  extrinsics: Array<Extrinsic>;\n  extrinsicsConnection: ExtrinsicsConnection;\n  findBacktrackingEvmEvents: Array<EvmEventEntity>;\n  findContract: Array<ContractEntity>;\n  newlyVerifiedContractQueueById?: Maybe<NewlyVerifiedContractQueue>;\n  /** @deprecated Use newlyVerifiedContractQueueById */\n  newlyVerifiedContractQueueByUniqueInput?: Maybe<NewlyVerifiedContractQueue>;\n  newlyVerifiedContractQueues: Array<NewlyVerifiedContractQueue>;\n  newlyVerifiedContractQueuesConnection: NewlyVerifiedContractQueuesConnection;\n  ping: Ping;\n  squidStatus?: Maybe<SquidStatus>;\n  stakingById?: Maybe<Staking>;\n  /** @deprecated Use stakingById */\n  stakingByUniqueInput?: Maybe<Staking>;\n  stakings: Array<Staking>;\n  stakingsConnection: StakingsConnection;\n  tokenHolderById?: Maybe<TokenHolder>;\n  /** @deprecated Use tokenHolderById */\n  tokenHolderByUniqueInput?: Maybe<TokenHolder>;\n  tokenHolders: Array<TokenHolder>;\n  tokenHoldersConnection: TokenHoldersConnection;\n  tokenHoldersCount: TokenHolderCount;\n  transferById?: Maybe<Transfer>;\n  /** @deprecated Use transferById */\n  transferByUniqueInput?: Maybe<Transfer>;\n  transfers: Array<Transfer>;\n  transfersConnection: TransfersConnection;\n  verificationRequestById?: Maybe<VerificationRequest>;\n  /** @deprecated Use verificationRequestById */\n  verificationRequestByUniqueInput?: Maybe<VerificationRequest>;\n  verificationRequests: Array<VerificationRequest>;\n  verificationRequestsConnection: VerificationRequestsConnection;\n  verifiedContractById?: Maybe<VerifiedContract>;\n  /** @deprecated Use verifiedContractById */\n  verifiedContractByUniqueInput?: Maybe<VerifiedContract>;\n  verifiedContracts: Array<VerifiedContract>;\n  verifiedContractsConnection: VerifiedContractsConnection;\n};\n\n\nexport type QueryAccountByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryAccountByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryAccountsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AccountOrderByInput>>;\n  where?: InputMaybe<AccountWhereInput>;\n};\n\n\nexport type QueryAccountsConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<AccountOrderByInput>;\n  where?: InputMaybe<AccountWhereInput>;\n};\n\n\nexport type QueryBlockByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryBlockByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryBlocksArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<BlockOrderByInput>>;\n  where?: InputMaybe<BlockWhereInput>;\n};\n\n\nexport type QueryBlocksConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<BlockOrderByInput>;\n  where?: InputMaybe<BlockWhereInput>;\n};\n\n\nexport type QueryChainInfoByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryChainInfoByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryChainInfosArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ChainInfoOrderByInput>>;\n  where?: InputMaybe<ChainInfoWhereInput>;\n};\n\n\nexport type QueryChainInfosConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<ChainInfoOrderByInput>;\n  where?: InputMaybe<ChainInfoWhereInput>;\n};\n\n\nexport type QueryContractByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryContractByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryContractsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ContractOrderByInput>>;\n  where?: InputMaybe<ContractWhereInput>;\n};\n\n\nexport type QueryContractsConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<ContractOrderByInput>;\n  where?: InputMaybe<ContractWhereInput>;\n};\n\n\nexport type QueryEraValidatorInfoByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryEraValidatorInfoByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryEraValidatorInfosArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EraValidatorInfoOrderByInput>>;\n  where?: InputMaybe<EraValidatorInfoWhereInput>;\n};\n\n\nexport type QueryEraValidatorInfosConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<EraValidatorInfoOrderByInput>;\n  where?: InputMaybe<EraValidatorInfoWhereInput>;\n};\n\n\nexport type QueryEventByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryEventByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryEventsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EventOrderByInput>>;\n  where?: InputMaybe<EventWhereInput>;\n};\n\n\nexport type QueryEventsConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<EventOrderByInput>;\n  where?: InputMaybe<EventWhereInput>;\n};\n\n\nexport type QueryEvmEventByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryEvmEventByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryEvmEventsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EvmEventOrderByInput>>;\n  where?: InputMaybe<EvmEventWhereInput>;\n};\n\n\nexport type QueryEvmEventsConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<EvmEventOrderByInput>;\n  where?: InputMaybe<EvmEventWhereInput>;\n};\n\n\nexport type QueryExtrinsicByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryExtrinsicByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryExtrinsicsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ExtrinsicOrderByInput>>;\n  where?: InputMaybe<ExtrinsicWhereInput>;\n};\n\n\nexport type QueryExtrinsicsConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<ExtrinsicOrderByInput>;\n  where?: InputMaybe<ExtrinsicWhereInput>;\n};\n\n\nexport type QueryFindBacktrackingEvmEventsArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryFindContractArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryNewlyVerifiedContractQueueByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryNewlyVerifiedContractQueueByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryNewlyVerifiedContractQueuesArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<NewlyVerifiedContractQueueOrderByInput>>;\n  where?: InputMaybe<NewlyVerifiedContractQueueWhereInput>;\n};\n\n\nexport type QueryNewlyVerifiedContractQueuesConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<NewlyVerifiedContractQueueOrderByInput>;\n  where?: InputMaybe<NewlyVerifiedContractQueueWhereInput>;\n};\n\n\nexport type QueryStakingByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryStakingByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryStakingsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<StakingOrderByInput>>;\n  where?: InputMaybe<StakingWhereInput>;\n};\n\n\nexport type QueryStakingsConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<StakingOrderByInput>;\n  where?: InputMaybe<StakingWhereInput>;\n};\n\n\nexport type QueryTokenHolderByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryTokenHolderByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryTokenHoldersArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<TokenHolderOrderByInput>>;\n  where?: InputMaybe<TokenHolderWhereInput>;\n};\n\n\nexport type QueryTokenHoldersConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<TokenHolderOrderByInput>;\n  where?: InputMaybe<TokenHolderWhereInput>;\n};\n\n\nexport type QueryTokenHoldersCountArgs = {\n  tokenId: Scalars['String']['input'];\n};\n\n\nexport type QueryTransferByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryTransferByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryTransfersArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<TransferOrderByInput>>;\n  where?: InputMaybe<TransferWhereInput>;\n};\n\n\nexport type QueryTransfersConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<TransferOrderByInput>;\n  where?: InputMaybe<TransferWhereInput>;\n};\n\n\nexport type QueryVerificationRequestByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryVerificationRequestByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryVerificationRequestsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<VerificationRequestOrderByInput>>;\n  where?: InputMaybe<VerificationRequestWhereInput>;\n};\n\n\nexport type QueryVerificationRequestsConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<VerificationRequestOrderByInput>;\n  where?: InputMaybe<VerificationRequestWhereInput>;\n};\n\n\nexport type QueryVerifiedContractByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type QueryVerifiedContractByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryVerifiedContractsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<VerifiedContractOrderByInput>>;\n  where?: InputMaybe<VerifiedContractWhereInput>;\n};\n\n\nexport type QueryVerifiedContractsConnectionArgs = {\n  after?: InputMaybe<Scalars['String']['input']>;\n  first?: InputMaybe<Scalars['Int']['input']>;\n  orderBy: Array<VerifiedContractOrderByInput>;\n  where?: InputMaybe<VerifiedContractWhereInput>;\n};\n\nexport type ReefswapAction =\n  | 'AddLiquidity'\n  | 'RemoveLiquidity'\n  | 'Swap';\n\nexport type SquidStatus = {\n  __typename?: 'SquidStatus';\n  /** The height of the processed part of the chain */\n  height?: Maybe<Scalars['Int']['output']>;\n};\n\nexport type Staking = {\n  __typename?: 'Staking';\n  amount: Scalars['BigInt']['output'];\n  event?: Maybe<Event>;\n  id: Scalars['String']['output'];\n  signer?: Maybe<Account>;\n  timestamp: Scalars['DateTime']['output'];\n  type: StakingType;\n};\n\nexport type StakingEdge = {\n  __typename?: 'StakingEdge';\n  cursor: Scalars['String']['output'];\n  node: Staking;\n};\n\nexport type StakingOrderByInput =\n  | 'amount_ASC'\n  | 'amount_ASC_NULLS_FIRST'\n  | 'amount_DESC'\n  | 'amount_DESC_NULLS_LAST'\n  | 'event_id_ASC'\n  | 'event_id_ASC_NULLS_FIRST'\n  | 'event_id_DESC'\n  | 'event_id_DESC_NULLS_LAST'\n  | 'event_index_ASC'\n  | 'event_index_ASC_NULLS_FIRST'\n  | 'event_index_DESC'\n  | 'event_index_DESC_NULLS_LAST'\n  | 'event_method_ASC'\n  | 'event_method_ASC_NULLS_FIRST'\n  | 'event_method_DESC'\n  | 'event_method_DESC_NULLS_LAST'\n  | 'event_phase_ASC'\n  | 'event_phase_ASC_NULLS_FIRST'\n  | 'event_phase_DESC'\n  | 'event_phase_DESC_NULLS_LAST'\n  | 'event_section_ASC'\n  | 'event_section_ASC_NULLS_FIRST'\n  | 'event_section_DESC'\n  | 'event_section_DESC_NULLS_LAST'\n  | 'event_timestamp_ASC'\n  | 'event_timestamp_ASC_NULLS_FIRST'\n  | 'event_timestamp_DESC'\n  | 'event_timestamp_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'signer_active_ASC'\n  | 'signer_active_ASC_NULLS_FIRST'\n  | 'signer_active_DESC'\n  | 'signer_active_DESC_NULLS_LAST'\n  | 'signer_availableBalance_ASC'\n  | 'signer_availableBalance_ASC_NULLS_FIRST'\n  | 'signer_availableBalance_DESC'\n  | 'signer_availableBalance_DESC_NULLS_LAST'\n  | 'signer_evmAddress_ASC'\n  | 'signer_evmAddress_ASC_NULLS_FIRST'\n  | 'signer_evmAddress_DESC'\n  | 'signer_evmAddress_DESC_NULLS_LAST'\n  | 'signer_evmNonce_ASC'\n  | 'signer_evmNonce_ASC_NULLS_FIRST'\n  | 'signer_evmNonce_DESC'\n  | 'signer_evmNonce_DESC_NULLS_LAST'\n  | 'signer_freeBalance_ASC'\n  | 'signer_freeBalance_ASC_NULLS_FIRST'\n  | 'signer_freeBalance_DESC'\n  | 'signer_freeBalance_DESC_NULLS_LAST'\n  | 'signer_id_ASC'\n  | 'signer_id_ASC_NULLS_FIRST'\n  | 'signer_id_DESC'\n  | 'signer_id_DESC_NULLS_LAST'\n  | 'signer_lockedBalance_ASC'\n  | 'signer_lockedBalance_ASC_NULLS_FIRST'\n  | 'signer_lockedBalance_DESC'\n  | 'signer_lockedBalance_DESC_NULLS_LAST'\n  | 'signer_nonce_ASC'\n  | 'signer_nonce_ASC_NULLS_FIRST'\n  | 'signer_nonce_DESC'\n  | 'signer_nonce_DESC_NULLS_LAST'\n  | 'signer_reservedBalance_ASC'\n  | 'signer_reservedBalance_ASC_NULLS_FIRST'\n  | 'signer_reservedBalance_DESC'\n  | 'signer_reservedBalance_DESC_NULLS_LAST'\n  | 'signer_timestamp_ASC'\n  | 'signer_timestamp_ASC_NULLS_FIRST'\n  | 'signer_timestamp_DESC'\n  | 'signer_timestamp_DESC_NULLS_LAST'\n  | 'signer_vestedBalance_ASC'\n  | 'signer_vestedBalance_ASC_NULLS_FIRST'\n  | 'signer_vestedBalance_DESC'\n  | 'signer_vestedBalance_DESC_NULLS_LAST'\n  | 'signer_votingBalance_ASC'\n  | 'signer_votingBalance_ASC_NULLS_FIRST'\n  | 'signer_votingBalance_DESC'\n  | 'signer_votingBalance_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST'\n  | 'type_ASC'\n  | 'type_ASC_NULLS_FIRST'\n  | 'type_DESC'\n  | 'type_DESC_NULLS_LAST';\n\nexport type StakingType =\n  | 'Reward'\n  | 'Slash';\n\nexport type StakingWhereInput = {\n  AND?: InputMaybe<Array<StakingWhereInput>>;\n  OR?: InputMaybe<Array<StakingWhereInput>>;\n  amount_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  amount_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  amount_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  event?: InputMaybe<EventWhereInput>;\n  event_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  signer?: InputMaybe<AccountWhereInput>;\n  signer_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  type_eq?: InputMaybe<StakingType>;\n  type_in?: InputMaybe<Array<StakingType>>;\n  type_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  type_not_eq?: InputMaybe<StakingType>;\n  type_not_in?: InputMaybe<Array<StakingType>>;\n};\n\nexport type StakingsConnection = {\n  __typename?: 'StakingsConnection';\n  edges: Array<StakingEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type Subscription = {\n  __typename?: 'Subscription';\n  accountById?: Maybe<Account>;\n  accounts: Array<Account>;\n  blockById?: Maybe<Block>;\n  blocks: Array<Block>;\n  chainInfoById?: Maybe<ChainInfo>;\n  chainInfos: Array<ChainInfo>;\n  contractById?: Maybe<Contract>;\n  contracts: Array<Contract>;\n  eraValidatorInfoById?: Maybe<EraValidatorInfo>;\n  eraValidatorInfos: Array<EraValidatorInfo>;\n  eventById?: Maybe<Event>;\n  events: Array<Event>;\n  evmEventById?: Maybe<EvmEvent>;\n  evmEvents: Array<EvmEvent>;\n  extrinsicById?: Maybe<Extrinsic>;\n  extrinsics: Array<Extrinsic>;\n  newlyVerifiedContractQueueById?: Maybe<NewlyVerifiedContractQueue>;\n  newlyVerifiedContractQueues: Array<NewlyVerifiedContractQueue>;\n  stakingById?: Maybe<Staking>;\n  stakings: Array<Staking>;\n  tokenHolderById?: Maybe<TokenHolder>;\n  tokenHolders: Array<TokenHolder>;\n  transferById?: Maybe<Transfer>;\n  transfers: Array<Transfer>;\n  verificationRequestById?: Maybe<VerificationRequest>;\n  verificationRequests: Array<VerificationRequest>;\n  verifiedContractById?: Maybe<VerifiedContract>;\n  verifiedContracts: Array<VerifiedContract>;\n};\n\n\nexport type SubscriptionAccountByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionAccountsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<AccountOrderByInput>>;\n  where?: InputMaybe<AccountWhereInput>;\n};\n\n\nexport type SubscriptionBlockByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionBlocksArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<BlockOrderByInput>>;\n  where?: InputMaybe<BlockWhereInput>;\n};\n\n\nexport type SubscriptionChainInfoByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionChainInfosArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ChainInfoOrderByInput>>;\n  where?: InputMaybe<ChainInfoWhereInput>;\n};\n\n\nexport type SubscriptionContractByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionContractsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ContractOrderByInput>>;\n  where?: InputMaybe<ContractWhereInput>;\n};\n\n\nexport type SubscriptionEraValidatorInfoByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionEraValidatorInfosArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EraValidatorInfoOrderByInput>>;\n  where?: InputMaybe<EraValidatorInfoWhereInput>;\n};\n\n\nexport type SubscriptionEventByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionEventsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EventOrderByInput>>;\n  where?: InputMaybe<EventWhereInput>;\n};\n\n\nexport type SubscriptionEvmEventByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionEvmEventsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<EvmEventOrderByInput>>;\n  where?: InputMaybe<EvmEventWhereInput>;\n};\n\n\nexport type SubscriptionExtrinsicByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionExtrinsicsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<ExtrinsicOrderByInput>>;\n  where?: InputMaybe<ExtrinsicWhereInput>;\n};\n\n\nexport type SubscriptionNewlyVerifiedContractQueueByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionNewlyVerifiedContractQueuesArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<NewlyVerifiedContractQueueOrderByInput>>;\n  where?: InputMaybe<NewlyVerifiedContractQueueWhereInput>;\n};\n\n\nexport type SubscriptionStakingByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionStakingsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<StakingOrderByInput>>;\n  where?: InputMaybe<StakingWhereInput>;\n};\n\n\nexport type SubscriptionTokenHolderByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionTokenHoldersArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<TokenHolderOrderByInput>>;\n  where?: InputMaybe<TokenHolderWhereInput>;\n};\n\n\nexport type SubscriptionTransferByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionTransfersArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<TransferOrderByInput>>;\n  where?: InputMaybe<TransferWhereInput>;\n};\n\n\nexport type SubscriptionVerificationRequestByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionVerificationRequestsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<VerificationRequestOrderByInput>>;\n  where?: InputMaybe<VerificationRequestWhereInput>;\n};\n\n\nexport type SubscriptionVerifiedContractByIdArgs = {\n  id: Scalars['String']['input'];\n};\n\n\nexport type SubscriptionVerifiedContractsArgs = {\n  limit?: InputMaybe<Scalars['Int']['input']>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  orderBy?: InputMaybe<Array<VerifiedContractOrderByInput>>;\n  where?: InputMaybe<VerifiedContractWhereInput>;\n};\n\nexport type TokenHolder = {\n  __typename?: 'TokenHolder';\n  balance: Scalars['BigInt']['output'];\n  evmAddress?: Maybe<Scalars['String']['output']>;\n  /** <tokenAddress>-<signerAddress>-<nftId> */\n  id: Scalars['String']['output'];\n  nftId?: Maybe<Scalars['BigInt']['output']>;\n  signer?: Maybe<Account>;\n  timestamp: Scalars['DateTime']['output'];\n  token: VerifiedContract;\n  type: TokenHolderType;\n};\n\nexport type TokenHolderCount = {\n  __typename?: 'TokenHolderCount';\n  count: Scalars['Int']['output'];\n};\n\nexport type TokenHolderEdge = {\n  __typename?: 'TokenHolderEdge';\n  cursor: Scalars['String']['output'];\n  node: TokenHolder;\n};\n\nexport type TokenHolderInput = {\n  balance: Scalars['BigInt']['input'];\n  evmAddress?: InputMaybe<Scalars['String']['input']>;\n  id: Scalars['String']['input'];\n  nftId?: InputMaybe<Scalars['BigInt']['input']>;\n  signerId?: InputMaybe<Scalars['String']['input']>;\n  timestamp: Scalars['BigInt']['input'];\n  tokenId: Scalars['String']['input'];\n  type: Scalars['String']['input'];\n};\n\nexport type TokenHolderOrderByInput =\n  | 'balance_ASC'\n  | 'balance_ASC_NULLS_FIRST'\n  | 'balance_DESC'\n  | 'balance_DESC_NULLS_LAST'\n  | 'evmAddress_ASC'\n  | 'evmAddress_ASC_NULLS_FIRST'\n  | 'evmAddress_DESC'\n  | 'evmAddress_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'nftId_ASC'\n  | 'nftId_ASC_NULLS_FIRST'\n  | 'nftId_DESC'\n  | 'nftId_DESC_NULLS_LAST'\n  | 'signer_active_ASC'\n  | 'signer_active_ASC_NULLS_FIRST'\n  | 'signer_active_DESC'\n  | 'signer_active_DESC_NULLS_LAST'\n  | 'signer_availableBalance_ASC'\n  | 'signer_availableBalance_ASC_NULLS_FIRST'\n  | 'signer_availableBalance_DESC'\n  | 'signer_availableBalance_DESC_NULLS_LAST'\n  | 'signer_evmAddress_ASC'\n  | 'signer_evmAddress_ASC_NULLS_FIRST'\n  | 'signer_evmAddress_DESC'\n  | 'signer_evmAddress_DESC_NULLS_LAST'\n  | 'signer_evmNonce_ASC'\n  | 'signer_evmNonce_ASC_NULLS_FIRST'\n  | 'signer_evmNonce_DESC'\n  | 'signer_evmNonce_DESC_NULLS_LAST'\n  | 'signer_freeBalance_ASC'\n  | 'signer_freeBalance_ASC_NULLS_FIRST'\n  | 'signer_freeBalance_DESC'\n  | 'signer_freeBalance_DESC_NULLS_LAST'\n  | 'signer_id_ASC'\n  | 'signer_id_ASC_NULLS_FIRST'\n  | 'signer_id_DESC'\n  | 'signer_id_DESC_NULLS_LAST'\n  | 'signer_lockedBalance_ASC'\n  | 'signer_lockedBalance_ASC_NULLS_FIRST'\n  | 'signer_lockedBalance_DESC'\n  | 'signer_lockedBalance_DESC_NULLS_LAST'\n  | 'signer_nonce_ASC'\n  | 'signer_nonce_ASC_NULLS_FIRST'\n  | 'signer_nonce_DESC'\n  | 'signer_nonce_DESC_NULLS_LAST'\n  | 'signer_reservedBalance_ASC'\n  | 'signer_reservedBalance_ASC_NULLS_FIRST'\n  | 'signer_reservedBalance_DESC'\n  | 'signer_reservedBalance_DESC_NULLS_LAST'\n  | 'signer_timestamp_ASC'\n  | 'signer_timestamp_ASC_NULLS_FIRST'\n  | 'signer_timestamp_DESC'\n  | 'signer_timestamp_DESC_NULLS_LAST'\n  | 'signer_vestedBalance_ASC'\n  | 'signer_vestedBalance_ASC_NULLS_FIRST'\n  | 'signer_vestedBalance_DESC'\n  | 'signer_vestedBalance_DESC_NULLS_LAST'\n  | 'signer_votingBalance_ASC'\n  | 'signer_votingBalance_ASC_NULLS_FIRST'\n  | 'signer_votingBalance_DESC'\n  | 'signer_votingBalance_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST'\n  | 'token_approved_ASC'\n  | 'token_approved_ASC_NULLS_FIRST'\n  | 'token_approved_DESC'\n  | 'token_approved_DESC_NULLS_LAST'\n  | 'token_compilerVersion_ASC'\n  | 'token_compilerVersion_ASC_NULLS_FIRST'\n  | 'token_compilerVersion_DESC'\n  | 'token_compilerVersion_DESC_NULLS_LAST'\n  | 'token_filename_ASC'\n  | 'token_filename_ASC_NULLS_FIRST'\n  | 'token_filename_DESC'\n  | 'token_filename_DESC_NULLS_LAST'\n  | 'token_id_ASC'\n  | 'token_id_ASC_NULLS_FIRST'\n  | 'token_id_DESC'\n  | 'token_id_DESC_NULLS_LAST'\n  | 'token_license_ASC'\n  | 'token_license_ASC_NULLS_FIRST'\n  | 'token_license_DESC'\n  | 'token_license_DESC_NULLS_LAST'\n  | 'token_name_ASC'\n  | 'token_name_ASC_NULLS_FIRST'\n  | 'token_name_DESC'\n  | 'token_name_DESC_NULLS_LAST'\n  | 'token_optimization_ASC'\n  | 'token_optimization_ASC_NULLS_FIRST'\n  | 'token_optimization_DESC'\n  | 'token_optimization_DESC_NULLS_LAST'\n  | 'token_runs_ASC'\n  | 'token_runs_ASC_NULLS_FIRST'\n  | 'token_runs_DESC'\n  | 'token_runs_DESC_NULLS_LAST'\n  | 'token_target_ASC'\n  | 'token_target_ASC_NULLS_FIRST'\n  | 'token_target_DESC'\n  | 'token_target_DESC_NULLS_LAST'\n  | 'token_timestamp_ASC'\n  | 'token_timestamp_ASC_NULLS_FIRST'\n  | 'token_timestamp_DESC'\n  | 'token_timestamp_DESC_NULLS_LAST'\n  | 'token_type_ASC'\n  | 'token_type_ASC_NULLS_FIRST'\n  | 'token_type_DESC'\n  | 'token_type_DESC_NULLS_LAST'\n  | 'type_ASC'\n  | 'type_ASC_NULLS_FIRST'\n  | 'type_DESC'\n  | 'type_DESC_NULLS_LAST';\n\nexport type TokenHolderType =\n  | 'Account'\n  | 'Contract';\n\nexport type TokenHolderWhereInput = {\n  AND?: InputMaybe<Array<TokenHolderWhereInput>>;\n  OR?: InputMaybe<Array<TokenHolderWhereInput>>;\n  balance_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  balance_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  balance_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  balance_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  balance_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  balance_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  balance_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  balance_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  balance_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  evmAddress_contains?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_endsWith?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_eq?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_gt?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_gte?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  evmAddress_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  evmAddress_lt?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_lte?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_contains?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_eq?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  evmAddress_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  evmAddress_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  nftId_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  nftId_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  nftId_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  signer?: InputMaybe<AccountWhereInput>;\n  signer_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  token?: InputMaybe<VerifiedContractWhereInput>;\n  token_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  type_eq?: InputMaybe<TokenHolderType>;\n  type_in?: InputMaybe<Array<TokenHolderType>>;\n  type_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  type_not_eq?: InputMaybe<TokenHolderType>;\n  type_not_in?: InputMaybe<Array<TokenHolderType>>;\n};\n\nexport type TokenHoldersConnection = {\n  __typename?: 'TokenHoldersConnection';\n  edges: Array<TokenHolderEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type Transfer = {\n  __typename?: 'Transfer';\n  amount: Scalars['BigInt']['output'];\n  blockHash: Scalars['String']['output'];\n  blockHeight: Scalars['Int']['output'];\n  denom?: Maybe<Scalars['String']['output']>;\n  errorMessage?: Maybe<Scalars['String']['output']>;\n  eventIndex: Scalars['Int']['output'];\n  extrinsicHash?: Maybe<Scalars['String']['output']>;\n  extrinsicId?: Maybe<Scalars['String']['output']>;\n  extrinsicIndex: Scalars['Int']['output'];\n  finalized: Scalars['Boolean']['output'];\n  from: Account;\n  fromEvmAddress?: Maybe<Scalars['String']['output']>;\n  id: Scalars['String']['output'];\n  nftId?: Maybe<Scalars['BigInt']['output']>;\n  reefswapAction?: Maybe<ReefswapAction>;\n  signedData?: Maybe<Scalars['JSON']['output']>;\n  success: Scalars['Boolean']['output'];\n  timestamp: Scalars['DateTime']['output'];\n  to: Account;\n  toEvmAddress?: Maybe<Scalars['String']['output']>;\n  token: VerifiedContract;\n  type: TransferType;\n};\n\nexport type TransferEdge = {\n  __typename?: 'TransferEdge';\n  cursor: Scalars['String']['output'];\n  node: Transfer;\n};\n\nexport type TransferInput = {\n  amount: Scalars['BigInt']['input'];\n  blockHash?: InputMaybe<Scalars['String']['input']>;\n  blockHeight?: InputMaybe<Scalars['Int']['input']>;\n  denom?: InputMaybe<Scalars['String']['input']>;\n  errorMessage?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId?: InputMaybe<Scalars['String']['input']>;\n  extrinsicIndex?: InputMaybe<Scalars['Int']['input']>;\n  finalized: Scalars['Boolean']['input'];\n  fromEvmAddress?: InputMaybe<Scalars['String']['input']>;\n  fromId?: InputMaybe<Scalars['String']['input']>;\n  id: Scalars['String']['input'];\n  nftId?: InputMaybe<Scalars['BigInt']['input']>;\n  signedData?: InputMaybe<Scalars['String']['input']>;\n  success: Scalars['Boolean']['input'];\n  timestamp: Scalars['BigInt']['input'];\n  toEvmAddress?: InputMaybe<Scalars['String']['input']>;\n  toId?: InputMaybe<Scalars['String']['input']>;\n  tokenId?: InputMaybe<Scalars['String']['input']>;\n  type: Scalars['String']['input'];\n};\n\nexport type TransferOrderByInput =\n  | 'amount_ASC'\n  | 'amount_ASC_NULLS_FIRST'\n  | 'amount_DESC'\n  | 'amount_DESC_NULLS_LAST'\n  | 'blockHash_ASC'\n  | 'blockHash_ASC_NULLS_FIRST'\n  | 'blockHash_DESC'\n  | 'blockHash_DESC_NULLS_LAST'\n  | 'blockHeight_ASC'\n  | 'blockHeight_ASC_NULLS_FIRST'\n  | 'blockHeight_DESC'\n  | 'blockHeight_DESC_NULLS_LAST'\n  | 'denom_ASC'\n  | 'denom_ASC_NULLS_FIRST'\n  | 'denom_DESC'\n  | 'denom_DESC_NULLS_LAST'\n  | 'errorMessage_ASC'\n  | 'errorMessage_ASC_NULLS_FIRST'\n  | 'errorMessage_DESC'\n  | 'errorMessage_DESC_NULLS_LAST'\n  | 'eventIndex_ASC'\n  | 'eventIndex_ASC_NULLS_FIRST'\n  | 'eventIndex_DESC'\n  | 'eventIndex_DESC_NULLS_LAST'\n  | 'extrinsicHash_ASC'\n  | 'extrinsicHash_ASC_NULLS_FIRST'\n  | 'extrinsicHash_DESC'\n  | 'extrinsicHash_DESC_NULLS_LAST'\n  | 'extrinsicId_ASC'\n  | 'extrinsicId_ASC_NULLS_FIRST'\n  | 'extrinsicId_DESC'\n  | 'extrinsicId_DESC_NULLS_LAST'\n  | 'extrinsicIndex_ASC'\n  | 'extrinsicIndex_ASC_NULLS_FIRST'\n  | 'extrinsicIndex_DESC'\n  | 'extrinsicIndex_DESC_NULLS_LAST'\n  | 'finalized_ASC'\n  | 'finalized_ASC_NULLS_FIRST'\n  | 'finalized_DESC'\n  | 'finalized_DESC_NULLS_LAST'\n  | 'fromEvmAddress_ASC'\n  | 'fromEvmAddress_ASC_NULLS_FIRST'\n  | 'fromEvmAddress_DESC'\n  | 'fromEvmAddress_DESC_NULLS_LAST'\n  | 'from_active_ASC'\n  | 'from_active_ASC_NULLS_FIRST'\n  | 'from_active_DESC'\n  | 'from_active_DESC_NULLS_LAST'\n  | 'from_availableBalance_ASC'\n  | 'from_availableBalance_ASC_NULLS_FIRST'\n  | 'from_availableBalance_DESC'\n  | 'from_availableBalance_DESC_NULLS_LAST'\n  | 'from_evmAddress_ASC'\n  | 'from_evmAddress_ASC_NULLS_FIRST'\n  | 'from_evmAddress_DESC'\n  | 'from_evmAddress_DESC_NULLS_LAST'\n  | 'from_evmNonce_ASC'\n  | 'from_evmNonce_ASC_NULLS_FIRST'\n  | 'from_evmNonce_DESC'\n  | 'from_evmNonce_DESC_NULLS_LAST'\n  | 'from_freeBalance_ASC'\n  | 'from_freeBalance_ASC_NULLS_FIRST'\n  | 'from_freeBalance_DESC'\n  | 'from_freeBalance_DESC_NULLS_LAST'\n  | 'from_id_ASC'\n  | 'from_id_ASC_NULLS_FIRST'\n  | 'from_id_DESC'\n  | 'from_id_DESC_NULLS_LAST'\n  | 'from_lockedBalance_ASC'\n  | 'from_lockedBalance_ASC_NULLS_FIRST'\n  | 'from_lockedBalance_DESC'\n  | 'from_lockedBalance_DESC_NULLS_LAST'\n  | 'from_nonce_ASC'\n  | 'from_nonce_ASC_NULLS_FIRST'\n  | 'from_nonce_DESC'\n  | 'from_nonce_DESC_NULLS_LAST'\n  | 'from_reservedBalance_ASC'\n  | 'from_reservedBalance_ASC_NULLS_FIRST'\n  | 'from_reservedBalance_DESC'\n  | 'from_reservedBalance_DESC_NULLS_LAST'\n  | 'from_timestamp_ASC'\n  | 'from_timestamp_ASC_NULLS_FIRST'\n  | 'from_timestamp_DESC'\n  | 'from_timestamp_DESC_NULLS_LAST'\n  | 'from_vestedBalance_ASC'\n  | 'from_vestedBalance_ASC_NULLS_FIRST'\n  | 'from_vestedBalance_DESC'\n  | 'from_vestedBalance_DESC_NULLS_LAST'\n  | 'from_votingBalance_ASC'\n  | 'from_votingBalance_ASC_NULLS_FIRST'\n  | 'from_votingBalance_DESC'\n  | 'from_votingBalance_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'nftId_ASC'\n  | 'nftId_ASC_NULLS_FIRST'\n  | 'nftId_DESC'\n  | 'nftId_DESC_NULLS_LAST'\n  | 'reefswapAction_ASC'\n  | 'reefswapAction_ASC_NULLS_FIRST'\n  | 'reefswapAction_DESC'\n  | 'reefswapAction_DESC_NULLS_LAST'\n  | 'success_ASC'\n  | 'success_ASC_NULLS_FIRST'\n  | 'success_DESC'\n  | 'success_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST'\n  | 'toEvmAddress_ASC'\n  | 'toEvmAddress_ASC_NULLS_FIRST'\n  | 'toEvmAddress_DESC'\n  | 'toEvmAddress_DESC_NULLS_LAST'\n  | 'to_active_ASC'\n  | 'to_active_ASC_NULLS_FIRST'\n  | 'to_active_DESC'\n  | 'to_active_DESC_NULLS_LAST'\n  | 'to_availableBalance_ASC'\n  | 'to_availableBalance_ASC_NULLS_FIRST'\n  | 'to_availableBalance_DESC'\n  | 'to_availableBalance_DESC_NULLS_LAST'\n  | 'to_evmAddress_ASC'\n  | 'to_evmAddress_ASC_NULLS_FIRST'\n  | 'to_evmAddress_DESC'\n  | 'to_evmAddress_DESC_NULLS_LAST'\n  | 'to_evmNonce_ASC'\n  | 'to_evmNonce_ASC_NULLS_FIRST'\n  | 'to_evmNonce_DESC'\n  | 'to_evmNonce_DESC_NULLS_LAST'\n  | 'to_freeBalance_ASC'\n  | 'to_freeBalance_ASC_NULLS_FIRST'\n  | 'to_freeBalance_DESC'\n  | 'to_freeBalance_DESC_NULLS_LAST'\n  | 'to_id_ASC'\n  | 'to_id_ASC_NULLS_FIRST'\n  | 'to_id_DESC'\n  | 'to_id_DESC_NULLS_LAST'\n  | 'to_lockedBalance_ASC'\n  | 'to_lockedBalance_ASC_NULLS_FIRST'\n  | 'to_lockedBalance_DESC'\n  | 'to_lockedBalance_DESC_NULLS_LAST'\n  | 'to_nonce_ASC'\n  | 'to_nonce_ASC_NULLS_FIRST'\n  | 'to_nonce_DESC'\n  | 'to_nonce_DESC_NULLS_LAST'\n  | 'to_reservedBalance_ASC'\n  | 'to_reservedBalance_ASC_NULLS_FIRST'\n  | 'to_reservedBalance_DESC'\n  | 'to_reservedBalance_DESC_NULLS_LAST'\n  | 'to_timestamp_ASC'\n  | 'to_timestamp_ASC_NULLS_FIRST'\n  | 'to_timestamp_DESC'\n  | 'to_timestamp_DESC_NULLS_LAST'\n  | 'to_vestedBalance_ASC'\n  | 'to_vestedBalance_ASC_NULLS_FIRST'\n  | 'to_vestedBalance_DESC'\n  | 'to_vestedBalance_DESC_NULLS_LAST'\n  | 'to_votingBalance_ASC'\n  | 'to_votingBalance_ASC_NULLS_FIRST'\n  | 'to_votingBalance_DESC'\n  | 'to_votingBalance_DESC_NULLS_LAST'\n  | 'token_approved_ASC'\n  | 'token_approved_ASC_NULLS_FIRST'\n  | 'token_approved_DESC'\n  | 'token_approved_DESC_NULLS_LAST'\n  | 'token_compilerVersion_ASC'\n  | 'token_compilerVersion_ASC_NULLS_FIRST'\n  | 'token_compilerVersion_DESC'\n  | 'token_compilerVersion_DESC_NULLS_LAST'\n  | 'token_filename_ASC'\n  | 'token_filename_ASC_NULLS_FIRST'\n  | 'token_filename_DESC'\n  | 'token_filename_DESC_NULLS_LAST'\n  | 'token_id_ASC'\n  | 'token_id_ASC_NULLS_FIRST'\n  | 'token_id_DESC'\n  | 'token_id_DESC_NULLS_LAST'\n  | 'token_license_ASC'\n  | 'token_license_ASC_NULLS_FIRST'\n  | 'token_license_DESC'\n  | 'token_license_DESC_NULLS_LAST'\n  | 'token_name_ASC'\n  | 'token_name_ASC_NULLS_FIRST'\n  | 'token_name_DESC'\n  | 'token_name_DESC_NULLS_LAST'\n  | 'token_optimization_ASC'\n  | 'token_optimization_ASC_NULLS_FIRST'\n  | 'token_optimization_DESC'\n  | 'token_optimization_DESC_NULLS_LAST'\n  | 'token_runs_ASC'\n  | 'token_runs_ASC_NULLS_FIRST'\n  | 'token_runs_DESC'\n  | 'token_runs_DESC_NULLS_LAST'\n  | 'token_target_ASC'\n  | 'token_target_ASC_NULLS_FIRST'\n  | 'token_target_DESC'\n  | 'token_target_DESC_NULLS_LAST'\n  | 'token_timestamp_ASC'\n  | 'token_timestamp_ASC_NULLS_FIRST'\n  | 'token_timestamp_DESC'\n  | 'token_timestamp_DESC_NULLS_LAST'\n  | 'token_type_ASC'\n  | 'token_type_ASC_NULLS_FIRST'\n  | 'token_type_DESC'\n  | 'token_type_DESC_NULLS_LAST'\n  | 'type_ASC'\n  | 'type_ASC_NULLS_FIRST'\n  | 'type_DESC'\n  | 'type_DESC_NULLS_LAST';\n\nexport type TransferType =\n  | 'ERC20'\n  | 'ERC721'\n  | 'ERC1155'\n  | 'Native';\n\nexport type TransferWhereInput = {\n  AND?: InputMaybe<Array<TransferWhereInput>>;\n  OR?: InputMaybe<Array<TransferWhereInput>>;\n  amount_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  amount_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  amount_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  amount_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  blockHash_contains?: InputMaybe<Scalars['String']['input']>;\n  blockHash_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  blockHash_endsWith?: InputMaybe<Scalars['String']['input']>;\n  blockHash_eq?: InputMaybe<Scalars['String']['input']>;\n  blockHash_gt?: InputMaybe<Scalars['String']['input']>;\n  blockHash_gte?: InputMaybe<Scalars['String']['input']>;\n  blockHash_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  blockHash_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  blockHash_lt?: InputMaybe<Scalars['String']['input']>;\n  blockHash_lte?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_contains?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_eq?: InputMaybe<Scalars['String']['input']>;\n  blockHash_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  blockHash_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  blockHash_startsWith?: InputMaybe<Scalars['String']['input']>;\n  blockHeight_eq?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_gt?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_gte?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  blockHeight_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  blockHeight_lt?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_lte?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  blockHeight_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  denom_contains?: InputMaybe<Scalars['String']['input']>;\n  denom_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  denom_endsWith?: InputMaybe<Scalars['String']['input']>;\n  denom_eq?: InputMaybe<Scalars['String']['input']>;\n  denom_gt?: InputMaybe<Scalars['String']['input']>;\n  denom_gte?: InputMaybe<Scalars['String']['input']>;\n  denom_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  denom_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  denom_lt?: InputMaybe<Scalars['String']['input']>;\n  denom_lte?: InputMaybe<Scalars['String']['input']>;\n  denom_not_contains?: InputMaybe<Scalars['String']['input']>;\n  denom_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  denom_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  denom_not_eq?: InputMaybe<Scalars['String']['input']>;\n  denom_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  denom_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  denom_startsWith?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_contains?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_endsWith?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_eq?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_gt?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_gte?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  errorMessage_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  errorMessage_lt?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_lte?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_contains?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_eq?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  errorMessage_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  errorMessage_startsWith?: InputMaybe<Scalars['String']['input']>;\n  eventIndex_eq?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_gt?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_gte?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  eventIndex_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  eventIndex_lt?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_lte?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  eventIndex_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  extrinsicHash_contains?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_endsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_eq?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_gt?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_gte?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  extrinsicHash_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  extrinsicHash_lt?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_lte?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_contains?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_eq?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  extrinsicHash_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicHash_startsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_contains?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_endsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_eq?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_gt?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_gte?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  extrinsicId_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  extrinsicId_lt?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_lte?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_not_contains?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_not_eq?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  extrinsicId_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicId_startsWith?: InputMaybe<Scalars['String']['input']>;\n  extrinsicIndex_eq?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_gt?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_gte?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  extrinsicIndex_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  extrinsicIndex_lt?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_lte?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  extrinsicIndex_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  finalized_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  finalized_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  finalized_not_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  from?: InputMaybe<AccountWhereInput>;\n  fromEvmAddress_contains?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_endsWith?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_eq?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_gt?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_gte?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  fromEvmAddress_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  fromEvmAddress_lt?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_lte?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_not_contains?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_not_eq?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  fromEvmAddress_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  fromEvmAddress_startsWith?: InputMaybe<Scalars['String']['input']>;\n  from_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  nftId_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_gt?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_gte?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  nftId_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  nftId_lt?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_lte?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_not_eq?: InputMaybe<Scalars['BigInt']['input']>;\n  nftId_not_in?: InputMaybe<Array<Scalars['BigInt']['input']>>;\n  reefswapAction_eq?: InputMaybe<ReefswapAction>;\n  reefswapAction_in?: InputMaybe<Array<ReefswapAction>>;\n  reefswapAction_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  reefswapAction_not_eq?: InputMaybe<ReefswapAction>;\n  reefswapAction_not_in?: InputMaybe<Array<ReefswapAction>>;\n  signedData_eq?: InputMaybe<Scalars['JSON']['input']>;\n  signedData_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  signedData_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  signedData_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  signedData_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  success_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  success_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  success_not_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  to?: InputMaybe<AccountWhereInput>;\n  toEvmAddress_contains?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_endsWith?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_eq?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_gt?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_gte?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  toEvmAddress_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  toEvmAddress_lt?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_lte?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_not_contains?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_not_eq?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  toEvmAddress_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  toEvmAddress_startsWith?: InputMaybe<Scalars['String']['input']>;\n  to_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  token?: InputMaybe<VerifiedContractWhereInput>;\n  token_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  type_eq?: InputMaybe<TransferType>;\n  type_in?: InputMaybe<Array<TransferType>>;\n  type_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  type_not_eq?: InputMaybe<TransferType>;\n  type_not_in?: InputMaybe<Array<TransferType>>;\n};\n\nexport type TransfersConnection = {\n  __typename?: 'TransfersConnection';\n  edges: Array<TransferEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type VerificationRequest = {\n  __typename?: 'VerificationRequest';\n  args: Scalars['JSON']['output'];\n  compilerVersion: Scalars['String']['output'];\n  filename?: Maybe<Scalars['String']['output']>;\n  /** Address */\n  id: Scalars['String']['output'];\n  license?: Maybe<Scalars['String']['output']>;\n  message?: Maybe<Scalars['String']['output']>;\n  name: Scalars['String']['output'];\n  optimization: Scalars['Boolean']['output'];\n  runs: Scalars['Int']['output'];\n  source: Scalars['JSON']['output'];\n  success: Scalars['Boolean']['output'];\n  target: Scalars['String']['output'];\n  timestamp?: Maybe<Scalars['DateTime']['output']>;\n};\n\nexport type VerificationRequestEdge = {\n  __typename?: 'VerificationRequestEdge';\n  cursor: Scalars['String']['output'];\n  node: VerificationRequest;\n};\n\nexport type VerificationRequestOrderByInput =\n  | 'compilerVersion_ASC'\n  | 'compilerVersion_ASC_NULLS_FIRST'\n  | 'compilerVersion_DESC'\n  | 'compilerVersion_DESC_NULLS_LAST'\n  | 'filename_ASC'\n  | 'filename_ASC_NULLS_FIRST'\n  | 'filename_DESC'\n  | 'filename_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'license_ASC'\n  | 'license_ASC_NULLS_FIRST'\n  | 'license_DESC'\n  | 'license_DESC_NULLS_LAST'\n  | 'message_ASC'\n  | 'message_ASC_NULLS_FIRST'\n  | 'message_DESC'\n  | 'message_DESC_NULLS_LAST'\n  | 'name_ASC'\n  | 'name_ASC_NULLS_FIRST'\n  | 'name_DESC'\n  | 'name_DESC_NULLS_LAST'\n  | 'optimization_ASC'\n  | 'optimization_ASC_NULLS_FIRST'\n  | 'optimization_DESC'\n  | 'optimization_DESC_NULLS_LAST'\n  | 'runs_ASC'\n  | 'runs_ASC_NULLS_FIRST'\n  | 'runs_DESC'\n  | 'runs_DESC_NULLS_LAST'\n  | 'success_ASC'\n  | 'success_ASC_NULLS_FIRST'\n  | 'success_DESC'\n  | 'success_DESC_NULLS_LAST'\n  | 'target_ASC'\n  | 'target_ASC_NULLS_FIRST'\n  | 'target_DESC'\n  | 'target_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST';\n\nexport type VerificationRequestWhereInput = {\n  AND?: InputMaybe<Array<VerificationRequestWhereInput>>;\n  OR?: InputMaybe<Array<VerificationRequestWhereInput>>;\n  args_eq?: InputMaybe<Scalars['JSON']['input']>;\n  args_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  args_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  args_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  args_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  compilerVersion_contains?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_endsWith?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_eq?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_gt?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_gte?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  compilerVersion_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  compilerVersion_lt?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_lte?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_contains?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_eq?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  compilerVersion_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_startsWith?: InputMaybe<Scalars['String']['input']>;\n  filename_contains?: InputMaybe<Scalars['String']['input']>;\n  filename_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  filename_endsWith?: InputMaybe<Scalars['String']['input']>;\n  filename_eq?: InputMaybe<Scalars['String']['input']>;\n  filename_gt?: InputMaybe<Scalars['String']['input']>;\n  filename_gte?: InputMaybe<Scalars['String']['input']>;\n  filename_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  filename_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  filename_lt?: InputMaybe<Scalars['String']['input']>;\n  filename_lte?: InputMaybe<Scalars['String']['input']>;\n  filename_not_contains?: InputMaybe<Scalars['String']['input']>;\n  filename_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  filename_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  filename_not_eq?: InputMaybe<Scalars['String']['input']>;\n  filename_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  filename_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  filename_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  license_contains?: InputMaybe<Scalars['String']['input']>;\n  license_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  license_endsWith?: InputMaybe<Scalars['String']['input']>;\n  license_eq?: InputMaybe<Scalars['String']['input']>;\n  license_gt?: InputMaybe<Scalars['String']['input']>;\n  license_gte?: InputMaybe<Scalars['String']['input']>;\n  license_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  license_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  license_lt?: InputMaybe<Scalars['String']['input']>;\n  license_lte?: InputMaybe<Scalars['String']['input']>;\n  license_not_contains?: InputMaybe<Scalars['String']['input']>;\n  license_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  license_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  license_not_eq?: InputMaybe<Scalars['String']['input']>;\n  license_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  license_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  license_startsWith?: InputMaybe<Scalars['String']['input']>;\n  message_contains?: InputMaybe<Scalars['String']['input']>;\n  message_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  message_endsWith?: InputMaybe<Scalars['String']['input']>;\n  message_eq?: InputMaybe<Scalars['String']['input']>;\n  message_gt?: InputMaybe<Scalars['String']['input']>;\n  message_gte?: InputMaybe<Scalars['String']['input']>;\n  message_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  message_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  message_lt?: InputMaybe<Scalars['String']['input']>;\n  message_lte?: InputMaybe<Scalars['String']['input']>;\n  message_not_contains?: InputMaybe<Scalars['String']['input']>;\n  message_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  message_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  message_not_eq?: InputMaybe<Scalars['String']['input']>;\n  message_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  message_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  message_startsWith?: InputMaybe<Scalars['String']['input']>;\n  name_contains?: InputMaybe<Scalars['String']['input']>;\n  name_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  name_endsWith?: InputMaybe<Scalars['String']['input']>;\n  name_eq?: InputMaybe<Scalars['String']['input']>;\n  name_gt?: InputMaybe<Scalars['String']['input']>;\n  name_gte?: InputMaybe<Scalars['String']['input']>;\n  name_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  name_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  name_lt?: InputMaybe<Scalars['String']['input']>;\n  name_lte?: InputMaybe<Scalars['String']['input']>;\n  name_not_contains?: InputMaybe<Scalars['String']['input']>;\n  name_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  name_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  name_not_eq?: InputMaybe<Scalars['String']['input']>;\n  name_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  name_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  name_startsWith?: InputMaybe<Scalars['String']['input']>;\n  optimization_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  optimization_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  optimization_not_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  runs_eq?: InputMaybe<Scalars['Int']['input']>;\n  runs_gt?: InputMaybe<Scalars['Int']['input']>;\n  runs_gte?: InputMaybe<Scalars['Int']['input']>;\n  runs_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  runs_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  runs_lt?: InputMaybe<Scalars['Int']['input']>;\n  runs_lte?: InputMaybe<Scalars['Int']['input']>;\n  runs_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  runs_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  source_eq?: InputMaybe<Scalars['JSON']['input']>;\n  source_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  source_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  source_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  source_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  success_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  success_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  success_not_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  target_contains?: InputMaybe<Scalars['String']['input']>;\n  target_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  target_endsWith?: InputMaybe<Scalars['String']['input']>;\n  target_eq?: InputMaybe<Scalars['String']['input']>;\n  target_gt?: InputMaybe<Scalars['String']['input']>;\n  target_gte?: InputMaybe<Scalars['String']['input']>;\n  target_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  target_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  target_lt?: InputMaybe<Scalars['String']['input']>;\n  target_lte?: InputMaybe<Scalars['String']['input']>;\n  target_not_contains?: InputMaybe<Scalars['String']['input']>;\n  target_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  target_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  target_not_eq?: InputMaybe<Scalars['String']['input']>;\n  target_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  target_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  target_startsWith?: InputMaybe<Scalars['String']['input']>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n};\n\nexport type VerificationRequestsConnection = {\n  __typename?: 'VerificationRequestsConnection';\n  edges: Array<VerificationRequestEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type VerifiedContract = {\n  __typename?: 'VerifiedContract';\n  approved?: Maybe<Scalars['Boolean']['output']>;\n  args: Scalars['JSON']['output'];\n  compiledData: Scalars['JSON']['output'];\n  compilerVersion: Scalars['String']['output'];\n  contract: Contract;\n  contractData?: Maybe<Scalars['JSON']['output']>;\n  filename?: Maybe<Scalars['String']['output']>;\n  /** Address */\n  id: Scalars['String']['output'];\n  license?: Maybe<Scalars['String']['output']>;\n  name: Scalars['String']['output'];\n  optimization: Scalars['Boolean']['output'];\n  runs: Scalars['Int']['output'];\n  source: Scalars['JSON']['output'];\n  target: Scalars['String']['output'];\n  timestamp?: Maybe<Scalars['DateTime']['output']>;\n  type?: Maybe<ContractType>;\n};\n\nexport type VerifiedContractEdge = {\n  __typename?: 'VerifiedContractEdge';\n  cursor: Scalars['String']['output'];\n  node: VerifiedContract;\n};\n\nexport type VerifiedContractOrderByInput =\n  | 'approved_ASC'\n  | 'approved_ASC_NULLS_FIRST'\n  | 'approved_DESC'\n  | 'approved_DESC_NULLS_LAST'\n  | 'compilerVersion_ASC'\n  | 'compilerVersion_ASC_NULLS_FIRST'\n  | 'compilerVersion_DESC'\n  | 'compilerVersion_DESC_NULLS_LAST'\n  | 'contract_bytecodeArguments_ASC'\n  | 'contract_bytecodeArguments_ASC_NULLS_FIRST'\n  | 'contract_bytecodeArguments_DESC'\n  | 'contract_bytecodeArguments_DESC_NULLS_LAST'\n  | 'contract_bytecodeContext_ASC'\n  | 'contract_bytecodeContext_ASC_NULLS_FIRST'\n  | 'contract_bytecodeContext_DESC'\n  | 'contract_bytecodeContext_DESC_NULLS_LAST'\n  | 'contract_bytecode_ASC'\n  | 'contract_bytecode_ASC_NULLS_FIRST'\n  | 'contract_bytecode_DESC'\n  | 'contract_bytecode_DESC_NULLS_LAST'\n  | 'contract_gasLimit_ASC'\n  | 'contract_gasLimit_ASC_NULLS_FIRST'\n  | 'contract_gasLimit_DESC'\n  | 'contract_gasLimit_DESC_NULLS_LAST'\n  | 'contract_id_ASC'\n  | 'contract_id_ASC_NULLS_FIRST'\n  | 'contract_id_DESC'\n  | 'contract_id_DESC_NULLS_LAST'\n  | 'contract_storageLimit_ASC'\n  | 'contract_storageLimit_ASC_NULLS_FIRST'\n  | 'contract_storageLimit_DESC'\n  | 'contract_storageLimit_DESC_NULLS_LAST'\n  | 'contract_timestamp_ASC'\n  | 'contract_timestamp_ASC_NULLS_FIRST'\n  | 'contract_timestamp_DESC'\n  | 'contract_timestamp_DESC_NULLS_LAST'\n  | 'filename_ASC'\n  | 'filename_ASC_NULLS_FIRST'\n  | 'filename_DESC'\n  | 'filename_DESC_NULLS_LAST'\n  | 'id_ASC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC'\n  | 'id_DESC_NULLS_LAST'\n  | 'license_ASC'\n  | 'license_ASC_NULLS_FIRST'\n  | 'license_DESC'\n  | 'license_DESC_NULLS_LAST'\n  | 'name_ASC'\n  | 'name_ASC_NULLS_FIRST'\n  | 'name_DESC'\n  | 'name_DESC_NULLS_LAST'\n  | 'optimization_ASC'\n  | 'optimization_ASC_NULLS_FIRST'\n  | 'optimization_DESC'\n  | 'optimization_DESC_NULLS_LAST'\n  | 'runs_ASC'\n  | 'runs_ASC_NULLS_FIRST'\n  | 'runs_DESC'\n  | 'runs_DESC_NULLS_LAST'\n  | 'target_ASC'\n  | 'target_ASC_NULLS_FIRST'\n  | 'target_DESC'\n  | 'target_DESC_NULLS_LAST'\n  | 'timestamp_ASC'\n  | 'timestamp_ASC_NULLS_FIRST'\n  | 'timestamp_DESC'\n  | 'timestamp_DESC_NULLS_LAST'\n  | 'type_ASC'\n  | 'type_ASC_NULLS_FIRST'\n  | 'type_DESC'\n  | 'type_DESC_NULLS_LAST';\n\nexport type VerifiedContractWhereInput = {\n  AND?: InputMaybe<Array<VerifiedContractWhereInput>>;\n  OR?: InputMaybe<Array<VerifiedContractWhereInput>>;\n  approved_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  approved_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  approved_not_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  args_eq?: InputMaybe<Scalars['JSON']['input']>;\n  args_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  args_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  args_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  args_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  compiledData_eq?: InputMaybe<Scalars['JSON']['input']>;\n  compiledData_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  compiledData_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  compiledData_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  compiledData_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  compilerVersion_contains?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_endsWith?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_eq?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_gt?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_gte?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  compilerVersion_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  compilerVersion_lt?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_lte?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_contains?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_eq?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  compilerVersion_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  compilerVersion_startsWith?: InputMaybe<Scalars['String']['input']>;\n  contract?: InputMaybe<ContractWhereInput>;\n  contractData_eq?: InputMaybe<Scalars['JSON']['input']>;\n  contractData_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  contractData_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  contractData_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  contractData_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  contract_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  filename_contains?: InputMaybe<Scalars['String']['input']>;\n  filename_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  filename_endsWith?: InputMaybe<Scalars['String']['input']>;\n  filename_eq?: InputMaybe<Scalars['String']['input']>;\n  filename_gt?: InputMaybe<Scalars['String']['input']>;\n  filename_gte?: InputMaybe<Scalars['String']['input']>;\n  filename_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  filename_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  filename_lt?: InputMaybe<Scalars['String']['input']>;\n  filename_lte?: InputMaybe<Scalars['String']['input']>;\n  filename_not_contains?: InputMaybe<Scalars['String']['input']>;\n  filename_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  filename_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  filename_not_eq?: InputMaybe<Scalars['String']['input']>;\n  filename_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  filename_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  filename_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_contains?: InputMaybe<Scalars['String']['input']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_eq?: InputMaybe<Scalars['String']['input']>;\n  id_gt?: InputMaybe<Scalars['String']['input']>;\n  id_gte?: InputMaybe<Scalars['String']['input']>;\n  id_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  id_lt?: InputMaybe<Scalars['String']['input']>;\n  id_lte?: InputMaybe<Scalars['String']['input']>;\n  id_not_contains?: InputMaybe<Scalars['String']['input']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  id_not_eq?: InputMaybe<Scalars['String']['input']>;\n  id_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  id_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  id_startsWith?: InputMaybe<Scalars['String']['input']>;\n  license_contains?: InputMaybe<Scalars['String']['input']>;\n  license_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  license_endsWith?: InputMaybe<Scalars['String']['input']>;\n  license_eq?: InputMaybe<Scalars['String']['input']>;\n  license_gt?: InputMaybe<Scalars['String']['input']>;\n  license_gte?: InputMaybe<Scalars['String']['input']>;\n  license_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  license_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  license_lt?: InputMaybe<Scalars['String']['input']>;\n  license_lte?: InputMaybe<Scalars['String']['input']>;\n  license_not_contains?: InputMaybe<Scalars['String']['input']>;\n  license_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  license_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  license_not_eq?: InputMaybe<Scalars['String']['input']>;\n  license_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  license_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  license_startsWith?: InputMaybe<Scalars['String']['input']>;\n  name_contains?: InputMaybe<Scalars['String']['input']>;\n  name_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  name_endsWith?: InputMaybe<Scalars['String']['input']>;\n  name_eq?: InputMaybe<Scalars['String']['input']>;\n  name_gt?: InputMaybe<Scalars['String']['input']>;\n  name_gte?: InputMaybe<Scalars['String']['input']>;\n  name_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  name_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  name_lt?: InputMaybe<Scalars['String']['input']>;\n  name_lte?: InputMaybe<Scalars['String']['input']>;\n  name_not_contains?: InputMaybe<Scalars['String']['input']>;\n  name_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  name_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  name_not_eq?: InputMaybe<Scalars['String']['input']>;\n  name_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  name_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  name_startsWith?: InputMaybe<Scalars['String']['input']>;\n  optimization_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  optimization_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  optimization_not_eq?: InputMaybe<Scalars['Boolean']['input']>;\n  runs_eq?: InputMaybe<Scalars['Int']['input']>;\n  runs_gt?: InputMaybe<Scalars['Int']['input']>;\n  runs_gte?: InputMaybe<Scalars['Int']['input']>;\n  runs_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  runs_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  runs_lt?: InputMaybe<Scalars['Int']['input']>;\n  runs_lte?: InputMaybe<Scalars['Int']['input']>;\n  runs_not_eq?: InputMaybe<Scalars['Int']['input']>;\n  runs_not_in?: InputMaybe<Array<Scalars['Int']['input']>>;\n  source_eq?: InputMaybe<Scalars['JSON']['input']>;\n  source_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  source_jsonContains?: InputMaybe<Scalars['JSON']['input']>;\n  source_jsonHasKey?: InputMaybe<Scalars['JSON']['input']>;\n  source_not_eq?: InputMaybe<Scalars['JSON']['input']>;\n  target_contains?: InputMaybe<Scalars['String']['input']>;\n  target_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  target_endsWith?: InputMaybe<Scalars['String']['input']>;\n  target_eq?: InputMaybe<Scalars['String']['input']>;\n  target_gt?: InputMaybe<Scalars['String']['input']>;\n  target_gte?: InputMaybe<Scalars['String']['input']>;\n  target_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  target_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  target_lt?: InputMaybe<Scalars['String']['input']>;\n  target_lte?: InputMaybe<Scalars['String']['input']>;\n  target_not_contains?: InputMaybe<Scalars['String']['input']>;\n  target_not_containsInsensitive?: InputMaybe<Scalars['String']['input']>;\n  target_not_endsWith?: InputMaybe<Scalars['String']['input']>;\n  target_not_eq?: InputMaybe<Scalars['String']['input']>;\n  target_not_in?: InputMaybe<Array<Scalars['String']['input']>>;\n  target_not_startsWith?: InputMaybe<Scalars['String']['input']>;\n  target_startsWith?: InputMaybe<Scalars['String']['input']>;\n  timestamp_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_gte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  timestamp_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  timestamp_lt?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_lte?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_eq?: InputMaybe<Scalars['DateTime']['input']>;\n  timestamp_not_in?: InputMaybe<Array<Scalars['DateTime']['input']>>;\n  type_eq?: InputMaybe<ContractType>;\n  type_in?: InputMaybe<Array<ContractType>>;\n  type_isNull?: InputMaybe<Scalars['Boolean']['input']>;\n  type_not_eq?: InputMaybe<ContractType>;\n  type_not_in?: InputMaybe<Array<ContractType>>;\n};\n\nexport type VerifiedContractsConnection = {\n  __typename?: 'VerifiedContractsConnection';\n  edges: Array<VerifiedContractEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int']['output'];\n};\n\nexport type WhereIdInput = {\n  id: Scalars['String']['input'];\n};\n\nexport type GetAccountByEvmQueryVariables = Exact<{\n  evmAddress: Scalars['String']['input'];\n}>;\n\n\nexport type GetAccountByEvmQuery = { __typename?: 'Query', accounts: Array<{ __typename?: 'Account', id: string, evmAddress?: string | null }> };\n\nexport type GetAccountByNativeQueryVariables = Exact<{\n  nativeAddress: Scalars['String']['input'];\n}>;\n\n\nexport type GetAccountByNativeQuery = { __typename?: 'Query', accounts: Array<{ __typename?: 'Account', id: string, evmAddress?: string | null }> };\n\nexport type NftsByOwnerQueryVariables = Exact<{\n  owner: Scalars['String']['input'];\n}>;\n\n\nexport type NftsByOwnerQuery = { __typename?: 'Query', tokenHolders: Array<{ __typename?: 'TokenHolder', id: string, balance: any, type: TokenHolderType, nftId?: any | null, token: { __typename?: 'VerifiedContract', id: string, type?: ContractType | null } }> };\n\nexport type NftsByOwnerPagedQueryVariables = Exact<{\n  owner: Scalars['String']['input'];\n  limit: Scalars['Int']['input'];\n  offset: Scalars['Int']['input'];\n}>;\n\n\nexport type NftsByOwnerPagedQuery = { __typename?: 'Query', tokenHolders: Array<{ __typename?: 'TokenHolder', id: string, balance: any, nftId?: any | null, token: { __typename?: 'VerifiedContract', id: string, type?: ContractType | null } }> };\n\nexport type ExtrinsicFeeQueryQueryVariables = Exact<{\n  extrinsicHash: Scalars['String']['input'];\n}>;\n\n\nexport type ExtrinsicFeeQueryQuery = { __typename?: 'Query', extrinsics: Array<{ __typename?: 'Extrinsic', events: Array<{ __typename?: 'Event', data: any }> }> };\n\nexport type TransfersFeeQueryQueryVariables = Exact<{\n  first: Scalars['Int']['input'];\n  after?: InputMaybe<Scalars['String']['input']>;\n  where?: InputMaybe<TransferWhereInput>;\n  orderBy: Array<TransferOrderByInput> | TransferOrderByInput;\n}>;\n\n\nexport type TransfersFeeQueryQuery = { __typename?: 'Query', transfersConnection: { __typename?: 'TransfersConnection', totalCount: number, edges: Array<{ __typename?: 'TransferEdge', node: { __typename?: 'Transfer', id: string, amount: any, timestamp: any, success: boolean, type: TransferType, extrinsicHash?: string | null, from: { __typename?: 'Account', id: string }, to: { __typename?: 'Account', id: string }, token: { __typename?: 'VerifiedContract', id: string, name: string, contractData?: any | null } } }>, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor: string } } };\n\nexport type NftTokenIdQueryQueryVariables = Exact<{\n  ids?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;\n}>;\n\n\nexport type NftTokenIdQueryQuery = { __typename?: 'Query', extrinsics: Array<{ __typename?: 'Extrinsic', id: string, hash: string, events: Array<{ __typename?: 'Event', id: string, section: string, method: string, data: any }> }> };\n\nexport type TransfersPollingQueryQueryVariables = Exact<{\n  where?: InputMaybe<TransferWhereInput>;\n  orderBy?: InputMaybe<Array<TransferOrderByInput> | TransferOrderByInput>;\n  offset?: InputMaybe<Scalars['Int']['input']>;\n  limit?: InputMaybe<Scalars['Int']['input']>;\n}>;\n\n\nexport type TransfersPollingQueryQuery = { __typename?: 'Query', transfers: Array<{ __typename?: 'Transfer', id: string, amount: any, timestamp: any, success: boolean, type: TransferType, extrinsicHash?: string | null, extrinsicId?: string | null, from: { __typename?: 'Account', id: string }, to: { __typename?: 'Account', id: string }, token: { __typename?: 'VerifiedContract', id: string, name: string, contractData?: any | null } }> };\n\nexport type TokenHoldersByCollectionQueryVariables = Exact<{\n  collectionId: Scalars['String']['input'];\n  limit: Scalars['Int']['input'];\n  offset: Scalars['Int']['input'];\n}>;\n\n\nexport type TokenHoldersByCollectionQuery = { __typename?: 'Query', tokenHolders: Array<{ __typename?: 'TokenHolder', nftId?: any | null }> };\n\n\nexport const GetAccountByEvmDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"GetAccountByEvm\"},\"variableDefinitions\":[{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"evmAddress\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"accounts\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"evmAddress_eq\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"evmAddress\"}}}]}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"},\"value\":{\"kind\":\"IntValue\",\"value\":\"1\"}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"evmAddress\"}}]}}]}}]} as unknown as DocumentNode<GetAccountByEvmQuery, GetAccountByEvmQueryVariables>;\nexport const GetAccountByNativeDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"GetAccountByNative\"},\"variableDefinitions\":[{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"nativeAddress\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"accounts\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"id_eq\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"nativeAddress\"}}}]}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"},\"value\":{\"kind\":\"IntValue\",\"value\":\"1\"}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"evmAddress\"}}]}}]}}]} as unknown as DocumentNode<GetAccountByNativeQuery, GetAccountByNativeQueryVariables>;\nexport const NftsByOwnerDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"NftsByOwner\"},\"variableDefinitions\":[{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"owner\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"tokenHolders\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"signer\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"evmAddress_eq\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"owner\"}}}]}},{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"balance_gt\"},\"value\":{\"kind\":\"StringValue\",\"value\":\"0\",\"block\":false}},{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"token\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"type_in\"},\"value\":{\"kind\":\"ListValue\",\"values\":[{\"kind\":\"EnumValue\",\"value\":\"ERC721\"},{\"kind\":\"EnumValue\",\"value\":\"ERC1155\"}]}}]}}]}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"},\"value\":{\"kind\":\"IntValue\",\"value\":\"300\"}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"balance\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"type\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"nftId\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"token\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"type\"}}]}}]}}]}}]} as unknown as DocumentNode<NftsByOwnerQuery, NftsByOwnerQueryVariables>;\nexport const NftsByOwnerPagedDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"NftsByOwnerPaged\"},\"variableDefinitions\":[{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"owner\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"offset\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"tokenHolders\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"signer\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"evmAddress_eq\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"owner\"}}}]}},{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"balance_gt\"},\"value\":{\"kind\":\"StringValue\",\"value\":\"0\",\"block\":false}},{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"token\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"type_in\"},\"value\":{\"kind\":\"ListValue\",\"values\":[{\"kind\":\"EnumValue\",\"value\":\"ERC721\"},{\"kind\":\"EnumValue\",\"value\":\"ERC1155\"}]}}]}}]}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"}}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"offset\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"offset\"}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"balance\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"nftId\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"token\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"type\"}}]}}]}}]}}]} as unknown as DocumentNode<NftsByOwnerPagedQuery, NftsByOwnerPagedQueryVariables>;\nexport const ExtrinsicFeeQueryDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"ExtrinsicFeeQuery\"},\"variableDefinitions\":[{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"extrinsicHash\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"extrinsics\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"hash_eq\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"extrinsicHash\"}}}]}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"},\"value\":{\"kind\":\"IntValue\",\"value\":\"1\"}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"events\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"section_eq\"},\"value\":{\"kind\":\"StringValue\",\"value\":\"transactionpayment\",\"block\":false}},{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"method_eq\"},\"value\":{\"kind\":\"StringValue\",\"value\":\"TransactionFeePaid\",\"block\":false}}]}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"data\"}}]}}]}}]}}]} as unknown as DocumentNode<ExtrinsicFeeQueryQuery, ExtrinsicFeeQueryQueryVariables>;\nexport const TransfersFeeQueryDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"TransfersFeeQuery\"},\"variableDefinitions\":[{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"first\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"after\"}},\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"}},\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"TransferWhereInput\"}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"orderBy\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"ListType\",\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"TransferOrderByInput\"}}}}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"transfersConnection\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"orderBy\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"orderBy\"}}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"first\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"first\"}}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"after\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"after\"}}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"edges\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"node\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"amount\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"timestamp\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"success\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"type\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"extrinsicHash\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"from\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}}]}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"to\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}}]}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"token\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"name\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"contractData\"}}]}}]}}]}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"pageInfo\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"hasNextPage\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"endCursor\"}}]}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"totalCount\"}}]}}]}}]} as unknown as DocumentNode<TransfersFeeQueryQuery, TransfersFeeQueryQueryVariables>;\nexport const NftTokenIdQueryDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"NftTokenIdQuery\"},\"variableDefinitions\":[{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"ids\"}},\"type\":{\"kind\":\"ListType\",\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"extrinsics\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"id_in\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"ids\"}}}]}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"hash\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"events\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"section_eq\"},\"value\":{\"kind\":\"StringValue\",\"value\":\"uniques\",\"block\":false}},{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"method_eq\"},\"value\":{\"kind\":\"StringValue\",\"value\":\"Transferred\",\"block\":false}}]}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"section\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"method\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"data\"}}]}}]}}]}}]} as unknown as DocumentNode<NftTokenIdQueryQuery, NftTokenIdQueryQueryVariables>;\nexport const TransfersPollingQueryDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"TransfersPollingQuery\"},\"variableDefinitions\":[{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"}},\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"TransferWhereInput\"}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"orderBy\"}},\"type\":{\"kind\":\"ListType\",\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"TransferOrderByInput\"}}}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"offset\"}},\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"}},\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"transfers\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"}}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"orderBy\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"orderBy\"}}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"offset\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"offset\"}}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"amount\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"timestamp\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"success\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"type\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"extrinsicHash\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"extrinsicId\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"from\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}}]}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"to\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}}]}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"token\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"id\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"name\"}},{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"contractData\"}}]}}]}}]}}]} as unknown as DocumentNode<TransfersPollingQueryQuery, TransfersPollingQueryQueryVariables>;\nexport const TokenHoldersByCollectionDocument = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"TokenHoldersByCollection\"},\"variableDefinitions\":[{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"collectionId\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"String\"}}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}}},{\"kind\":\"VariableDefinition\",\"variable\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"offset\"}},\"type\":{\"kind\":\"NonNullType\",\"type\":{\"kind\":\"NamedType\",\"name\":{\"kind\":\"Name\",\"value\":\"Int\"}}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"tokenHolders\"},\"arguments\":[{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"where\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"token\"},\"value\":{\"kind\":\"ObjectValue\",\"fields\":[{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"id_eq\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"collectionId\"}}}]}},{\"kind\":\"ObjectField\",\"name\":{\"kind\":\"Name\",\"value\":\"balance_gt\"},\"value\":{\"kind\":\"StringValue\",\"value\":\"0\",\"block\":false}}]}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"limit\"}}},{\"kind\":\"Argument\",\"name\":{\"kind\":\"Name\",\"value\":\"offset\"},\"value\":{\"kind\":\"Variable\",\"name\":{\"kind\":\"Name\",\"value\":\"offset\"}}}],\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"nftId\"}}]}}]}}]} as unknown as DocumentNode<TokenHoldersByCollectionQuery, TokenHoldersByCollectionQueryVariables>;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\gql\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\hooks\\use-address-resolver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\hooks\\use-in-view.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\hooks\\use-sqwid-collection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\hooks\\use-sqwid-collections-by-owner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\hooks\\use-sqwid-nfts.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'fetchMetadataWithRetry', 'getLocalTokenUri', 'getSqwidMeta', 'getString', 'reefEvmCallBatch', and 'setLocalTokenUri'. Either include them or remove the dependency array.","line":1087,"column":5,"nodeType":"ArrayExpression","endLine":1087,"endColumn":24,"suggestions":[{"desc":"Update the dependencies array to be: [fetchMetadataWithRetry, getLocalTokenUri, getSqwidMeta, getString, reefEvmCallBatch, resolveEvmAddress, setLocalTokenUri]","fix":{"range":[45316,45335],"text":"[fetchMetadataWithRetry, getLocalTokenUri, getSqwidMeta, getString, reefEvmCallBatch, resolveEvmAddress, setLocalTokenUri]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'react';\nimport { apolloClient as client } from '../apollo-client';\nimport { useAddressResolver } from './use-address-resolver';\nimport { NFTS_BY_OWNER_PAGED_QUERY } from '../data/nfts';\nimport type { DocumentNode } from 'graphql';\n\n\n// Define the types for better type-checking\ninterface NftAttribute {\n  trait_type?: string;\n  value?: string | number | boolean | null;\n  display_type?: string;\n  [key: string]: unknown;\n}\n\ntype Json = null | boolean | number | string | Json[] | { [prop: string]: Json };\n\nexport interface Nft {\n  id: string;\n  name: string;\n  image?: string;\n  media?: string;\n  thumbnail?: string;\n  mimetype?: string;\n  description?: string;\n  attributes?: NftAttribute[];\n  amount?: number;\n  error?: boolean;\n  collection?: {\n    id: string;\n    name: string;\n    image?: string;\n  };\n  [key: string]: unknown;\n}\n\nexport interface Collection {\n  id: string;\n  name: string;\n  image?: string;\n  itemCount: number;\n  [key: string]: unknown;\n}\n\n// EVM JSON-RPC endpoint (configurable via env). If endpoint doesn't support EVM, we disable eth_call gracefully.\nconst ENV = ((import.meta as unknown as { env?: Record<string, string | undefined> }).env) ?? {};\nconst EVM_RPC_URL: string = ENV.VITE_REEF_EVM_RPC_URL ?? 'https://rpc.reefscan.com';\n// Max number of concurrent prefetch batches (across contracts). Defaults to 16 if not set or invalid.\nconst PREFETCH_MAX_WORKERS: number = (() => {\n  try {\n    const raw = ENV.VITE_PREFETCH_MAX_WORKERS;\n    const n = Number(raw);\n    return Number.isFinite(n) && n > 0 ? Math.floor(n) : 16;\n  } catch {\n    return 16;\n  }\n})();\n// Max number of concurrent metadata fetch workers. Defaults to 12 if not set or invalid.\nconst FETCH_CONCURRENCY: number = (() => {\n  try {\n    const raw = ENV.VITE_FETCH_CONCURRENCY;\n    const n = Number(raw);\n    return Number.isFinite(n) && n > 0 ? Math.floor(n) : 12;\n  } catch {\n    return 12;\n  }\n})();\nlet evmRpcHealthy: boolean = false;\nlet evmRpcChecked = false;\nlet evmRpcCheckPromise: Promise<boolean> | null = null;\nlet evmEthCallDisabled = false; // disabled when endpoint is Substrate-like\nlet reefEvmCallDisabled = false; // disabled when endpoint is Ethereum-like\n// Some Reef RPC nodes require a full Block struct instead of a block hash for evm_* calls.\n// If eth_call keeps failing or returning 0x, disable it to avoid unnecessary requests\nconst ETH_CALL_FAIL_THRESHOLD = 3;\nlet ethCallFailCount = 0;\n// Cache for finalized head and blocks to avoid per-token RPCs\nlet cachedHead: string | null = null;\nlet cachedHeadTs = 0;\nconst HEAD_TTL_MS = 60000;\nconst blockCache = new Map<string, unknown>();\nlet headPending: Promise<string | null> | null = null;\nconst blockPending = new Map<string, Promise<unknown | null>>();\n\n// Capability probes and caching\nlet reefEvmSupportChecked = false;\nlet reefEvmSupported = false;\nlet reefEvmCheckPromise: Promise<boolean> | null = null;\n\nlet ethCallSupportChecked = false;\nlet ethCallSupported = false;\nlet ethCallCheckPromise: Promise<boolean> | null = null;\n\nfunction isHexAddress(addr: string): boolean {\n  return typeof addr === 'string' && /^0x[0-9a-fA-F]{40}$/.test(addr);\n}\n\nfunction detectEndpointKind(url: string): 'substrate' | 'ethereum' {\n  try {\n    const u = new URL(url);\n    const host = u.hostname.toLowerCase();\n    // Heuristics: reefscan RPC is Substrate. Common ETH providers won't have 'reefscan'.\n    const substrateLikely = /reefscan\\.com$/i.test(host) || /rpc/i.test(host);\n    return substrateLikely ? 'substrate' : 'ethereum';\n  } catch {\n    return 'substrate';\n  }\n}\n\nconst ENDPOINT_KIND = detectEndpointKind(EVM_RPC_URL);\n// Pre-disable unsupported families to avoid probing unsupported methods\nevmEthCallDisabled = ENDPOINT_KIND !== 'ethereum';\nreefEvmCallDisabled = ENDPOINT_KIND !== 'substrate';\n\n// Shared AbortController (set per hook run); module-level so all helpers can access\nlet currentAbortController: AbortController | null = null;\nfunction setAbortController(ctrl: AbortController | null): void {\n  currentAbortController = ctrl;\n}\nfunction getAbortSignal(): AbortSignal | undefined {\n  return currentAbortController?.signal;\n}\nfunction fetchWithAbort(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {\n  const signal = getAbortSignal();\n  const options = signal ? { ...(init ?? {}), signal } : (init ?? {});\n  return fetch(input as RequestInfo, options);\n}\n\nasync function checkEvmRpcHealth(): Promise<boolean> {\n  if (evmRpcChecked) return evmRpcHealthy;\n  if (evmRpcCheckPromise) return evmRpcCheckPromise;\n  evmRpcCheckPromise = (async () => {\n    try {\n      if (ENDPOINT_KIND === 'ethereum') {\n        const res = await fetchWithAbort(EVM_RPC_URL, {\n          method: 'POST',\n          headers: { 'content-type': 'application/json' },\n          body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'eth_chainId', params: [] }),\n        });\n        if (!res.ok) {\n          evmRpcHealthy = false;\n          evmRpcChecked = true;\n          return false;\n        }\n        const json = await res.json().catch(() => null);\n        const j = json as { result?: unknown };\n        evmRpcHealthy = typeof j.result === 'string' && (j.result as string).startsWith('0x');\n        evmRpcChecked = true;\n        return evmRpcHealthy;\n      } else {\n        const res2 = await fetchWithAbort(EVM_RPC_URL, {\n          method: 'POST',\n          headers: { 'content-type': 'application/json' },\n          body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'chain_getFinalizedHead', params: [] }),\n        });\n        if (!res2.ok) {\n          evmRpcHealthy = false;\n          evmRpcChecked = true;\n          return false;\n        }\n        const json2 = await res2.json().catch(() => null);\n        const j2 = json2 as { result?: unknown };\n        const head = typeof j2.result === 'string' ? j2.result : undefined;\n        evmRpcHealthy = typeof head === 'string' && head.startsWith('0x');\n        evmRpcChecked = true;\n        return evmRpcHealthy;\n      }\n    } catch {\n      evmRpcHealthy = false;\n      evmRpcChecked = true;\n      return false;\n    } finally {\n      evmRpcCheckPromise = null;\n    }\n  })();\n  return evmRpcCheckPromise;\n}\n\nasync function checkReefEvmSupport(): Promise<boolean> {\n  if (reefEvmSupportChecked) return reefEvmSupported;\n  if (reefEvmCheckPromise) return reefEvmCheckPromise;\n  reefEvmCheckPromise = (async () => {\n    try {\n      // Avoid probing unsupported method lists; infer from endpoint kind\n      reefEvmSupported = ENDPOINT_KIND === 'substrate';\n    } catch {\n      reefEvmSupported = false;\n    } finally {\n      reefEvmSupportChecked = true;\n      if (!reefEvmSupported) reefEvmCallDisabled = true;\n      reefEvmCheckPromise = null;\n    }\n    return reefEvmSupported;\n  })();\n  return reefEvmCheckPromise;\n}\n\nasync function checkEthCallSupport(): Promise<boolean> {\n  if (ethCallSupportChecked) return ethCallSupported;\n  if (ethCallCheckPromise) return ethCallCheckPromise;\n  ethCallCheckPromise = (async () => {\n    try {\n      // Avoid unsupported probes; assume eth_call only on Ethereum-like endpoints\n      ethCallSupported = ENDPOINT_KIND === 'ethereum';\n    } catch {\n      ethCallSupported = false;\n    } finally {\n      ethCallSupportChecked = true;\n      if (!ethCallSupported) evmEthCallDisabled = true;\n      ethCallCheckPromise = null;\n    }\n    return ethCallSupported;\n  })();\n  return ethCallCheckPromise;\n}\n\n/**\n * A custom hook to fetch and process NFT data from the Sqwid API for a given address.\n * @param address The Reef chain address of the owner. Can be Substrate or EVM format.\n * @returns An object containing the list of NFTs, collections, loading state, and any errors.\n */\nexport const useSqwidNfts = (address: string | null) => {\n  const [nfts, setNfts] = useState<Nft[]>([]);\n  const [collections, setCollections] = useState<Collection[]>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<Error | null>(null);\n  const { resolveEvmAddress } = useAddressResolver();\n\n  const toIpfsUrl = (ipfsUri: string): string => {\n    if (!ipfsUri) return '';\n    if (ipfsUri.startsWith('ipfs://')) {\n      return `https://reef.infura-ipfs.io/ipfs/${ipfsUri.split('ipfs://')[1]}`;\n    }\n    return ipfsUri;\n  };\n\n  // Helpers: basic sleep and retry for transient errors (e.g., 503)\n  function sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n  \n  // In-flight de-duplication to coalesce concurrent calls for the same token (stable across renders)\n  const inflightRef = useRef(new Map<string, Promise<Nft | null>>());\n  // Cache for Sqwid REST fallback: contract -> (tokenId -> meta)\n  const sqwidCacheRef = useRef(new Map<string, Map<string, { name?: string; image?: string; media?: string; thumbnail?: string; mimetype?: string; amount?: number }>>());\n  // In-flight fetches per contract to coalesce concurrent by-collection REST requests\n  const sqwidPendingRef = useRef(new Map<string, Promise<void>>());\n  // Pre-resolved tokenURI cache to avoid repeated RPCs (memory + localStorage TTL)\n  const tokenUriCacheRef = useRef(new Map<string, string>());\n\n  // Shared AbortController is managed at module scope via setAbortController()\n\n  function toHex(value: bigint, padBytes = 32): string {\n    const hex = value.toString(16);\n    return hex.length >= padBytes * 2 ? hex : '0'.repeat(padBytes * 2 - hex.length) + hex;\n  }\n\n  function tokenUriCacheKey(contractAddress: string, nftId: string | number): string {\n    return `${contractAddress}-${String(nftId)}`;\n  }\n\n  const TOKEN_URI_LS_NS = 'reef:tokenURI:';\n  const TOKEN_URI_TTL_MS = 2 * 24 * 60 * 60 * 1000; // 2 days\n\n  function getLocalTokenUri(contractAddress: string, nftId: string | number): string | null {\n    try {\n      const key = TOKEN_URI_LS_NS + tokenUriCacheKey(contractAddress, nftId);\n      const raw = localStorage.getItem(key);\n      if (!raw) return null;\n      const obj = JSON.parse(raw) as { uri: string; ts: number } | null;\n      if (!obj || !obj.uri || !obj.ts) return null;\n      if (Date.now() - obj.ts > TOKEN_URI_TTL_MS) {\n        localStorage.removeItem(key);\n        return null;\n      }\n      return obj.uri;\n    } catch {\n      return null;\n    }\n  }\n\n  function setLocalTokenUri(contractAddress: string, nftId: string | number, uri: string): void {\n    try {\n      const key = TOKEN_URI_LS_NS + tokenUriCacheKey(contractAddress, nftId);\n      const payload = JSON.stringify({ uri, ts: Date.now() });\n      localStorage.setItem(key, payload);\n    } catch {\n      // ignore quota errors\n    }\n  }\n\n  async function ethCall(to: string, data: string): Promise<string | null> {\n    try {\n      // Probe once to avoid spamming an endpoint that does not support EVM JSON-RPC\n      if (evmEthCallDisabled) return null;\n      if (!ethCallSupportChecked) {\n        const ok = await checkEthCallSupport();\n        if (!ok) return null;\n      }\n      if (!(await checkEvmRpcHealth())) return null;\n      const res = await fetchWithAbort(EVM_RPC_URL, {\n        method: 'POST',\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'eth_call', params: [{ to, data }, 'latest'] }),\n      });\n      if (!res.ok) return null;\n      const json = await res.json();\n      // Some gateways respond with { error: { code: -32601, message: 'Method not found' } }\n      if (json?.error) {\n        if (json?.error?.code === -32601) {\n          evmEthCallDisabled = true;\n          return null;\n        }\n        // Count other failures; disable after threshold\n        ethCallFailCount++;\n        if (ethCallFailCount >= ETH_CALL_FAIL_THRESHOLD) evmEthCallDisabled = true;\n        return null;\n      }\n      const result = json?.result as string | undefined;\n      if (!result || result === '0x') {\n        ethCallFailCount++;\n        if (ethCallFailCount >= ETH_CALL_FAIL_THRESHOLD) evmEthCallDisabled = true;\n        return null;\n      }\n      ethCallFailCount = 0;\n      return result as string;\n    } catch {\n      return null;\n    }\n  }\n\n  // Substrate: get the latest finalized block hash to use as `at` parameter\n  async function getFinalizedHead(): Promise<string | null> {\n    try {\n      // TTL cache to avoid one call per token\n      const now = Date.now();\n      if (cachedHead && (now - cachedHeadTs) < HEAD_TTL_MS) return cachedHead;\n      if (headPending) return await headPending;\n      headPending = (async () => {\n        try {\n          const res = await fetchWithAbort(EVM_RPC_URL, {\n            method: 'POST',\n            headers: { 'content-type': 'application/json' },\n            body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'chain_getFinalizedHead', params: [] }),\n          });\n          if (!res.ok) return null;\n          const json = await res.json();\n          const head = json?.result as string | undefined;\n          const ok = typeof head === 'string' && head.startsWith('0x');\n          if (ok) {\n            cachedHead = head!;\n            cachedHeadTs = Date.now();\n            return head!;\n          }\n          return null;\n        } catch {\n          return null;\n        }\n      })();\n      const head = await headPending;\n      headPending = null;\n      return head;\n    } catch {\n      return null;\n    }\n  }\n\n  // Substrate: get the full block object for a given block hash\n  async function getBlock(at: string): Promise<unknown | null> {\n    try {\n      if (blockCache.has(at)) return blockCache.get(at);\n      if (blockPending.has(at)) return await blockPending.get(at)!;\n      const pending = (async () => {\n        try {\n          const res = await fetchWithAbort(EVM_RPC_URL, {\n            method: 'POST',\n            headers: { 'content-type': 'application/json' },\n            body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'chain_getBlock', params: [at] }),\n          });\n          if (!res.ok) return null;\n          const json = await res.json();\n          const j: unknown = json;\n          let block: unknown = null;\n          if (j && typeof j === 'object') {\n            const r = (j as Record<string, unknown>)['result'];\n            if (r && typeof r === 'object') {\n              block = (r as Record<string, unknown>)['block'] ?? r;\n            } else {\n              block = (r as unknown) ?? null;\n            }\n          }\n          if (block) blockCache.set(at, block);\n          return block ?? null;\n        } catch {\n          return null;\n        } finally {\n          blockPending.delete(at);\n        }\n      })();\n      blockPending.set(at, pending);\n      return await pending;\n    } catch {\n      return null;\n    }\n  }\n\n  function toU64(value: unknown, fallback = 0): number {\n    try {\n      if (value === null || value === undefined) return fallback;\n      if (typeof value === 'number' && Number.isFinite(value)) return Math.max(0, Math.floor(value));\n      if (typeof value === 'string') {\n        const v = value.startsWith('0x') ? Number.parseInt(value.slice(2), 16) : Number.parseInt(value, 10);\n        return Number.isFinite(v) ? Math.max(0, Math.floor(v)) : fallback;\n      }\n      // objects like BN? Best-effort via valueOf\n      const v2 = Number(value as unknown as number | string);\n      return Number.isFinite(v2) ? Math.max(0, Math.floor(v2)) : fallback;\n    } catch {\n      return fallback;\n    }\n  }\n\n  // Reef-specific RPC: evm_call (Frontier-style, but under `evm_*` namespace on Reef)\n  async function reefEstimateResources(to: string, data: string): Promise<{ gasLimit?: number; storageLimit?: number } | null> {\n    try {\n      if (reefEvmCallDisabled) return null;\n      if (!reefEvmSupportChecked) {\n        const ok = await checkReefEvmSupport();\n        if (!ok) return null;\n      }\n      const baseReq = {\n        from: '0x0000000000000000000000000000000000000000',\n        to,\n        value: 0,\n        data,\n      } as const;\n      const at = await getFinalizedHead();\n      if (!at) return null;\n      const block0 = await getBlock(at);\n      if (!block0) return null;\n      const secondParam: Json = block0 as Json;\n      const res = await fetchWithAbort(EVM_RPC_URL, {\n        method: 'POST',\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'evm_estimateResources', params: [baseReq, secondParam] }),\n      });\n      if (!res.ok) return null;\n      const json = await res.json();\n      if (json?.error) {\n        const code = json?.error?.code;\n        if (code === -32601) {\n          reefEvmCallDisabled = true;\n        }\n        // Already passed Block; no retry path needed for -32602\n        return null;\n      }\n      const result = json?.result ?? {};\n      // Accept a variety of shapes across Frontier forks\n      const r = result as Record<string, unknown>;\n      const gasRaw = r['gasLimit'] ?? r['gas_limit'] ?? r['gas'];\n      const storRaw = r['storageLimit'] ?? r['storage_limit'] ?? r['storage'] ?? 0;\n      const gas = toU64(gasRaw, 8_000_000);\n      const storage = toU64(storRaw, 0);\n      return { gasLimit: gas, storageLimit: storage };\n    } catch {\n      return null;\n    }\n  }\n\n  // Reef-specific RPC: evm_call (Frontier-style, but under `evm_*` namespace on Reef)\n  async function reefEvmCall(to: string, data: string): Promise<string | null> {\n    try {\n      if (reefEvmCallDisabled) return null;\n      if (!reefEvmSupportChecked) {\n        const ok = await checkReefEvmSupport();\n        if (!ok) return null;\n      }\n      // Start with conservative defaults; only estimate if call fails for resource reasons\n      let gasLimit = 8_000_000;\n      let storageLimit = 0;\n      const callReq = {\n        from: '0x0000000000000000000000000000000000000000',\n        to,\n        gasLimit,\n        storageLimit,\n        value: 0,\n        data,\n      } as const;\n      const at = await getFinalizedHead();\n      if (!at) return null;\n      // Require Block struct; skip call entirely if not available to avoid -32602\n      const block0 = await getBlock(at);\n      if (!block0) return null;\n      const secondParam: Json = block0 as Json;\n      const res = await fetchWithAbort(EVM_RPC_URL, {\n        method: 'POST',\n        headers: { 'content-type': 'application/json' },\n        // `evm_call` takes CallRequest and an `at` block hash (or some nodes expect a full Block struct)\n        body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'evm_call', params: [callReq, secondParam] }),\n      });\n      if (!res.ok) return null;\n      const json = await res.json();\n      if (json?.error) {\n        const code = json?.error?.code;\n        const msg = String(json?.error?.message ?? '');\n        if (code === -32601) {\n          reefEvmCallDisabled = true;\n          return null;\n        }\n        // If error suggests resource limits, try estimating and retry once\n        if (/gas|resource|storage/i.test(msg)) {\n          const est = await reefEstimateResources(to, data).catch(() => null);\n          if (est && (est.gasLimit || est.storageLimit !== undefined)) {\n            gasLimit = est.gasLimit ?? gasLimit;\n            storageLimit = est.storageLimit ?? storageLimit;\n            const callReq2 = { ...callReq, gasLimit, storageLimit } as const;\n            const res3 = await fetchWithAbort(EVM_RPC_URL, {\n              method: 'POST',\n              headers: { 'content-type': 'application/json' },\n              body: JSON.stringify({ jsonrpc: '2.0', id: 1, method: 'evm_call', params: [callReq2, secondParam] }),\n            });\n            if (!res3.ok) return null;\n            const json3 = await res3.json();\n            if (json3?.error) return null;\n            const result3 = json3?.result as string | undefined;\n            if (!result3 || result3 === '0x') return null;\n            return result3;\n          }\n        }\n        return null;\n      }\n      const result = json?.result as string | undefined;\n      if (!result || result === '0x') return null;\n      return result as string;\n    } catch {\n      return null;\n    }\n  }\n\n  // Batched version of evm_call for many inputs to the same contract. Falls back silently if batch unsupported.\n  async function reefEvmCallBatch(to: string, datas: string[]): Promise<(string | null)[]> {\n    const results: (string | null)[] = Array(datas.length).fill(null);\n    try {\n      if (reefEvmCallDisabled || datas.length === 0) return results;\n      if (!reefEvmSupportChecked) {\n        const ok = await checkReefEvmSupport();\n        if (!ok) return results;\n      }\n      const at = await getFinalizedHead();\n      if (!at) return results;\n      const block0 = await getBlock(at);\n      if (!block0) return results;\n      const secondParam: Json = block0 as Json;\n\n      const gasLimit = 8_000_000;\n      const storageLimit = 0;\n      const batch = datas.map((data, i) => ({\n        jsonrpc: '2.0',\n        id: i + 1,\n        method: 'evm_call',\n        params: [\n          { from: '0x0000000000000000000000000000000000000000', to, gasLimit, storageLimit, value: 0, data },\n          secondParam,\n        ],\n      }));\n\n      const res = await fetchWithAbort(EVM_RPC_URL, {\n        method: 'POST',\n        headers: { 'content-type': 'application/json' },\n        body: JSON.stringify(batch),\n      });\n      if (!res.ok) return results;\n      const json = await res.json();\n      if (!Array.isArray(json)) return results; // batch not supported or proxied\n\n      // Map by id back to index\n      for (const item of json) {\n        const id = (item?.id ?? 0) as number;\n        const idx = Math.max(0, Math.min(datas.length - 1, id - 1));\n        if (item?.error) {\n          const code = item?.error?.code;\n          if (code === -32601) reefEvmCallDisabled = true;\n          results[idx] = null;\n        } else {\n          const r = item?.result as string | undefined;\n          results[idx] = !r || r === '0x' ? null : r;\n        }\n      }\n      return results;\n    } catch {\n      return results;\n    }\n  }\n\n  function decodeAbiString(hex: string): string | null {\n    try {\n      if (!hex || hex.length < 2) return null;\n      // Strip 0x\n      const clean = hex.startsWith('0x') ? hex.slice(2) : hex;\n      // ABI dynamic string: 32 bytes offset, 32 bytes length, then data\n      if (clean.length < 64 * 2) return null;\n      const offset = parseInt(clean.slice(0, 64), 16);\n      const lenPos = (offset) * 2; // offset is in bytes\n      const length = parseInt(clean.slice(lenPos, lenPos + 64), 16);\n      const dataPos = lenPos + 64;\n      const dataHex = clean.slice(dataPos, dataPos + length * 2);\n      const bytes = new Uint8Array(dataHex.match(/.{1,2}/g)!.map(b => parseInt(b, 16)));\n      return new TextDecoder().decode(bytes);\n    } catch {\n      return null;\n    }\n  }\n\n  function toIpfsHttp(uri?: string | null): string | undefined {\n    if (!uri) return undefined;\n    if (uri.startsWith('ipfs://')) return `https://reef.infura-ipfs.io/ipfs/${uri.slice('ipfs://'.length)}`;\n    return uri;\n  }\n\n  // Safe getters for unknown-shaped JSON\n  function get(obj: unknown, path: string[]): unknown {\n    let cur: unknown = obj;\n    for (const key of path) {\n      if (!cur || typeof cur !== 'object') return undefined;\n      cur = (cur as Record<string, unknown>)[key];\n    }\n    return cur;\n  }\n\n  function getString(obj: unknown, path: string[]): string | undefined {\n    const v = get(obj, path);\n    return typeof v === 'string' ? v : undefined;\n  }\n\n  function getNumber(obj: unknown, path: string[]): number | undefined {\n    const v = get(obj, path);\n    if (typeof v === 'number') return v;\n    if (typeof v === 'string') {\n      const n = Number(v);\n      return Number.isFinite(n) ? n : undefined;\n    }\n    return undefined;\n  }\n\n  function getHttpStatus(err: unknown): number | undefined {\n    if (err && typeof err === 'object') {\n      const e = err as Record<string, unknown>;\n      const s = e['status'];\n      if (typeof s === 'number') return s;\n      const resp = e['response'];\n      if (resp && typeof resp === 'object') {\n        const rs = (resp as Record<string, unknown>)['status'];\n        if (typeof rs === 'number') return rs;\n      }\n    }\n    return undefined;\n  }\n\n  // Support inline metadata: data:application/json;base64,<...> or URL-encoded JSON\n  function parseDataUrlJson(dataUrl: string): Record<string, unknown> | null {\n    try {\n      if (!dataUrl || !dataUrl.startsWith('data:')) return null;\n      const comma = dataUrl.indexOf(',');\n      if (comma < 0) return null;\n      const meta = dataUrl.slice(5, comma); // between 'data:' and comma\n      const payload = dataUrl.slice(comma + 1);\n      const isBase64 = /;base64/i.test(meta);\n      const decoded = isBase64 ? atob(payload) : decodeURIComponent(payload);\n      const json = JSON.parse(decoded) as unknown;\n      if (!json || typeof json !== 'object') return null;\n      return json as Record<string, unknown>;\n    } catch {\n      return null;\n    }\n  }\n\n  function isLikelyRpcEndpoint(uri: string): boolean {\n    try {\n      const u = new URL(uri);\n      return /rpc\\.reefscan\\.com/i.test(u.hostname) || /\\/rpc(\\/|$)/i.test(u.pathname);\n    } catch {\n      return false;\n    }\n  }\n\n  // Fallback: fetch marketplace items by collection (contract) once and cache\n  async function getSqwidMeta(contractAddress: string, nftId: string | number): Promise<{ name?: string; image?: string; media?: string; thumbnail?: string; mimetype?: string; amount?: number } | null> {\n    try {\n      const tokenIdKey = String(nftId);\n      const cache = sqwidCacheRef.current;\n      let contractMap = cache.get(contractAddress);\n      if (!contractMap) {\n        // Coalesce concurrent fetches for the same contract\n        let pending = sqwidPendingRef.current.get(contractAddress);\n        if (!pending) {\n          pending = (async () => {\n            const limit = 200;\n            const startFrom = 0;\n            const url = `https://sqwid-api-mainnet.reefscan.info/get/marketplace/by-collection/${contractAddress}/0?limit=${limit}&startFrom=${startFrom}`;\n            const res = await fetchWithAbort(url, { headers: { accept: 'application/json' } });\n            if (!res.ok) return;\n            const json = await res.json().catch(() => null);\n            const maybeItems = json && typeof json === 'object' ? (json as Record<string, unknown>)['items'] : undefined;\n            const items = Array.isArray(maybeItems) ? maybeItems : [];\n            const map = new Map<string, { name?: string; image?: string; media?: string; thumbnail?: string; mimetype?: string; amount?: number }>();\n            for (const it of items) {\n              const rawTokenId = get(it, ['tokenId']) ?? get(it, ['itemId']) ?? get(it, ['id']);\n              if (rawTokenId === undefined || rawTokenId === null) continue;\n              const tid = String(rawTokenId);\n              const rawImage = getString(it, ['meta', 'image']) ?? getString(it, ['image']) ?? getString(it, ['meta', 'thumbnail']);\n              const rawMedia = getString(it, ['meta', 'media']) ?? getString(it, ['media']) ?? getString(it, ['meta', 'animation_url']) ?? getString(it, ['animation_url']);\n              const rawThumb = getString(it, ['meta', 'thumbnail']) ?? getString(it, ['thumbnail']) ?? getString(it, ['meta', 'image_preview']);\n              const name = getString(it, ['meta', 'name']) ?? getString(it, ['name']);\n              const image = toIpfsHttp(rawImage);\n              const media = toIpfsHttp(rawMedia);\n              const thumbnail = toIpfsHttp(rawThumb);\n              const mimetype = getString(it, ['meta', 'mimetype']) ?? getString(it, ['mimetype']) ?? getString(it, ['meta', 'mimeType']);\n              const parsed = getNumber(it, ['amount']) ?? getNumber(it, ['state', 'amount']);\n              const amount = typeof parsed === 'number' && !Number.isNaN(parsed) ? parsed : undefined;\n              map.set(tid, { name, image, media, thumbnail, mimetype, amount });\n            }\n            cache.set(contractAddress, map);\n          })();\n          sqwidPendingRef.current.set(contractAddress, pending);\n        }\n        await pending;\n        sqwidPendingRef.current.delete(contractAddress);\n        contractMap = cache.get(contractAddress);\n      }\n      if (!contractMap) {\n        contractMap = new Map<string, { name?: string; image?: string; media?: string; thumbnail?: string; mimetype?: string; amount?: number }>();\n        cache.set(contractAddress, contractMap);\n      }\n      const hit = contractMap.get(tokenIdKey) ?? contractMap.get(String(Number(tokenIdKey)));\n      return hit ?? null;\n    } catch {\n      return null;\n    }\n  }\n\n  async function resolveTokenURI(contractAddress: string, nftId: string | number, tokenType?: string): Promise<string | null> {\n    // Ensure we only call RPC for valid EVM addresses; otherwise go straight to fallback\n    if (!isHexAddress(contractAddress)) return null;\n    // Try cache (memory/localStorage) first\n    const cached = tokenUriCacheRef.current.get(tokenUriCacheKey(contractAddress, nftId))\n      ?? getLocalTokenUri(contractAddress, nftId);\n    if (cached) return cached;\n    const idBig = BigInt(typeof nftId === 'string' ? (nftId.startsWith('0x') ? BigInt(nftId).toString() : nftId) : nftId);\n    const arg = toHex(BigInt(idBig));\n    // Selectors\n    const sel721 = '0xc87b56dd'; // tokenURI(uint256)\n    const sel1155 = '0x0e89341c'; // uri(uint256)\n\n    async function tryCall(selector: string): Promise<string | null> {\n      const data = selector + arg;\n      const result = await ethCall(contractAddress, data);\n      if (!result) {\n        const r2 = await reefEvmCall(contractAddress, data);\n        if (!r2) return null;\n        const value = decodeAbiString(r2);\n        if (value) {\n          tokenUriCacheRef.current.set(tokenUriCacheKey(contractAddress, nftId), value);\n          setLocalTokenUri(contractAddress, nftId, value);\n        }\n        return value;\n      }\n      const value = decodeAbiString(result);\n      if (value) {\n        tokenUriCacheRef.current.set(tokenUriCacheKey(contractAddress, nftId), value);\n        setLocalTokenUri(contractAddress, nftId, value);\n      }\n      return value;\n    }\n\n    if (tokenType === 'ERC721') {\n      return tryCall(sel721);\n    }\n    if (tokenType === 'ERC1155') {\n      return tryCall(sel1155);\n    }\n    // Unknown: try ERC721, then ERC1155\n    return (await tryCall(sel721)) ?? (await tryCall(sel1155));\n  }\n\n  function applyErc1155Template(uri: string, nftId: string | number): string {\n    // {id} must be 64-lowercase-hex padded\n    const id = BigInt(typeof nftId === 'string' ? nftId : Number(nftId));\n    const hexId = toHex(id).toLowerCase();\n    return uri.replace('{id}', hexId).replace('{ID}', hexId);\n  }\n\n  async function fetchMetadataOnce(contractAddress: string, nftId: string | number, tokenType?: string): Promise<Nft | null> {\n    const key = `${contractAddress}-${nftId}`;\n    if (inflightRef.current.has(key)) return inflightRef.current.get(key)!;\n\n    const task = (async () => {\n      // 0) Fast path: try Sqwid REST first to avoid unnecessary RPC\n      const sqwidQuick = await getSqwidMeta(contractAddress, nftId);\n      if (sqwidQuick && (sqwidQuick.image || sqwidQuick.media || sqwidQuick.thumbnail || sqwidQuick.name)) {\n        const name = sqwidQuick.name ?? `Token #${nftId}`;\n        const image = sqwidQuick.image;\n        const media = sqwidQuick.media;\n        const thumbnail = sqwidQuick.thumbnail;\n        const mimetype = sqwidQuick.mimetype;\n        const amount = sqwidQuick.amount;\n        return { id: key, name, image, media, thumbnail, mimetype, amount } as Nft;\n      }\n\n      // 1) Resolve tokenURI/uri via RPC (skips if RPC unavailable)\n      let tokenUri = await resolveTokenURI(contractAddress, nftId, tokenType);\n      if (!tokenUri) {\n        // Try Sqwid REST fallback first\n        const sqwid = await getSqwidMeta(contractAddress, nftId);\n        if (sqwid) {\n          const name = sqwid.name ?? `Token #${nftId}`;\n          const image = sqwid.image;\n          const media = sqwid.media;\n          const thumbnail = sqwid.thumbnail;\n          const mimetype = sqwid.mimetype;\n          const amount = sqwid.amount;\n          return { id: key, name, image, media, thumbnail, mimetype, amount } as Nft;\n        }\n        // Otherwise, render minimal placeholder so UI still shows the token\n        return { id: key, name: `Token #${nftId}` } as Nft;\n      }\n      // Handle inline metadata URIs without extra network requests\n      if (tokenUri.startsWith('data:')) {\n        const meta = parseDataUrlJson(tokenUri);\n        if (meta && typeof meta === 'object') {\n          const name = getString(meta, ['name']) ?? `Token #${nftId}`;\n          const image = toIpfsHttp(getString(meta, ['image']) ?? getString(meta, ['image_url']) ?? getString(meta, ['thumbnail']));\n          const media = toIpfsHttp(getString(meta, ['media']) ?? getString(meta, ['animation_url']) ?? getString(meta, ['animation']));\n          const thumbnail = toIpfsHttp(getString(meta, ['thumbnail']) ?? getString(meta, ['image_preview']) ?? getString(meta, ['image_small']) ?? getString(meta, ['preview_image']));\n          const mimetype = getString(meta, ['mimetype']) ?? getString(meta, ['mime_type']) ?? getString(meta, ['mimeType']) ?? getString(meta, ['format']);\n          return { id: key, name, image, media, thumbnail, mimetype } as Nft;\n        }\n        return { id: key, name: `Token #${nftId}` } as Nft;\n      }\n      // ERC1155 templates may include {id}\n      if (tokenUri.includes('{id}') || tokenUri.includes('{ID}')) {\n        tokenUri = applyErc1155Template(tokenUri, nftId);\n      }\n      const httpUri = toIpfsHttp(tokenUri);\n      if (!httpUri || isLikelyRpcEndpoint(httpUri)) {\n        const sqwid = await getSqwidMeta(contractAddress, nftId);\n        if (sqwid) {\n          const name = sqwid.name ?? `Token #${nftId}`;\n          const image = sqwid.image;\n          const media = sqwid.media;\n          const thumbnail = sqwid.thumbnail;\n          const mimetype = sqwid.mimetype;\n          const amount = sqwid.amount;\n          return { id: key, name, image, media, thumbnail, mimetype, amount } as Nft;\n        }\n        return { id: key, name: `Token #${nftId}` } as Nft;\n      }\n      // 2) Fetch metadata JSON\n      const resp = await fetchWithAbort(httpUri, { method: 'GET' });\n      if (!resp.ok) {\n        const sqwid = await getSqwidMeta(contractAddress, nftId);\n        if (sqwid) return { id: key, name: sqwid.name ?? `Token #${nftId}`, image: sqwid.image, media: sqwid.media, thumbnail: sqwid.thumbnail, mimetype: sqwid.mimetype } as Nft;\n        return { id: key, name: `Token #${nftId}` } as Nft;\n      }\n      const json = await resp.json().catch(() => null);\n      if (!json || typeof json !== 'object') {\n        const sqwid = await getSqwidMeta(contractAddress, nftId);\n        if (sqwid) return { id: key, name: sqwid.name ?? `Token #${nftId}`, image: sqwid.image, media: sqwid.media, thumbnail: sqwid.thumbnail, mimetype: sqwid.mimetype, amount: sqwid.amount } as Nft;\n        return { id: key, name: `Token #${nftId}` } as Nft;\n      }\n      const name = getString(json, ['name']) ?? `Token #${nftId}`;\n      const image = toIpfsHttp(getString(json, ['image']) ?? getString(json, ['image_url']) ?? getString(json, ['thumbnail']));\n      const media = toIpfsHttp(getString(json, ['media']) ?? getString(json, ['animation_url']) ?? getString(json, ['animation']));\n      const thumbnail = toIpfsHttp(getString(json, ['thumbnail']) ?? getString(json, ['image_preview']) ?? getString(json, ['image_small']) ?? getString(json, ['preview_image']));\n      const mimetype = getString(json, ['mimetype']) ?? getString(json, ['mime_type']) ?? getString(json, ['mimeType']) ?? getString(json, ['format']);\n      return { id: key, name, image, media, thumbnail, mimetype } as Nft;\n    })();\n\n    inflightRef.current.set(key, task);\n    try {\n      return await task;\n    } finally {\n      inflightRef.current.delete(key);\n    }\n  }\n\n  async function fetchMetadataWithRetry(contractAddress: string, nftId: string | number, tokenType?: string, retries = 2): Promise<Nft | null> {\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        return await fetchMetadataOnce(contractAddress, nftId, tokenType);\n      } catch (err: unknown) {\n        const status = getHttpStatus(err);\n        const isTransient = status === 503 || status === 502 || status === 429 || status === 500 || !status;\n        if (attempt < retries && isTransient) {\n          // Exponential backoff with jitter\n          const base = 300 * Math.pow(2, attempt); // 300, 600, 1200, 2400...\n          const jitter = Math.floor(Math.random() * 200);\n          await sleep(base + jitter);\n          continue;\n        }\n        return { id: `${contractAddress}-${nftId}`, name: 'Loading Failed', error: true } as Nft;\n      }\n    }\n    return { id: `${contractAddress}-${nftId}`, name: 'Loading Failed', error: true } as Nft;\n  }\n\n  const fetchAndProcessNfts = useCallback(\n    async (inputAddress: string, isCanceled: () => boolean) => {\n      if (!inputAddress) {\n        if (isCanceled()) return;\n        setNfts([]);\n        setCollections([]);\n        setIsLoading(false);\n        setError(null);\n        return;\n      }\n\n      if (!isCanceled()) setIsLoading(true);\n      if (!isCanceled()) setError(null);\n\n      try {\n        const evmAddress = await resolveEvmAddress(inputAddress);\n        if (!evmAddress) {\n          if (isCanceled()) return;\n          setNfts([]);\n          setCollections([]);\n          setIsLoading(false);\n          return;\n        }\n\n        // Page through tokenHolders to stay under Squid size limits\n        const pageSize = 100; // keep each response small\n        const maxPairs = 300;  // safety cap to avoid hammering downstream metadata API\n        const seen = new Set<string>();\n        const uniquePairs: { contractAddress: string; nftId: string | number; tokenType?: string; ownedAmount?: number }[] = [];\n        let offset = 0;\n        // Limit number of pages to avoid unbounded loops (e.g., 10 pages x 100 = 1000 max scan, but we cap by maxPairs)\n        for (let page = 0; page < 10; page++) {\n          const { data } = await client.query({\n            query: NFTS_BY_OWNER_PAGED_QUERY as unknown as DocumentNode,\n            variables: { owner: evmAddress, limit: pageSize, offset },\n            fetchPolicy: 'network-only',\n            context: { fetchOptions: { signal: getAbortSignal() } },\n          });\n          const tokenHolders = (data as { tokenHolders?: unknown[] })?.tokenHolders ?? [];\n          const batch = Array.isArray(tokenHolders) ? tokenHolders : [];\n          if (!Array.isArray(batch) || batch.length === 0) break;\n\n          for (const t of batch) {\n            const contractId = getString(t, ['token', 'id']);\n            const nftIdRaw = get(t, ['nftId']);\n            const nftId = typeof nftIdRaw === 'string' || typeof nftIdRaw === 'number' ? nftIdRaw : undefined;\n            const tokenType = getString(t, ['token', 'type']);\n            const ownedAmount = toU64(get(t, ['balance']), 0);\n            if (!contractId || (nftId === undefined || nftId === null)) continue;\n            const key = `${contractId}::${nftId}`;\n            if (!seen.has(key)) {\n              seen.add(key);\n              uniquePairs.push({ contractAddress: contractId, nftId, tokenType, ownedAmount });\n            }\n            if (uniquePairs.length >= maxPairs) break;\n          }\n\n          if (uniquePairs.length >= maxPairs) break;\n          offset += batch.length;\n          if (isCanceled()) return;\n        }\n\n        if (uniquePairs.length === 0) {\n          if (isCanceled()) return;\n          setNfts([]);\n          setCollections([]);\n          setIsLoading(false);\n          return;\n        }\n\n        // Preflight RPC support once to avoid first-try errors under parallelism\n        await checkEvmRpcHealth();\n        await checkEthCallSupport();\n        await checkReefEvmSupport();\n\n        // Prefetch tokenURIs in batches per contract for known token types\n        try {\n          const byContract = new Map<string, { nftId: string | number; tokenType?: string }[]>();\n          for (const p of uniquePairs) {\n            const list = byContract.get(p.contractAddress) ?? [];\n            list.push({ nftId: p.nftId, tokenType: p.tokenType });\n            byContract.set(p.contractAddress, list);\n          }\n          // For each contract: build batch for tokens with known type and no cache/REST hit\n          const prefetchTasks: Array<() => Promise<void>> = [];\n          for (const [contract, items] of byContract) {\n            prefetchTasks.push(async () => {\n              // Ensure REST cache is warmed once per contract\n              try { await getSqwidMeta(contract, items[0]?.nftId ?? '0'); } catch (e) { void e; /* ignore cache warmup errors */ }\n              const known = items.filter(it => it.tokenType === 'ERC721' || it.tokenType === 'ERC1155');\n              if (known.length === 0) return;\n              const datas: string[] = [];\n              const keys: (string | number)[] = [];\n              for (const it of known) {\n                const key = tokenUriCacheKey(contract, it.nftId);\n                if (tokenUriCacheRef.current.has(key) || getLocalTokenUri(contract, it.nftId)) continue;\n                const idBig = BigInt(typeof it.nftId === 'string' ? (it.nftId.startsWith('0x') ? BigInt(it.nftId).toString() : it.nftId) : it.nftId);\n                const arg = toHex(idBig);\n                const sel = it.tokenType === 'ERC1155' ? '0x0e89341c' : '0xc87b56dd';\n                datas.push(sel + arg);\n                keys.push(it.nftId);\n              }\n              if (datas.length === 0) return;\n              const batchRes = await reefEvmCallBatch(contract, datas);\n              for (let i = 0; i < batchRes.length; i++) {\n                const r = batchRes[i];\n                if (!r) continue;\n                const decoded = decodeAbiString(r);\n                if (!decoded) continue;\n                const nftId = keys[i];\n                const cacheKey = tokenUriCacheKey(contract, nftId);\n                tokenUriCacheRef.current.set(cacheKey, decoded);\n                setLocalTokenUri(contract, nftId, decoded);\n              }\n            });\n          }\n          // Concurrency-limited execution of prefetch tasks across contracts\n          let pIndex = 0;\n          async function prefetchWorker() {\n            while (pIndex < prefetchTasks.length) {\n              const current = pIndex++;\n              try { await prefetchTasks[current](); } catch (e) { void e; /* ignore individual prefetch errors */ }\n            }\n          }\n          const prefetchConcurrency = Math.max(1, Math.min(PREFETCH_MAX_WORKERS, prefetchTasks.length));\n          await Promise.all(Array.from({ length: prefetchConcurrency }, () => prefetchWorker()));\n        } catch (e) { void e; /* ignore prefetch stage errors */ }\n\n        // Concurrency limiter to avoid hammering API\n        const concurrency = FETCH_CONCURRENCY;\n        const results: PromiseSettledResult<Nft | null>[] = [];\n        let index = 0;\n        async function worker() {\n          while (index < uniquePairs.length) {\n            const current = index++;\n            const { contractAddress, nftId, tokenType, ownedAmount } = uniquePairs[current];\n            const value = await fetchMetadataWithRetry(contractAddress, nftId, tokenType);\n            // Prefer the owner's actual balance (ERC-1155) for displayed amount when available\n            if (value && typeof ownedAmount === 'number' && ownedAmount > 0) {\n              value.amount = ownedAmount;\n            }\n            results[current] = { status: 'fulfilled', value } as PromiseFulfilledResult<Nft | null>;\n          }\n        }\n        const workers = Array.from({ length: Math.min(concurrency, uniquePairs.length) }, () => worker());\n        await Promise.all(workers);\n\n        const allNfts = results\n          .map((r) => (r.status === 'fulfilled' ? (r as PromiseFulfilledResult<Nft | null>).value : null))\n          .filter((n): n is Nft => n !== null);\n\n        if (isCanceled()) return;\n        setNfts(allNfts.map(nft => ({ ...nft, image: nft.image ? toIpfsUrl(nft.image) : undefined })));\n\n        // Process NFTs to extract unique collections\n        const collectionsMap = new Map<string, Collection>();\n        allNfts.forEach(nft => {\n          if (nft.collection && nft.collection.id) {\n            const existing = collectionsMap.get(nft.collection.id);\n            if (existing) {\n              existing.itemCount += 1;\n            } else {\n              collectionsMap.set(nft.collection.id, {\n                id: nft.collection.id,\n                name: nft.collection.name || 'Unnamed Collection',\n                image: nft.collection.image ? toIpfsUrl(nft.collection.image) : (nft.image ? toIpfsUrl(nft.image) : ''),\n                itemCount: 1,\n              });\n            }\n          }\n        });\n\n        if (isCanceled()) return;\n        setCollections(Array.from(collectionsMap.values()));\n      } catch (err) {\n        console.error('Error fetching or processing NFTs:', err);\n        if (!isCanceled()) setError(err as Error);\n      } finally {\n        if (!isCanceled()) setIsLoading(false);\n      }\n    },\n    [resolveEvmAddress]\n  );\n\n    useEffect(() => {\n      let canceled = false;\n      const controller = new AbortController();\n      setAbortController(controller);\n      const isCanceled = () => canceled || controller.signal.aborted;\n      // Fire and forget; internal functions check isCanceled and fetch is abortable\n      fetchAndProcessNfts(address ?? '', isCanceled).catch((e) => { void e; /* ignore top-level rejection; handled internally */ });\n      return () => {\n        canceled = true;\n        try { controller.abort(); } catch (e) { void e; /* ignore abort errors */ }\n        setAbortController(null);\n      };\n    }, [address, fetchAndProcessNfts]);\n\n  return { nfts, collections, isLoading, error };\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\hooks\\use-transaction-data-with-blocks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\hooks\\usePaginationAndSorting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\hooks\\useTanstackTransactionAdapter.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'initialTransactions'. Either include it or remove the dependency array.","line":71,"column":6,"nodeType":"ArrayExpression","endLine":78,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [pagination.pageIndex, pagination.pageSize, initialTransactions.length, hasNextPage, isLoading, fetchMore, initialTransactions]","fix":{"range":[2344,2480],"text":"[pagination.pageIndex, pagination.pageSize, initialTransactions.length, hasNextPage, isLoading, fetchMore, initialTransactions]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useState } from 'react';\nimport {\n  useReactTable,\n  getCoreRowModel,\n  getPaginationRowModel,\n  Table,\n  PaginationState,\n} from '@tanstack/react-table';\nimport { useTransactionDataWithBlocks } from './use-transaction-data-with-blocks';\nimport { transactionColumns } from '../components/transaction-columns';\nimport { UiTransfer } from '../data/transfer-mapper';\nimport { PAGINATION_CONFIG } from '../constants/pagination';\nimport { ApolloError } from '@apollo/client';\n\nexport interface TanstackTransactionAdapterReturn {\n  table: Table<UiTransfer>;\n  isLoading: boolean;\n  error?: ApolloError | Error;\n}\n\nexport function useTanstackTransactionAdapter(\n  address: string,\n): TanstackTransactionAdapterReturn {\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize: PAGINATION_CONFIG.UI_TRANSACTIONS_PER_PAGE,\n  });\n\n  const {\n    transfers: initialTransactions,\n    loading: isLoading,\n    error,\n    fetchMore,\n    hasMore: hasNextPage,\n    totalCount,\n  } = useTransactionDataWithBlocks(address, PAGINATION_CONFIG.API_FETCH_PAGE_SIZE);\n\n  // Apollo cache is the single source of truth; pages are merged by typePolicies\n\n  const pageCount = useMemo(() => {\n    if (totalCount === 0) return 0;\n    return Math.ceil(totalCount / pagination.pageSize);\n  }, [totalCount, pagination.pageSize]);\n\n  const dataForCurrentPage = useMemo(() => {\n    const { pageIndex, pageSize } = pagination;\n    const start = pageIndex * pageSize;\n    const end = start + pageSize;\n    return (initialTransactions || []).slice(start, end);\n  }, [pagination, initialTransactions]);\n\n  const table = useReactTable({\n    data: dataForCurrentPage,\n    columns: transactionColumns,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    manualPagination: true,\n    pageCount,\n    state: { pagination },\n    onPaginationChange: setPagination,\n  });\n\n  useEffect(() => {\n    const itemsLoaded = (initialTransactions || []).length;\n    const currentPageFirstItemIndex = pagination.pageIndex * pagination.pageSize;\n\n    // Fetch more if we are near the end of the currently loaded data and a next page exists.\n    if (itemsLoaded > 0 && itemsLoaded - currentPageFirstItemIndex < pagination.pageSize && hasNextPage && !isLoading) {\n      fetchMore();\n    }\n  }, [\n    pagination.pageIndex,\n    pagination.pageSize,\n    initialTransactions?.length,\n    hasNextPage,\n    isLoading,\n    fetchMore,\n  ]);\n\n  return {\n    table,\n    isLoading,\n    error,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\hooks\\useTransferSubscription.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\test-utils\\testing-library-utils.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"This rule can't verify that `export *` only exports components.","line":37,"column":1,"nodeType":"ExportAllDeclaration","messageId":"exportAll","endLine":37,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { ReactElement } from 'react';\nimport { render, renderHook, RenderOptions, RenderHookOptions } from '@testing-library/react';\nimport { MockedProvider, MockedResponse } from '@apollo/client/testing';\nimport { cache } from '../apollo-client';\n\n\nconst createCustomWrapper = (mocks: readonly MockedResponse<Record<string, unknown>>[] = []) => {\n  const CustomWrapper = ({ children }: { children: React.ReactNode }) => (\n    <MockedProvider mocks={mocks} cache={cache} addTypename>\n      {children}\n    </MockedProvider>\n  );\n  return CustomWrapper;\n};\n\n// Custom render for components\nconst customRender = (\n  ui: ReactElement,\n  options?: Omit<RenderOptions, 'wrapper'> & { mocks?: readonly MockedResponse<Record<string, unknown>>[] }\n) => {\n  const { mocks, ...renderOptions } = options || {};\n  return render(ui, { wrapper: createCustomWrapper(mocks), ...renderOptions });\n};\n\n// Custom renderHook for hooks\nfunction renderHookWithProviders<TProps, TResult>(\n  callback: (props: TProps) => TResult,\n  options?: RenderHookOptions<TProps> & { mocks?: readonly MockedResponse<Record<string, unknown>>[] }\n) {\n  const { mocks, ...hookOptions } = options || {};\n  return renderHook(callback, {\n    wrapper: createCustomWrapper(mocks),\n    ...hookOptions,\n  });\n}\n\nexport * from '@testing-library/react';\nexport { customRender as render, renderHookWithProviders };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\types\\nft.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\types\\tanstack-table.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\utils\\address-helpers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\utils\\address-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\utils\\error-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\utils\\formatters.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\utils\\formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\utils\\ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\tests\\e2e\\address-validation.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\tests\\e2e\\nft-header-no-overview.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\tests\\e2e\\nft-invalid-address.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\tests\\e2e\\nft-substrate-no-evm.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\tests\\e2e\\nft.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\tests\\e2e\\viewmode-optimization.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\tests\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\CascadeProjects\\reef-web3-history-vite\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]