[{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\apollo-client.ts","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":22,"column":109,"nodeType":"BlockStatement","messageId":"unexpected","endLine":22,"endColumn":111,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[972,972],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":27,"column":87,"nodeType":"BlockStatement","messageId":"unexpected","endLine":27,"endColumn":89,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1158,1158],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":28,"column":93,"nodeType":"BlockStatement","messageId":"unexpected","endLine":28,"endColumn":95,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1257,1257],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1305,1308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1305,1308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1317,1320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1317,1320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":31,"column":181,"nodeType":"BlockStatement","messageId":"unexpected","endLine":31,"endColumn":183,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1504,1504],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1628,1631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1628,1631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":34,"column":135,"nodeType":"BlockStatement","messageId":"unexpected","endLine":34,"endColumn":137,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1673,1673],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2538,2541],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2538,2541],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3500,3503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3500,3503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4048,4051],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4048,4051],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":100,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4469,4472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4469,4472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5015,5018],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5015,5018],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5076,5079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5076,5079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5963,5966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5963,5966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5996,5999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5996,5999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6275,6278],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6275,6278],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6507,6510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6507,6510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6809,6812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6809,6812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6870,6873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6870,6873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":155,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7353,7356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7353,7356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":155,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7386,7389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7386,7389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":22,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApolloClient, InMemoryCache, HttpLink, ApolloLink, split } from '@apollo/client';\r\nimport type { TransfersMinQueryQuery } from '@/gql/graphql';\r\nimport { getMainDefinition } from '@apollo/client/utilities';\r\nimport { GraphQLWsLink } from '@apollo/client/link/subscriptions';\r\nimport { createClient as createWSClient } from 'graphql-ws';\r\n\r\nconst httpLink = new HttpLink({\r\n  uri: 'https://squid.subsquid.io/reef-explorer/graphql',\r\n  useGETForQueries: true,\r\n});\r\n\r\nlet lastRetryTries = 0;\r\nconst wsClient = createWSClient({\r\n  url: 'wss://squid.subsquid.io/reef-explorer/graphql',\r\n  lazy: true,\r\n  keepAlive: 15000,\r\n  retryWait: async (tries) => {\r\n    lastRetryTries = tries;\r\n    const base = Math.min(30000, 1000 * Math.pow(2, Math.min(tries - 1, 5)));\r\n    const jitter = Math.floor(base * 0.2 * Math.random());\r\n    const delay = base + jitter;\r\n    try { window.dispatchEvent(new CustomEvent('ws-retry', { detail: { tries, delayMs: delay } })); } catch {}\r\n    await new Promise((r) => setTimeout(r, delay));\r\n  },\r\n  shouldRetry: () => true,\r\n  on: {\r\n    opened: () => { try { window.dispatchEvent(new CustomEvent('ws-opened')); } catch {} },\r\n    connected: () => { try { window.dispatchEvent(new CustomEvent('ws-connected')); } catch {} },\r\n    closed: (ev) => {\r\n      const anyEv: any = ev as any;\r\n      try { window.dispatchEvent(new CustomEvent('ws-closed', { detail: { code: anyEv?.code, reason: anyEv?.reason, wasClean: anyEv?.wasClean, tries: lastRetryTries } })); } catch {}\r\n    },\r\n    error: (err) => {\r\n      try { window.dispatchEvent(new CustomEvent('ws-error', { detail: { message: (err as any)?.message ?? String(err) } })); } catch {}\r\n    },\r\n  },\r\n});\r\n\r\nconst wsLink = new GraphQLWsLink(wsClient);\r\n\r\n// Lightweight timing hook (now silent). Keeps structure for potential future use.\r\nconst shouldLogTiming = (import.meta.env.VITE_APOLLO_TIMING === '1' || import.meta.env.VITE_APOLLO_TIMING === 'true');\r\nconst measureOps = new Set(['PaginatedTransfers', 'TransfersPollingQuery']);\r\nconst timingLink = new ApolloLink((operation, forward) => {\r\n  const opName = operation.operationName || 'UnknownOp';\r\n  const obs = forward(operation);\r\n  if (!measureOps.has(opName)) return obs;\r\n  return obs.map((result) => {\r\n    if (!shouldLogTiming) return result;\r\n    // Timing logs disabled\r\n    return result;\r\n  });\r\n});\r\nconst httpBaseLink = shouldLogTiming ? ApolloLink.from([timingLink, httpLink]) : httpLink;\r\n\r\nconst link = split(\r\n  ({ query }) => {\r\n    const def = getMainDefinition(query) as any;\r\n    return def.kind === 'OperationDefinition' && def.operation === 'subscription';\r\n  },\r\n  wsLink,\r\n  httpBaseLink\r\n);\r\n\r\nexport const cache = new InMemoryCache({\r\n  typePolicies: {\r\n    Query: {\r\n      fields: {\r\n        transfersConnection: {\r\n          keyArgs: ['where', 'orderBy'],\r\n          // Merge policy tuned for stable, globally ordered pagination.\r\n          // - First page (after == null): prepend incoming edges into existing list with de-duplication,\r\n          //   preserving already-loaded older pages to keep page boundaries stable during refresh.\r\n          // - Subsequent pages (after != null): append while de-duplicating by node.id.\r\n          merge(\r\n            existing: TransfersMinQueryQuery['transfersConnection'] | undefined,\r\n            incoming: TransfersMinQueryQuery['transfersConnection'],\r\n            options\r\n          ) {\r\n            if (!incoming) return existing;\r\n            const after = (options?.args as any)?.after ?? null;\r\n            const incomingEdges = incoming?.edges ?? [];\r\n\r\n            // First page: prepend + dedupe to retain older pages and preserve global order\r\n            if (after == null) {\r\n              const existingEdges = existing?.edges ?? [];\r\n              const seen = new Set<string>();\r\n              // Seed with incoming (newest-first) to respect server order at the top\r\n              const mergedEdges = [] as typeof incomingEdges;\r\n              for (const e of incomingEdges) {\r\n                const key = (e as any)?.node?.id as string | undefined;\r\n                const skey = key ? String(key) : undefined;\r\n                if (!skey || !seen.has(skey)) {\r\n                  if (skey) seen.add(skey);\r\n                  mergedEdges.push(e);\r\n                }\r\n              }\r\n              // Append existing edges that are not already present\r\n              for (const e of existingEdges) {\r\n                const key = (e as any)?.node?.id as string | undefined;\r\n                const skey = key ? String(key) : undefined;\r\n                if (!skey || !seen.has(skey)) {\r\n                  if (skey) seen.add(skey);\r\n                  mergedEdges.push(e);\r\n                }\r\n              }\r\n\r\n              // Prefer incoming pageInfo when it is present; fall back to existing when incoming omitted it.\r\n              // This prevents count-only queries (which don't request pageInfo) from freezing pagination.\r\n              const incomingPI = incoming?.pageInfo as any;\r\n              const existingPI = existing?.pageInfo as any;\r\n              const hasIncomingPI = incomingPI && (typeof incomingPI?.hasNextPage === 'boolean' || incomingPI?.endCursor != null);\r\n              const mergedPageInfo = hasIncomingPI\r\n                ? {\r\n                    ...(existingPI ?? {}),\r\n                    ...(incomingPI ?? {}),\r\n                    hasNextPage: (incomingPI?.hasNextPage ?? existingPI?.hasNextPage ?? false) as boolean,\r\n                    endCursor: (incomingPI?.endCursor ?? existingPI?.endCursor ?? null) as string | null,\r\n                  }\r\n                : (existingPI ?? incomingPI ?? { hasNextPage: false, endCursor: null });\r\n\r\n              return {\r\n                ...incoming,\r\n                edges: mergedEdges,\r\n                pageInfo: mergedPageInfo,\r\n                // Keep totalCount stable if incoming omitted it (e.g., test mocks)\r\n                totalCount: (incoming as any)?.totalCount ?? (existing as any)?.totalCount,\r\n              };\r\n            }\r\n\r\n            // Next pages: append + dedupe\r\n            const existingEdges = existing?.edges ?? [];\r\n            const seen = new Set<string>();\r\n            for (const e of existingEdges) {\r\n              const key = (e as any)?.node?.id as string | undefined;\r\n              if (key) seen.add(String(key));\r\n            }\r\n            const mergedEdges = [...existingEdges];\r\n            for (const e of incomingEdges) {\r\n              const key = (e as any)?.node?.id as string | undefined;\r\n              const skey = key ? String(key) : undefined;\r\n              if (!skey || !seen.has(skey)) {\r\n                if (skey) seen.add(skey);\r\n                mergedEdges.push(e);\r\n              }\r\n            }\r\n            const incomingPI = (incoming as any)?.pageInfo;\r\n            const existingPI = (existing as any)?.pageInfo;\r\n            const hasIncomingPI = incomingPI && (typeof incomingPI?.hasNextPage === 'boolean' || incomingPI?.endCursor != null);\r\n            return {\r\n              ...incoming,\r\n              edges: mergedEdges,\r\n              pageInfo: hasIncomingPI ? { ...(existingPI ?? {}), ...(incomingPI ?? {}) } : (existingPI ?? incomingPI),\r\n              // Preserve totalCount if it's not present in incoming payload (e.g., mocks)\r\n              totalCount: (incoming as any)?.totalCount ?? (existing as any)?.totalCount,\r\n            };\r\n          },\r\n        },\r\n      },\r\n    },\r\n  },\r\n});\r\n\r\nexport const apolloClient = new ApolloClient({\r\n  link,\r\n  cache,\r\n  // Silence Apollo DevTools suggestion banner in dev console\r\n  connectToDevTools: false,\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\AddressDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\BalancesTable.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[636,639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[636,639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":311,"column":112,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":311,"endColumn":115,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13535,13538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13535,13538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { toFloatAmount } from '@/utils/token-helpers';\r\nimport { Loader2, Wallet, Copy, Check } from 'lucide-react';\r\nimport { useTokenBalances } from '@/hooks/use-token-balances';\r\nimport { formatTokenAmount } from '@/utils/formatters';\r\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from './ui/tooltip';\r\nimport React from 'react';\r\nimport { shortenHash } from '@/utils/formatters';\r\nimport { useTokenIcons } from '@/hooks/use-token-icons';\r\nimport { isIpfsLike, buildCandidates } from '@/utils/ipfs';\r\nimport { useTokenUsdPrices } from '@/hooks/use-token-usd-prices';\r\n\r\ninterface BalanceRowProps {\r\n  balance: any;\r\n  index: number;\r\n  price: number | null;\r\n  valueUsd: number | null;\r\n  amount: string;\r\n  copied: string | null;\r\n  handleCopy: (id: string) => void;\r\n  iconsById: Record<string, string | undefined>;\r\n  TOKEN_LOGO_FALLBACKS: Record<string, string[]>;\r\n  TOKEN_LOGO_OVERRIDES: Record<string, string[]>;\r\n  isLocalAsset: (url: string) => boolean;\r\n  usdFmt: Intl.NumberFormat;\r\n}\r\n\r\nconst BalanceRow = React.memo(function BalanceRow({\r\n  balance: b,\r\n  index,\r\n  price,\r\n  valueUsd,\r\n  amount,\r\n  copied,\r\n  handleCopy,\r\n  iconsById,\r\n  TOKEN_LOGO_FALLBACKS,\r\n  TOKEN_LOGO_OVERRIDES,\r\n  isLocalAsset,\r\n  usdFmt,\r\n}: BalanceRowProps) {\r\n  return (\r\n    <tr\r\n      key={b.token.id}\r\n      className={`group transition-colors transition-transform duration-200 hover:bg-gray-50 hover:-translate-y-px ${index % 2 === 0 ? 'bg-white' : 'bg-slate-50/30'}`}\r\n    >\r\n      <td className=\"px-4 py-5 whitespace-nowrap\">\r\n        <TooltipProvider>\r\n          <Tooltip>\r\n            <TooltipTrigger asChild>\r\n              <button\r\n                type=\"button\"\r\n                onClick={() => handleCopy(b.token.id)}\r\n                className=\"group inline-flex items-center gap-3 hover:text-blue-600 focus:outline-none\"\r\n                title={b.token.id}\r\n                aria-label=\"Copy token contract address\"\r\n              >\r\n                {(() => {\r\n                  const sym = (b.token.name || '').toUpperCase();\r\n                  const fallbacks = TOKEN_LOGO_FALLBACKS[sym] || [];\r\n                  const tokenIdLower = (b.token.id || '').toLowerCase();\r\n                  const overrideList = TOKEN_LOGO_OVERRIDES[tokenIdLower] ?? [];\r\n                  const fromQuery = iconsById[b.token.id];\r\n                  const raw = [fromQuery, ...overrideList, b.token.image, ...fallbacks].filter(Boolean) as string[];\r\n                  const dedup = new Set<string>();\r\n                  const localSources: string[] = [];\r\n                  const ipfsSources: string[] = [];\r\n                  for (const u of raw) {\r\n                    if (isLocalAsset(u)) {\r\n                      if (!dedup.has(u)) { dedup.add(u); localSources.push(u); }\r\n                    } else if (isIpfsLike(u)) {\r\n                      for (const c of buildCandidates(u)) {\r\n                        if (!dedup.has(c)) { dedup.add(c); ipfsSources.push(c); }\r\n                      }\r\n                    }\r\n                  }\r\n                  const sources = [...localSources, ...ipfsSources];\r\n                  if (sources.length > 0) {\r\n                    return (\r\n                      <img\r\n                        src={sources[0]!}\r\n                        data-idx={0}\r\n                        alt={`${b.token.name} icon`}\r\n                        loading=\"lazy\"\r\n                        decoding=\"async\"\r\n                        referrerPolicy=\"no-referrer\"\r\n                        className=\"h-6 w-6 rounded-full object-cover border border-gray-200\"\r\n                        onError={(e) => {\r\n                          const img = e.currentTarget as HTMLImageElement & { dataset: { idx?: string } };\r\n                          const i = Number(img.dataset.idx ?? '0');\r\n                          const next = i + 1;\r\n                          if (next < sources.length) {\r\n                            img.dataset.idx = String(next);\r\n                            img.src = sources[next]!;\r\n                          } else {\r\n                            try {\r\n                              const fallback = document.createElement('div');\r\n                              fallback.className = 'flex h-6 w-6 items-center justify-center rounded-full bg-gray-100 text-gray-600 text-[10px] font-semibold';\r\n                              const text = (b.token.name || '?').slice(0, 2).toUpperCase();\r\n                              fallback.textContent = text;\r\n                              img.replaceWith(fallback);\r\n                            } catch {\r\n                              img.style.display = 'none';\r\n                            }\r\n                          }\r\n                        }}\r\n                      />\r\n                    );\r\n                  }\r\n                  return (\r\n                    <div className=\"flex h-6 w-6 items-center justify-center rounded-full bg-gray-100 text-gray-600 text-[10px] font-semibold\">\r\n                      {(b.token.name || '?').slice(0, 2).toUpperCase()}\r\n                    </div>\r\n                  );\r\n                })()}\r\n                <div className=\"flex flex-col items-start\">\r\n                  <span className=\"font-medium text-gray-800\">{b.token.name}</span>\r\n                  <span className=\"text-xs text-gray-500 inline-flex items-center gap-1\">\r\n                    <span className=\"font-mono\">{shortenHash(b.token.id, 6, 6)}</span>\r\n                    {copied === b.token.id ? (\r\n                      <Check className=\"h-3.5 w-3.5 text-green-600\" />\r\n                    ) : (\r\n                      <Copy className=\"h-3.5 w-3.5 text-gray-400 group-hover:text-blue-600\" />\r\n                    )}\r\n                  </span>\r\n                </div>\r\n              </button>\r\n            </TooltipTrigger>\r\n            <TooltipContent>\r\n              <p className=\"break-all\">{b.token.id}</p>\r\n            </TooltipContent>\r\n          </Tooltip>\r\n        </TooltipProvider>\r\n      </td>\r\n      <td className=\"px-4 py-5 whitespace-nowrap\">\r\n        <div className=\"flex items-center gap-2\">\r\n          <span className=\"font-medium tabular-nums text-gray-900\">{amount}</span>\r\n        </div>\r\n      </td>\r\n      <td className=\"px-2 py-5 whitespace-nowrap text-right\">\r\n        {typeof price === 'number' && Number.isFinite(price) && price > 0 ? (\r\n          <span className=\"tabular-nums\">{usdFmt.format(price)}</span>\r\n        ) : (\r\n          <span className=\"text-gray-500\">—</span>\r\n        )}\r\n      </td>\r\n      <td className=\"px-2 py-5 whitespace-nowrap text-right\">\r\n        {typeof valueUsd === 'number' && Number.isFinite(valueUsd) && valueUsd > 0 ? (\r\n          <span className=\"font-semibold tabular-nums\">{usdFmt.format(valueUsd)}</span>\r\n        ) : (\r\n          <span className=\"text-gray-500\">—</span>\r\n        )}\r\n      </td>\r\n    </tr>\r\n  );\r\n});\r\n\r\ninterface BalancesTableProps {\r\n  address: string;\r\n  onCountsChange?: (count: number) => void;\r\n}\r\n\r\nexport function BalancesTable({ address, onCountsChange }: BalancesTableProps) {\r\n  const { balances, loading, error, totalCount } = useTokenBalances(address, 50);\r\n  const [copied, setCopied] = React.useState<string | null>(null);\r\n  const [hideNoPrice, setHideNoPrice] = React.useState(false);\r\n  const [sort, setSort] = React.useState<{ key: 'balance' | 'value'; dir: 'asc' | 'desc' } | null>(null);\r\n\r\n  const sortBadge = React.useMemo(() => {\r\n    if (!sort) return null;\r\n    const label = sort.key === 'balance' ? 'Balance' : 'Value';\r\n    return `${label} ${sort.dir === 'desc' ? '↓' : '↑'}`;\r\n  }, [sort]);\r\n\r\n  React.useEffect(() => {\r\n    if (!onCountsChange) return;\r\n    if (loading && typeof totalCount !== 'number') return;\r\n    const value = typeof totalCount === 'number' ? totalCount : balances.length;\r\n    if (!Number.isFinite(value)) return;\r\n    onCountsChange(value);\r\n  }, [onCountsChange, loading, totalCount, balances.length]);\r\n\r\n  // Well-known token logo fallbacks (external). Try in order.\r\n  const TOKEN_LOGO_FALLBACKS: Record<string, string[]> = React.useMemo(() => ({\r\n    REEF: [\r\n      '/token-logos/reef.png',\r\n    ],\r\n  }), []);\r\n\r\n  // Per-contract overrides (exact match by contract id, LOWERCASE keys)\r\n  // Use local assets in public/token-logos to avoid CORS/CORP issues\r\n  const TOKEN_LOGO_OVERRIDES: Record<string, string[]> = React.useMemo(() => ({\r\n    // REEF system token — only reef.png per request\r\n    '0x0000000000000000000000000000000001000000': [\r\n      '/token-logos/reef.png',\r\n    ],\r\n  }), []);\r\n\r\n  // Query official icons only for the tokens that are currently shown\r\n  const tokenIds = React.useMemo(() => balances.map((b) => b.token.id), [balances]);\r\n  const { icons: iconsById } = useTokenIcons(tokenIds, 100);\r\n\r\n  // Prepare pricing inputs and fetch USD prices via Reefswap reserves\r\n  const pricingInputs = React.useMemo(() => balances.map((b) => ({ id: b.token.id, decimals: b.token.decimals })), [balances]);\r\n  const { pricesById } = useTokenUsdPrices(pricingInputs);\r\n\r\n  const displayBalances = React.useMemo(() => {\r\n    const filtered = hideNoPrice\r\n      ? balances.filter((b) => {\r\n          const price = pricesById[(b.token.id || '').toLowerCase()] ?? null;\r\n          return typeof price === 'number' && Number.isFinite(price) && price > 0;\r\n        })\r\n      : balances.slice();\r\n    if (!sort) return filtered;\r\n    const arr = filtered.slice();\r\n    arr.sort((a, b) => {\r\n      if (sort.key === 'balance') {\r\n        const aAmt = toFloatAmount(a.balance, a.token.decimals);\r\n        const bAmt = toFloatAmount(b.balance, b.token.decimals);\r\n        const cmp = aAmt - bAmt;\r\n        return sort.dir === 'asc' ? (cmp < 0 ? -1 : cmp > 0 ? 1 : 0) : (cmp < 0 ? 1 : cmp > 0 ? -1 : 0);\r\n      }\r\n      const ap = pricesById[(a.token.id || '').toLowerCase()] ?? null;\r\n      const bp = pricesById[(b.token.id || '').toLowerCase()] ?? null;\r\n      const aVal = (typeof ap === 'number' && Number.isFinite(ap) && ap > 0 ? ap : 0) * toFloatAmount(a.balance, a.token.decimals);\r\n      const bVal = (typeof bp === 'number' && Number.isFinite(bp) && bp > 0 ? bp : 0) * toFloatAmount(b.balance, b.token.decimals);\r\n      const cmp = aVal - bVal;\r\n      return sort.dir === 'asc' ? (cmp < 0 ? -1 : cmp > 0 ? 1 : 0) : (cmp < 0 ? 1 : cmp > 0 ? -1 : 0);\r\n    });\r\n    return arr;\r\n  }, [balances, hideNoPrice, pricesById, sort]);\r\n  const usdFmt = React.useMemo(() => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 6 }), []);\r\n  \r\n  function toggleSort(key: 'balance' | 'value') {\r\n    setSort((prev) => {\r\n      if (!prev || prev.key !== key) return { key, dir: 'desc' };\r\n      return { key, dir: prev.dir === 'desc' ? 'asc' : 'desc' };\r\n    });\r\n  }\r\n\r\n  function sortIndicator(key: 'balance' | 'value'): string {\r\n    if (!sort || sort.key !== key) return '↕';\r\n    return sort.dir === 'desc' ? '▼' : '▲';\r\n  }\r\n\r\n  const totalUsd = React.useMemo(() => {\r\n    try {\r\n      let sum = 0;\r\n      for (const b of displayBalances) {\r\n        const price = pricesById[(b.token.id || '').toLowerCase()] ?? null;\r\n        if (typeof price !== 'number' || !Number.isFinite(price) || price <= 0) continue;\r\n        const amt = toFloatAmount(b.balance, b.token.decimals);\r\n        if (!Number.isFinite(amt) || amt <= 0) continue;\r\n        sum += amt * price;\r\n      }\r\n      return sum;\r\n    } catch {\r\n      return 0;\r\n    }\r\n  }, [displayBalances, pricesById]);\r\n\r\n  function isLocalAsset(url: string): boolean {\r\n    try {\r\n      return typeof url === 'string' && url.startsWith('/') && !url.startsWith('//');\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async function handleCopy(id: string) {\r\n    try {\r\n      await navigator.clipboard.writeText(id);\r\n      setCopied(id);\r\n      window.setTimeout(() => setCopied(null), 1200);\r\n    } catch {\r\n      // ignore\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"relative p-6 bg-white rounded-xl border border-gray-100 shadow-sm overflow-hidden\">\r\n      {sortBadge ? (\r\n        <div className=\"absolute top-2 right-3\">\r\n          <span className=\"text-[10px] font-medium px-2 py-0.5 rounded-full border border-gray-200 bg-gray-50 text-gray-700\">\r\n            Sorted by {sortBadge}\r\n          </span>\r\n        </div>\r\n      ) : null}\r\n      <div className=\"absolute inset-x-0 top-0 h-1 bg-gradient-to-r from-transparent via-blue-500/40 to-transparent opacity-60\" />\r\n      <div className=\"flex items-center justify-between mb-3\">\r\n        <div className=\"flex items-center gap-2 text-gray-700\">\r\n          <Wallet className=\"h-5 w-5\" />\r\n          <span className=\"font-semibold\">Token Balances</span>\r\n          <span className=\"text-sm text-gray-500\">{totalCount ? `${totalCount} total` : ''}</span>\r\n          {Number.isFinite(totalUsd) && totalUsd > 0 ? (\r\n            <span className=\"ml-2 text-sm text-gray-600\">Portfolio: <span className=\"font-semibold\">{usdFmt.format(totalUsd)}</span></span>\r\n          ) : null}\r\n        </div>\r\n        <label className=\"flex items-center gap-2 text-sm text-gray-600 select-none\">\r\n          <input\r\n            type=\"checkbox\"\r\n            className=\"h-4 w-4 accent-blue-600\"\r\n            checked={hideNoPrice}\r\n            onChange={(e) => setHideNoPrice(e.target.checked)}\r\n            aria-label=\"Hide tokens without USD price\"\r\n          />\r\n          Hide tokens without price\r\n        </label>\r\n      </div>\r\n\r\n      {error && (\r\n        <div className=\"mb-3 rounded border border-red-200 bg-red-50 px-3 py-2 text-red-800\">{String((error as any)?.message || error)}</div>\r\n      )}\r\n\r\n      <div className=\"overflow-x-auto md:overflow-x-visible\">\r\n        <table className=\"w-full table-fixed divide-y divide-gray-200\">\r\n          <thead className=\"bg-slate-50\">\r\n            <tr className=\"border-b-2 border-slate-200\">\r\n              <th className=\"px-4 py-3 text-left text-[11px] font-semibold text-slate-400 uppercase tracking-[0.14em] font-sans\">TOKEN</th>\r\n              <th\r\n                className=\"px-4 py-3 text-left text-[11px] font-semibold text-slate-400 uppercase tracking-[0.14em] font-sans cursor-pointer select-none\"\r\n                onClick={() => toggleSort('balance')}\r\n                aria-sort={sort?.key === 'balance' ? (sort.dir === 'asc' ? 'ascending' : 'descending') : 'none'}\r\n                title=\"Sort by balance\"\r\n              >\r\n                BALANCE <span className=\"ml-1 opacity-70\">{sortIndicator('balance')}</span>\r\n              </th>\r\n              <th className=\"px-2 py-3 text-right text-[11px] font-semibold text-slate-400 uppercase tracking-[0.14em] font-sans\">PRICE (USD)</th>\r\n              <th\r\n                className=\"px-2 py-3 text-right text-[11px] font-semibold text-slate-400 uppercase tracking-[0.14em] font-sans cursor-pointer select-none\"\r\n                onClick={() => toggleSort('value')}\r\n                aria-sort={sort?.key === 'value' ? (sort.dir === 'asc' ? 'ascending' : 'descending') : 'none'}\r\n                title=\"Sort by value (USD)\"\r\n              >\r\n                VALUE (USD) <span className=\"ml-1 opacity-70\">{sortIndicator('value')}</span>\r\n              </th>\r\n            </tr>\r\n          </thead>\r\n          <tbody className=\"bg-white divide-y divide-gray-200\">\r\n            {loading && balances.length === 0 ? (\r\n              <tr>\r\n                <td colSpan={4} className=\"py-6 text-center text-gray-600\">\r\n                  <div className=\"inline-flex items-center gap-2\"><Loader2 className=\"h-5 w-5 animate-spin\" /><span>Loading…</span></div>\r\n                </td>\r\n              </tr>\r\n            ) : balances.length === 0 ? (\r\n              <tr>\r\n                <td colSpan={4} className=\"py-6 text-center text-gray-600\">No ERC20 balances found for this address.</td>\r\n              </tr>\r\n            ) : (\r\n              displayBalances.map((b, index) => {\r\n                const amount = formatTokenAmount(b.balance, b.token.decimals, b.token.name);\r\n                const lowerId = (b.token.id || '').toLowerCase();\r\n                const price = pricesById[lowerId] ?? null;\r\n                const amt = toFloatAmount(b.balance, b.token.decimals);\r\n                const valueUsd = typeof price === 'number' && Number.isFinite(price) && price > 0 ? amt * price : null;\r\n                return (\r\n                  <BalanceRow\r\n                    key={b.token.id}\r\n                    balance={b}\r\n                    index={index}\r\n                    price={price}\r\n                    valueUsd={valueUsd}\r\n                    amount={amount}\r\n                    copied={copied}\r\n                    handleCopy={handleCopy}\r\n                    iconsById={iconsById}\r\n                    TOKEN_LOGO_FALLBACKS={TOKEN_LOGO_FALLBACKS}\r\n                    TOKEN_LOGO_OVERRIDES={TOKEN_LOGO_OVERRIDES}\r\n                    isLocalAsset={isLocalAsset}\r\n                    usdFmt={usdFmt}\r\n                  />\r\n                );\r\n              })\r\n            )}\r\n          </tbody>\r\n        </table>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\BarSparkline.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\CollectionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\HomeLanding.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\Navigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\NetworkStatistics.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\NftGallery.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\NftImage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\NftMediaViewer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\PnLDualMiniChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1425,1428],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1425,1428],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1680,1683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1680,1683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":125,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":128,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1710,1713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1710,1713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3796,3799],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3796,3799],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from 'react';\r\nimport {\r\n  ResponsiveContainer,\r\n  LineChart,\r\n  Line,\r\n  XAxis,\r\n  YAxis,\r\n  Tooltip as RechartsTooltip,\r\n  CartesianGrid,\r\n} from 'recharts';\r\n\r\ninterface PnLDualMiniChartProps {\r\n  label?: string;\r\n  aLabel: string;\r\n  aThenUsd: number | null | undefined;\r\n  aNowUsd: number | null | undefined;\r\n  bLabel: string;\r\n  bThenUsd: number | null | undefined;\r\n  bNowUsd: number | null | undefined;\r\n  aQtyText?: string; // e.g., \"6.17K Mr.Dapps\"\r\n  bQtyText?: string; // e.g., \"118.28K Reef\"\r\n  aMidThen?: number | null;\r\n  bMidThen?: number | null;\r\n}\r\n\r\nfunction fmtPct(p: number | null): string {\r\n  if (p == null || !Number.isFinite(Number(p))) return '—';\r\n  const v = Number(p);\r\n  return `${v >= 0 ? '+' : ''}${v.toFixed(2)}%`;\r\n}\r\n\r\nexport function PnLDualMiniChart({ label, aLabel, aThenUsd, aNowUsd, bLabel, bThenUsd, bNowUsd, aQtyText, bQtyText, aMidThen = null, bMidThen = null }: PnLDualMiniChartProps) {\r\n  const aValid = typeof aThenUsd === 'number' && isFinite(Number(aThenUsd)) && typeof aNowUsd === 'number' && isFinite(Number(aNowUsd));\r\n  const bValid = typeof bThenUsd === 'number' && isFinite(Number(bThenUsd)) && typeof bNowUsd === 'number' && isFinite(Number(bNowUsd));\r\n  const hasAny = aValid || bValid;\r\n  const data = useMemo(() => {\r\n    if (!hasAny) return [] as Array<{ x: number; a?: number; b?: number; aMid?: number; bMid?: number }>;\r\n    const clamp = (v: any) => {\r\n      if (!(typeof v === 'number' && isFinite(v))) return undefined;\r\n      const n = Number(v);\r\n      return Math.max(0, n);\r\n    };\r\n    return [\r\n      { x: 0, a: clamp(Number(aThenUsd)), b: clamp(Number(bThenUsd)), aMid: clamp(aMidThen as any), bMid: clamp(bMidThen as any) },\r\n      { x: 1, a: clamp(Number(aNowUsd)),  b: clamp(Number(bNowUsd))  },\r\n    ];\r\n  }, [hasAny, aThenUsd, aNowUsd, bThenUsd, bNowUsd, aMidThen, bMidThen]);\r\n  if (!hasAny || data.length === 0) return null;\r\n\r\n  const aQtyShort = (aQtyText || '').trim().split(/\\s+/)[0] || '';\r\n  const bQtyShort = (bQtyText || '').trim().split(/\\s+/)[0] || '';\r\n  const aName = aQtyShort ? `${aLabel} • ${aQtyShort}` : aLabel;\r\n  const bName = bQtyShort ? `${bLabel} • ${bQtyShort}` : bLabel;\r\n  const showLabel = !!(label && String(label).trim());\r\n  const aPct = aValid && Number(aThenUsd) !== 0\r\n    ? ((Number(aNowUsd) - Number(aThenUsd)) / Number(aThenUsd)) * 100\r\n    : null;\r\n  const bPct = bValid && Number(bThenUsd) !== 0\r\n    ? ((Number(bNowUsd) - Number(bThenUsd)) / Number(bThenUsd)) * 100\r\n    : null;\r\n  const pctClass = (p: number | null) => (p == null ? 'text-gray-600' : (p >= 0 ? 'text-green-600' : 'text-red-600'));\r\n\r\n  return (\r\n    <div className=\"mt-2 rounded border border-gray-200 p-2 bg-white\">\r\n      <div className={`flex items-center ${showLabel ? 'justify-between' : 'justify-end'} text-xs`}>\r\n        {showLabel ? <div className=\"text-gray-600 truncate\">{label}</div> : null}\r\n        <div className=\"flex items-center gap-3 text-gray-600\">\r\n          <span className=\"inline-flex items-center gap-1\"><span className=\"inline-block w-2 h-2 rounded-full bg-[#2563eb]\" />{aLabel} • {aQtyShort}</span>\r\n          <span className=\"inline-flex items-center gap-1\"><span className=\"inline-block w-2 h-2 rounded-full bg-[#f59e0b]\" />{bLabel} • {bQtyShort}</span>\r\n        </div>\r\n      </div>\r\n      <div className=\"w-full h-32\">\r\n        <ResponsiveContainer width=\"100%\" height=\"100%\">\r\n          <LineChart data={data} margin={{ top: 6, right: 8, left: 4, bottom: 0 }}>\r\n            <CartesianGrid strokeDasharray=\"3 3\" vertical={false} stroke=\"#edf2f7\" />\r\n            <XAxis dataKey=\"x\" hide domain={[0, 1]} type=\"number\" />\r\n            <YAxis hide domain={[0, 'auto']} scale={'linear'} />\r\n            <RechartsTooltip\r\n              formatter={(v) => (Number(v as any)).toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 })}\r\n              labelFormatter={(l) => (l === 0 ? 'Then' : 'Now')}\r\n              wrapperStyle={{ fontSize: 11 }}\r\n              contentStyle={{ background: 'rgba(255,255,255,0.98)', border: '1px solid #e5e7eb', borderRadius: 8, boxShadow: '0 8px 24px rgba(0,0,0,0.08)' }}\r\n              labelStyle={{ color: '#6b7280', fontSize: 11 }}\r\n              itemStyle={{ color: '#111827', fontSize: 12 }}\r\n            />\r\n            <Line type=\"monotone\" dataKey=\"a\" name={aName} stroke=\"#2563eb\" strokeWidth={2} strokeLinecap=\"round\" strokeLinejoin=\"round\" dot={{ r: 2, strokeWidth: 2, fill: '#ffffff' }} activeDot={{ r: 4 }} isAnimationActive={false} />\r\n            <Line type=\"monotone\" dataKey=\"b\" name={bName} stroke=\"#f59e0b\" strokeWidth={2} strokeLinecap=\"round\" strokeLinejoin=\"round\" dot={{ r: 2, strokeWidth: 2, fill: '#ffffff' }} activeDot={{ r: 4 }} isAnimationActive={false} />\r\n            {/* spot-at-trade dots */}\r\n            <Line type=\"linear\" dataKey=\"aMid\" stroke=\"transparent\" dot={{ r: 3, fill: '#2563eb', stroke: '#2563eb' }} activeDot={false} isAnimationActive={false} />\r\n            <Line type=\"linear\" dataKey=\"bMid\" stroke=\"transparent\" dot={{ r: 3, fill: '#f59e0b', stroke: '#f59e0b' }} activeDot={false} isAnimationActive={false} />\r\n          </LineChart>\r\n        </ResponsiveContainer>\r\n      </div>\r\n      <div className=\"mt-1 grid grid-cols-2 text-[11px]\">\r\n        <span className={`inline-flex items-center gap-1 ${pctClass(aPct)}`}><span className=\"inline-block w-2 h-2 rounded-full bg-[#2563eb]\" />{aLabel}: {fmtPct(aPct)}</span>\r\n        <span className={`inline-flex items-center gap-1 justify-end ${pctClass(bPct)}`}><span className=\"inline-block w-2 h-2 rounded-full bg-[#f59e0b]\" />{bLabel}: {fmtPct(bPct)}</span>\r\n      </div>\r\n      {/* Legend moved to header; rely on tooltip for values */}\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\PnLMiniChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\RewardsChart.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'ranges'. Either include it or remove the dependency array.","line":146,"column":6,"nodeType":"ArrayExpression","endLine":146,"endColumn":51,"suggestions":[{"desc":"Update the dependencies array to be: [dailyBase, mode, price?.usd, priceHistory, range, ranges]","fix":{"range":[5615,5660],"text":"[dailyBase, mode, price?.usd, priceHistory, range, ranges]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":167,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6446,6449],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6446,6449],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":167,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6475,6478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6475,6478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7080,7083],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7080,7083],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":390,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":390,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17554,17557],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17554,17557],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":392,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":392,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17632,17635],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17632,17635],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":393,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17738,17741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17738,17741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":393,"column":109,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":112,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17784,17787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17784,17787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":404,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":404,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18247,18250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18247,18250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":451,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":451,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20358,20361],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20358,20361],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":455,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":455,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20562,20565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20562,20565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useRef, useState } from 'react';\r\nimport { useStakingRewardsSeries } from '@/hooks/use-staking-rewards-series';\r\nimport { useReefPrice } from '@/hooks/use-reef-price';\r\nimport { useReefPriceHistory } from '@/hooks/use-reef-price-history';\r\nimport { Button } from './ui/button';\r\nimport { Info } from 'lucide-react';\r\nimport {\r\n  ResponsiveContainer,\r\n  AreaChart,\r\n  Area,\r\n  XAxis,\r\n  YAxis,\r\n  Tooltip as RechartsTooltip,\r\n  CartesianGrid,\r\n  Legend,\r\n  Brush,\r\n  ReferenceArea,\r\n  ReferenceLine,\r\n} from 'recharts';\r\n\r\ninterface RewardsChartProps {\r\n  address: string;\r\n}\r\n\r\ninterface ChartPoint {\r\n  ts: number;     // UTC midnight timestamp (ms)\r\n  date: string;   // YYYY-MM-DD\r\n  valueReef?: number;\r\n  valueUsd?: number;\r\n  valueUsdHist?: number;\r\n  zero: boolean;  // true if no staking that day\r\n}\r\n\r\nexport function RewardsChart({ address }: RewardsChartProps) {\r\n  const { price } = useReefPrice();\r\n  // Primary unit scale of Y axis; USD group supports overlays\r\n  const [unit, setUnit] = useState<'reef' | 'usd'>('reef');\r\n  const [mode, setMode] = useState<'daily' | 'cumulative'>('daily');\r\n  const ranges = [\r\n    { key: '30d', days: 30 },\r\n    { key: '90d', days: 90 },\r\n    { key: '180d', days: 180 },\r\n    { key: '365d', days: 365 },\r\n    { key: 'all', days: undefined },\r\n  ] as const;\r\n  const [range, setRange] = useState<(typeof ranges)[number]['key']>('90d');\r\n  const [showUsd, setShowUsd] = useState(true);\r\n  const [showUsdHist, setShowUsdHist] = useState(false);\r\n  const [unitInfoOpen, setUnitInfoOpen] = useState(false);\r\n  const infoBtnRef = useRef<HTMLSpanElement | null>(null);\r\n  const infoPopRef = useRef<HTMLDivElement | null>(null);\r\n  // Single base dataset: for ALL fetch 'all', otherwise fetch '365d'\r\n  const baseKey = range === 'all' ? 'all' : '365d';\r\n  const { daily: dailyBase, loading, error } = useStakingRewardsSeries(address, baseKey);\r\n\r\n  const canShowUsdCurrent = !!price?.usd;\r\n  const { history: priceHistory } = useReefPriceHistory(baseKey === 'all' ? 'max' : 365);\r\n  const canShowUsdHist = !!priceHistory && Object.keys(priceHistory).length > 0;\r\n  const reefCompact = useMemo(() => new Intl.NumberFormat('en-US', { notation: 'compact', minimumFractionDigits: 2, maximumFractionDigits: 2 }), []);\r\n  // Date formatters (UTC) for readable ticks in English locale\r\n  const fmtDayMonth = useMemo(() => new Intl.DateTimeFormat('en-US', { month: 'short', day: '2-digit', timeZone: 'UTC' }), []); // Sep 07\r\n  const fmtMonthYear = useMemo(() => new Intl.DateTimeFormat('en-US', { month: 'short', year: 'numeric', timeZone: 'UTC' }), []); // Sep 2025\r\n  const fmtFull = useMemo(() => new Intl.DateTimeFormat('en-US', { month: 'long', day: '2-digit', year: 'numeric', timeZone: 'UTC' }), []);\r\n\r\n  // Close unit info on outside click / Esc\r\n  useEffect(() => {\r\n    function onDocClick(e: MouseEvent) {\r\n      if (!unitInfoOpen) return;\r\n      const target = e.target as Node;\r\n      if (infoPopRef.current && infoPopRef.current.contains(target)) return;\r\n      if (infoBtnRef.current && infoBtnRef.current.contains(target)) return;\r\n      setUnitInfoOpen(false);\r\n    }\r\n    function onKey(e: KeyboardEvent) { if (e.key === 'Escape') setUnitInfoOpen(false); }\r\n    document.addEventListener('click', onDocClick);\r\n    document.addEventListener('keydown', onKey);\r\n    return () => {\r\n      document.removeEventListener('click', onDocClick);\r\n      document.removeEventListener('keydown', onKey);\r\n    };\r\n  }, [unitInfoOpen]);\r\n\r\n  const data: ChartPoint[] = useMemo(() => {\r\n    const srcDaily = dailyBase;\r\n    if (!srcDaily || srcDaily.length === 0) return [];\r\n\r\n    const currentUsd = price?.usd ?? 0;\r\n    const byDate = new Map<string, number>();\r\n    for (const p of srcDaily) byDate.set(p.date, p.sumReef);\r\n\r\n    const MS_DAY = 24 * 60 * 60 * 1000;\r\n    let startTs: number;\r\n    let endTs: number;\r\n    if (range === 'all') {\r\n      startTs = srcDaily[0].ts;\r\n      endTs = srcDaily[srcDaily.length - 1].ts;\r\n    } else {\r\n      const opt = ranges.find((r) => r.key === range);\r\n      const todayUtcMid = new Date(new Date().toISOString().slice(0, 10) + 'T00:00:00.000Z').getTime();\r\n      const days = opt?.days ?? 30;\r\n      endTs = todayUtcMid;\r\n      startTs = todayUtcMid - (days - 1) * MS_DAY;\r\n    }\r\n\r\n    const filled: Array<{ date: string; ts: number; sum: number }> = [];\r\n    for (let t = startTs; t <= endTs; t += MS_DAY) {\r\n      const d = new Date(t).toISOString().slice(0, 10);\r\n      const v = byDate.get(d) ?? 0;\r\n      filled.push({ date: d, ts: t, sum: v });\r\n    }\r\n\r\n    if (mode === 'daily') {\r\n      return filled.map((p) => {\r\n        const hist = priceHistory?.[p.date];\r\n        const dayUsdHist = typeof hist === 'number' ? hist : 0; // Variant A: no fallback\r\n        return {\r\n          ts: p.ts,\r\n          date: p.date,\r\n          valueReef: p.sum,\r\n          valueUsd: p.sum * currentUsd,\r\n          valueUsdHist: p.sum * dayUsdHist,\r\n          zero: p.sum === 0,\r\n        };\r\n      });\r\n    }\r\n\r\n    // mode === 'cumulative': recompute cumulative within the filled window\r\n    let accReef = 0;\r\n    let accUsd = 0;\r\n    let accUsdHist = 0;\r\n    return filled.map((p) => {\r\n      accReef += p.sum;\r\n      accUsd = accReef * currentUsd;\r\n      const hist = priceHistory?.[p.date];\r\n      const dayUsd = typeof hist === 'number' ? hist : 0; // Variant A\r\n      accUsdHist += p.sum * dayUsd;\r\n      return {\r\n        ts: p.ts,\r\n        date: p.date,\r\n        valueReef: accReef,\r\n        valueUsd: accUsd,\r\n        valueUsdHist: accUsdHist,\r\n        zero: p.sum === 0,\r\n      };\r\n    });\r\n  }, [dailyBase, mode, price, priceHistory, range]);\r\n\r\n  const yTickFormatter = (v: number) => {\r\n    if (unit === 'usd') {\r\n      const sign = v < 0 ? '-' : '';\r\n      const abs = Math.abs(v);\r\n      const num = abs.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });\r\n      return `${sign}${num}$`;\r\n    }\r\n    // For REEF use compact to keep axis readable on mobile\r\n    return reefCompact.format(v);\r\n  };\r\n\r\n  const xTickFormatter = (ts: number | string) => {\r\n    const d = typeof ts === 'number' ? new Date(ts) : new Date(`${ts}T00:00:00Z`);\r\n    if (Number.isNaN(d.getTime())) return String(ts);\r\n    // <= 90d: dd.MM, >= 180d & ALL: MMM yyyy\r\n    if (range === '30d' || range === '90d') return fmtDayMonth.format(d);\r\n    return fmtMonthYear.format(d);\r\n  };\r\n\r\n  const tooltipFormatter = (value: any, _name?: string, props?: any) => {\r\n    const v = Number(value);\r\n    const key: string = props?.dataKey ?? '';\r\n    const isUsdSeries = key === 'valueUsd' || key === 'valueUsdHist' || unit === 'usd';\r\n    if (isUsdSeries) {\r\n      const sign = v < 0 ? '-' : '';\r\n      const abs = Math.abs(v);\r\n      const num = abs.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });\r\n      return [`${sign}${num}$`, mode === 'daily' ? 'Daily Sum' : 'Cumulative'];\r\n    }\r\n    return [`${reefCompact.format(v)} REEF`, mode === 'daily' ? 'Daily Sum' : 'Cumulative'];\r\n  };\r\n\r\n  const tooltipLabelFormatter = (label: any) => {\r\n    const d = typeof label === 'number' ? new Date(label) : new Date(`${String(label)}T00:00:00Z`);\r\n    if (Number.isNaN(d.getTime())) return String(label);\r\n    return fmtFull.format(d);\r\n  };\r\n\r\n  // Shade region with no historical USD data inside current window\r\n  const missingShade = useMemo(() => {\r\n    if (!(unit === 'usd' && showUsdHist) || !priceHistory || data.length === 0) return null;\r\n    const keys = Object.keys(priceHistory);\r\n    if (keys.length === 0) return null;\r\n    keys.sort();\r\n    const firstHistDate = keys[0];\r\n    const firstHistTs = new Date(`${firstHistDate}T00:00:00.000Z`).getTime();\r\n    const x1 = data[0].ts;\r\n    const x2 = Math.min(firstHistTs - 1, data[data.length - 1].ts);\r\n    if (!(Number.isFinite(x1) && Number.isFinite(x2)) || x2 <= x1) return null;\r\n    return { x1, x2 } as const;\r\n  }, [unit, showUsdHist, priceHistory, data]);\r\n\r\n  // After data is computed, prepare Brush state (only for ALL)\r\n  const showBrush = range === 'all' && data.length > 0;\r\n  const [brush, setBrush] = useState<{ startIndex: number; endIndex: number } | null>(null);\r\n  useEffect(() => {\r\n    if (!showBrush) { setBrush(null); return; }\r\n    setBrush((prev) => {\r\n      const full = { startIndex: 0, endIndex: Math.max(0, data.length - 1) };\r\n      if (!prev) return full;\r\n      const maxEnd = Math.max(0, data.length - 1);\r\n      if (prev.endIndex > maxEnd) return full;\r\n      return prev;\r\n    });\r\n  }, [showBrush, data.length]);\r\n  const isZoomed = !!brush && (brush.startIndex > 0 || brush.endIndex < Math.max(0, data.length - 1));\r\n  const resetZoom = () => setBrush({ startIndex: 0, endIndex: Math.max(0, data.length - 1) });\r\n\r\n  // Pre-compute cumulative totals for fixed windows for all modes; later pick display set\r\n  const fixedTotalsAll = useMemo(() => {\r\n    const empty = { '30d': 0, '90d': 0, '180d': 0, '365d': 0 } as Record<'30d'|'90d'|'180d'|'365d', number>;\r\n    const base = dailyBase ?? [];\r\n    if (base.length === 0) return { reef: empty, usd: empty, usdHist: empty };\r\n    const todayMs = new Date(new Date().toISOString().slice(0, 10) + 'T00:00:00.000Z').getTime();\r\n    const currentUsd = price?.usd ?? 0;\r\n    const windows: Array<{ key: '30d' | '90d' | '180d' | '365d'; days: number }> = [\r\n      { key: '30d', days: 30 },\r\n      { key: '90d', days: 90 },\r\n      { key: '180d', days: 180 },\r\n      { key: '365d', days: 365 },\r\n    ];\r\n    const reef: Record<'30d'|'90d'|'180d'|'365d', number> = { ...empty };\r\n    const usd: Record<'30d'|'90d'|'180d'|'365d', number> = { ...empty };\r\n    const usdHist: Record<'30d'|'90d'|'180d'|'365d', number> = { ...empty };\r\n    for (const w of windows) {\r\n      const cutoffMs = todayMs - (w.days - 1) * 24 * 60 * 60 * 1000;\r\n      const cutoffStr = new Date(cutoffMs).toISOString().slice(0, 10);\r\n      const slice = base.filter((p) => p.date >= cutoffStr);\r\n      const sumReef = slice.reduce((acc, p) => acc + p.sumReef, 0);\r\n      reef[w.key] = sumReef;\r\n      usd[w.key] = sumReef * currentUsd;\r\n      usdHist[w.key] = slice.reduce((acc, p) => {\r\n        const hist = priceHistory?.[p.date];\r\n        const dayUsd = typeof hist === 'number' ? hist : 0;\r\n        return acc + p.sumReef * dayUsd;\r\n      }, 0);\r\n    }\r\n    return { reef, usd, usdHist };\r\n  }, [dailyBase, price, priceHistory]);\r\n\r\n  const fixedTotals = useMemo(() => {\r\n    if (unit === 'reef') return fixedTotalsAll.reef;\r\n    // unit === 'usd'\r\n    if (showUsd) return fixedTotalsAll.usd;\r\n    return fixedTotalsAll.usdHist;\r\n  }, [fixedTotalsAll, unit, showUsd]);\r\n\r\n  function formatTotal(v: number): string {\r\n    if (unit === 'usd') {\r\n      const sign = v < 0 ? '-' : '';\r\n      const abs = Math.abs(v);\r\n      const num = abs.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });\r\n      return `${sign}${num}$`;\r\n    }\r\n    // For REEF use compact for readability\r\n    return `${reefCompact.format(v)} REEF`;\r\n  }\r\n\r\n  return (\r\n    <div className=\"mt-4 rounded-md border border-gray-200 p-3 bg-white\">\r\n      <div className=\"mb-3 flex flex-wrap items-center gap-2\">\r\n        <div className=\"inline-flex items-center gap-2\">\r\n          <span className=\"text-sm text-gray-600\">Mode:</span>\r\n          <Button variant={mode === 'daily' ? 'default' : 'outline'} size=\"sm\" onClick={() => setMode('daily')}>Daily</Button>\r\n          <Button variant={mode === 'cumulative' ? 'default' : 'outline'} size=\"sm\" onClick={() => setMode('cumulative')}>Cumulative</Button>\r\n        </div>\r\n        <div className=\"inline-flex items-center gap-2 ml-4 relative\">\r\n          <span className=\"text-sm text-gray-600\">Unit:</span>\r\n          <Button variant={unit === 'reef' ? 'default' : 'outline'} size=\"sm\" onClick={() => setUnit('reef')}>REEF</Button>\r\n          <Button\r\n            variant={unit === 'usd' ? 'default' : 'outline'}\r\n            size=\"sm\"\r\n            onClick={() => setUnit('usd')}\r\n            disabled={!canShowUsdCurrent && !canShowUsdHist}\r\n          >\r\n            USD\r\n          </Button>\r\n          {unit === 'usd' && (\r\n            <div className=\"inline-flex items-center gap-1 ml-2\">\r\n              <span className=\"text-xs text-gray-500\">Layers:</span>\r\n              <Button\r\n                variant={showUsd ? 'default' : 'outline'}\r\n                size=\"sm\"\r\n                onClick={() => setShowUsd((prev) => { const next = !prev; if (!next && !showUsdHist) return prev; return next; })}\r\n                disabled={!canShowUsdCurrent}\r\n              >\r\n                USD\r\n              </Button>\r\n              <Button\r\n                variant={showUsdHist ? 'default' : 'outline'}\r\n                size=\"sm\"\r\n                onClick={() => setShowUsdHist((prev) => { const next = !prev; if (!next && !showUsd) return prev; return next; })}\r\n                disabled={!canShowUsdHist}\r\n              >\r\n                USD(H)\r\n              </Button>\r\n            </div>\r\n          )}\r\n          <span ref={infoBtnRef}>\r\n            <Button variant=\"outline\" size=\"sm\" onClick={() => setUnitInfoOpen((v) => !v)} className=\"inline-flex items-center\">\r\n              <Info className=\"h-4 w-4 mr-1\" /> Info\r\n            </Button>\r\n          </span>\r\n          {unitInfoOpen ? (\r\n            <div ref={infoPopRef} role=\"dialog\" aria-label=\"About USD modes\" className=\"absolute z-20 top-full left-0 mt-2 w-80 rounded-md border border-gray-200 bg-white p-3 shadow-lg\">\r\n              <div className=\"text-sm font-semibold mb-2\">What are USD and USD(H)?</div>\r\n              <div className=\"space-y-2 text-xs text-gray-700\">\r\n                <p><b>USD</b> — converts all rewards using the <i>current</i> REEF→USD rate. Quick “what is it worth now” view.</p>\r\n                <p><b>USD(H)</b> — converts each reward using the <i>rate of that day</i>. Correct for retrospectives and period-to-period comparisons.</p>\r\n                <div>\r\n                  <div className=\"font-medium mb-1\">When to use:</div>\r\n                  <ul className=\"list-disc pl-4 space-y-1\">\r\n                    <li>USD for a present-value snapshot.</li>\r\n                    <li>USD(H) for trends and historical analysis.</li>\r\n                  </ul>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          ) : null}\r\n        </div>\r\n        <div className=\"inline-flex items-center gap-2 ml-4\">\r\n          <span className=\"text-sm text-gray-600\">Range:</span>\r\n          {ranges.map((r) => (\r\n            <Button key={r.key} variant={range === r.key ? 'default' : 'outline'} size=\"sm\" onClick={() => setRange(r.key)}>\r\n              {r.key.toUpperCase()}\r\n            </Button>\r\n          ))}\r\n        </div>\r\n        {showBrush && isZoomed && (\r\n          <div className=\"ml-auto\">\r\n            <Button variant=\"outline\" size=\"sm\" onClick={resetZoom}>Reset Zoom</Button>\r\n          </div>\r\n        )}\r\n        {(!canShowUsdCurrent || !canShowUsdHist) && (\r\n          <span className=\"text-xs text-gray-500 ml-2\">\r\n            {!canShowUsdCurrent ? 'USD недоступен (нет текущей цены).' : ''}\r\n            {!canShowUsdHist ? ' USD(H) недоступен (нет истории цен).' : ''}\r\n          </span>\r\n        )}\r\n      </div>\r\n\r\n      {error && <div className=\"mb-2 rounded border border-red-200 bg-red-50 px-3 py-2 text-red-800\">{String(error.message || error)}</div>}\r\n      {loading && data.length === 0 ? (\r\n        <div className=\"py-8 text-center text-gray-600\">Loading chart…</div>\r\n      ) : data.length === 0 ? (\r\n        <div className=\"py-8 text-center text-gray-600\">No data</div>\r\n      ) : (\r\n        <div className=\"w-full h-56 sm:h-64 md:h-72\">\r\n          <ResponsiveContainer width=\"100%\" height=\"100%\">\r\n            <AreaChart data={data} margin={{ top: 10, right: 20, left: 0, bottom: 0 }}>\r\n              <defs>\r\n                <linearGradient id=\"reefGradient\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\r\n                  <stop offset=\"0%\" stopColor=\"#3b82f6\" stopOpacity={0.25} />\r\n                  <stop offset=\"100%\" stopColor=\"#3b82f6\" stopOpacity={0.05} />\r\n                </linearGradient>\r\n                <linearGradient id=\"usdCurGradient\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\r\n                  <stop offset=\"0%\" stopColor=\"#2563eb\" stopOpacity={0.25} />\r\n                  <stop offset=\"100%\" stopColor=\"#2563eb\" stopOpacity={0.05} />\r\n                </linearGradient>\r\n                <linearGradient id=\"usdHistGradient\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\r\n                  <stop offset=\"0%\" stopColor=\"#10b981\" stopOpacity={0.25} />\r\n                  <stop offset=\"100%\" stopColor=\"#10b981\" stopOpacity={0.05} />\r\n                </linearGradient>\r\n              </defs>\r\n              <CartesianGrid strokeDasharray=\"3 3\" />\r\n              {missingShade ? (\r\n                <ReferenceArea x1={missingShade.x1} x2={missingShade.x2} fill=\"#9ca3af\" fillOpacity={0.2} strokeOpacity={0} />\r\n              ) : null}\r\n              {missingShade ? (\r\n                <ReferenceLine\r\n                  x={(missingShade.x1 + missingShade.x2) / 2}\r\n                  strokeOpacity={0}\r\n                  label={{ value: 'No historical price', position: 'insideTop', fill: '#6b7280', fontSize: 12 }}\r\n                />\r\n              ) : null}\r\n              <XAxis\r\n                dataKey=\"ts\"\r\n                type=\"number\"\r\n                domain={[\"dataMin\", \"dataMax\"]}\r\n                tick={{ fontSize: 12 }}\r\n                minTickGap={12}\r\n                interval=\"preserveStartEnd\"\r\n                tickFormatter={xTickFormatter as any}\r\n              />\r\n              <YAxis tickFormatter={yTickFormatter as any} width={80} tick={{ fontSize: 12 }} />\r\n              <RechartsTooltip formatter={tooltipFormatter as any} labelFormatter={tooltipLabelFormatter as any} labelClassName=\"text-xs\" />\r\n              <Legend />\r\n              {unit === 'reef' ? (\r\n                <Area\r\n                  type=\"monotone\"\r\n                  dataKey=\"valueReef\"\r\n                  name={mode === 'daily' ? 'Daily REEF' : 'Cumulative REEF'}\r\n                  stroke=\"#2563eb\"\r\n                  fill=\"url(#reefGradient)\"\r\n                  strokeWidth={2}\r\n                  isAnimationActive={false}\r\n                  dot={(props: any) => {\r\n                    const keyBase = props?.payload?.date ?? props?.index ?? 'x';\r\n                    if (mode !== 'daily') return <g key={`dot-${keyBase}`} />;\r\n                    const payload = props?.payload as ChartPoint | undefined;\r\n                    if (!payload || !payload.zero) return <g key={`dot-${keyBase}`} />;\r\n                    const { cx, cy } = props;\r\n                    if (typeof cx !== 'number' || typeof cy !== 'number') return <g key={`dot-${keyBase}`} />;\r\n                    return (\r\n                      <circle key={`dot-${keyBase}`} cx={cx} cy={cy} r={4} fill=\"#f59e0b\" stroke=\"#ffffff\" strokeWidth={1} />\r\n                    );\r\n                  }}\r\n                />\r\n              ) : (\r\n                <>\r\n                  {showUsd ? (\r\n                    <Area\r\n                      type=\"monotone\"\r\n                      dataKey=\"valueUsd\"\r\n                      name={mode === 'daily' ? 'Daily USD (Current)' : 'Cumulative USD (Current)'}\r\n                      stroke=\"#2563eb\"\r\n                      fill=\"url(#usdCurGradient)\"\r\n                      strokeWidth={2}\r\n                      isAnimationActive={false}\r\n                    />\r\n                  ) : null}\r\n                  {showUsdHist ? (\r\n                    <Area\r\n                      type=\"monotone\"\r\n                      dataKey=\"valueUsdHist\"\r\n                      name={mode === 'daily' ? 'Daily USD (History)' : 'Cumulative USD (History)'}\r\n                      stroke=\"#10b981\"\r\n                      fill=\"url(#usdHistGradient)\"\r\n                      strokeWidth={2}\r\n                      isAnimationActive={false}\r\n                    />\r\n                  ) : null}\r\n                </>\r\n              )}\r\n              {showBrush && (\r\n                <Brush\r\n                  dataKey=\"ts\"\r\n                  height={32}\r\n                  travellerWidth={12}\r\n                  stroke=\"#94a3b8\"\r\n                  fill=\"#f8fafc\"\r\n                  startIndex={brush?.startIndex}\r\n                  endIndex={brush?.endIndex}\r\n                  onChange={(e: any) => {\r\n                    if (!e) return;\r\n                    setBrush({ startIndex: e.startIndex, endIndex: e.endIndex });\r\n                  }}\r\n                  tickFormatter={xTickFormatter as any}\r\n                >\r\n                  <AreaChart data={data}>\r\n                    <Area\r\n                      type=\"monotone\"\r\n                      dataKey={unit === 'reef' ? 'valueReef' : (showUsd ? 'valueUsd' : 'valueUsdHist')}\r\n                      stroke=\"#94a3b8\"\r\n                      fill=\"#e5e7eb\"\r\n                      strokeWidth={1}\r\n                    />\r\n                  </AreaChart>\r\n                </Brush>\r\n              )}\r\n            </AreaChart>\r\n          </ResponsiveContainer>\r\n        </div>\r\n      )}\r\n\r\n      \r\n      {/* Fixed cumulative totals below chart */}\r\n      <div className=\"mt-3 grid grid-cols-2 sm:grid-cols-4 gap-2\">\r\n        <div className=\"rounded border border-gray-200 p-2 text-center\">\r\n          <div className=\"text-xs text-gray-500\">30D Cumulative</div>\r\n          <div className=\"text-sm font-semibold\">{formatTotal(fixedTotals['30d'])}</div>\r\n        </div>\r\n        <div className=\"rounded border border-gray-200 p-2 text-center\">\r\n          <div className=\"text-xs text-gray-500\">90D Cumulative</div>\r\n          <div className=\"text-sm font-semibold\">{formatTotal(fixedTotals['90d'])}</div>\r\n        </div>\r\n        <div className=\"rounded border border-gray-200 p-2 text-center\">\r\n          <div className=\"text-xs text-gray-500\">180D Cumulative</div>\r\n          <div className=\"text-sm font-semibold\">{formatTotal(fixedTotals['180d'])}</div>\r\n        </div>\r\n        <div className=\"rounded border border-gray-200 p-2 text-center\">\r\n          <div className=\"text-xs text-gray-500\">365D Cumulative</div>\r\n          <div className=\"text-sm font-semibold\">{formatTotal(fixedTotals['365d'])}</div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\RewardsTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\SearchPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\SquidHealthIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\TpsSparkline.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useEffect has missing dependencies: 'H', 'W', 'XPAD', 'displaySeries', 'emaAlpha', and 'yPadPx'. Either include them or remove the dependency array.","line":281,"column":6,"nodeType":"ArrayExpression","endLine":281,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [H, W, XPAD, displaySeries, emaAlpha, pathAnimMs, yPadPx]","fix":{"range":[11295,11307],"text":"[H, W, XPAD, displaySeries, emaAlpha, pathAnimMs, yPadPx]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\n\ninterface TpsSparklineProps {\n  series: number[];\n  trendWin?: number;       // points (seconds)\n  trendRes?: number;       // upsample factor 1..8\n  trendZoom?: number;      // y-domain zoom, >=1\n  height?: number;         // viewBox H\n  width?: number;          // viewBox W\n  xpad?: number;           // horizontal padding\n  emaAlpha?: number;       // EMA for y-domain\n  fixedXFrac?: number;     // marker X in [0..1]\n  animDurMs?: number;      // marker animation duration\n  ease?: 'linear' | 'cubic';\n  yPadPx?: number;         // vertical padding in pixels for top/bottom\n  pathAnimMs?: number;     // path morph duration\n}\n\nfunction rollingAverage(data: number[], window: number): number[] {\n  if (window <= 1) return data.slice();\n  const out: number[] = [];\n  let sum = 0;\n  for (let i = 0; i < data.length; i++) {\n    sum += data[i];\n    if (i >= window) sum -= data[i - window];\n    const count = Math.min(i + 1, window);\n    out.push(sum / count);\n  }\n  return out;\n}\n\nfunction upsampleLinear(data: number[], factor: number): number[] {\n  const f = Math.max(1, Math.floor(factor || 1));\n  const n = data.length;\n  if (n <= 1 || f === 1) return data.slice();\n  const out: number[] = [];\n  for (let i = 0; i < n - 1; i++) {\n    const a = data[i];\n    const b = data[i + 1];\n    out.push(a);\n    for (let k = 1; k < f; k++) {\n      const t = k / f;\n      out.push(a + (b - a) * t);\n    }\n  }\n  out.push(data[n - 1]);\n  return out;\n}\n\nfunction flatPath(W: number, H: number, XPAD: number): string {\n  const y = Math.max(0, (H / 2) - 0.6);\n  return `M${XPAD} ${y} L${W - XPAD} ${y}`;\n}\n\nfunction resampleToLength(arr: number[], n: number): number[] {\n  const m = arr.length;\n  if (n <= 0) return [];\n  if (m === 0) return new Array(n).fill(0);\n  if (m === n) return arr.slice();\n  const out: number[] = [];\n  for (let i = 0; i < n; i++) {\n    const t = n === 1 ? 0 : i / (n - 1);\n    const pos = t * (m - 1);\n    const i0 = Math.floor(pos);\n    const i1 = Math.min(m - 1, i0 + 1);\n    const f = pos - i0;\n    out.push(arr[i0] * (1 - f) + arr[i1] * f);\n  }\n  return out;\n}\n\nfunction trendToCurvePath(\n  data: number[],\n  width: number,\n  height: number,\n  smoothing = 0.8,\n  xPad = 1,\n  yPadPx = 1,\n  yDomain?: { min: number; max: number },\n): string {\n  const n = data.length;\n  if (n === 0) return `M0 ${height / 2} L${width} ${height / 2}`;\n  let min: number; let max: number;\n  if (yDomain && Number.isFinite(yDomain.min) && Number.isFinite(yDomain.max) && yDomain.max > yDomain.min) {\n    min = yDomain.min; max = yDomain.max;\n  } else {\n    let mi = Infinity, ma = -Infinity;\n    for (let i = 0; i < n; i++) { const v = data[i]; if (v < mi) mi = v; if (v > ma) ma = v; }\n    min = mi; max = ma;\n  }\n  // Adjust min/max for flat zero data to center the line visibly\n  if (max <= 0 && min >= 0) {\n    // All zeros or near-zero - create artificial range to show line in middle\n    min = -1;\n    max = 2;\n  }\n  // ensure minimum span so flat data renders at reasonable height (not collapsed)\n  const rawSpan = max - min;\n  const minSpan = 3; // Always at least 3 units span for visibility\n  const span = rawSpan < minSpan ? minSpan : rawSpan;\n  const step = (width - 2 * xPad) / Math.max(n - 1, 1);\n  const pad = Math.max(0, Math.floor(yPadPx));\n  const scaleY = (v: number) => {\n    // Clamp value to domain to prevent line from falling through\n    const clampedV = Math.max(min, Math.min(max, v));\n    const t = (clampedV - min) / span;\n    const y = height - (pad + t * (height - 2 * pad));\n    // Extra clamping for safety\n    return Math.max(pad + 0.5, Math.min(height - pad - 0.5, y));\n  };\n  const pts: Array<{ x: number; y: number }> = [];\n  for (let i = 0; i < n; i++) pts.push({ x: xPad + i * step, y: scaleY(data[i]) });\n  if (pts.length === 1) return `M${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)} L${width - xPad} ${pts[0].y.toFixed(2)}`;\n  let d = `M${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)}`;\n  for (let i = 0; i < pts.length - 1; i++) {\n    const p0 = pts[i - 1] ?? pts[i];\n    const p1 = pts[i];\n    const p2 = pts[i + 1];\n    const p3 = pts[i + 2] ?? pts[i + 1];\n    const c1x = p1.x + (p2.x - p0.x) / 6 * smoothing;\n    const c1y = p1.y + (p2.y - p0.y) / 6 * smoothing;\n    const c2x = p2.x - (p3.x - p1.x) / 6 * smoothing;\n    const c2y = p2.y - (p3.y - p1.y) / 6 * smoothing;\n    d += ` C${c1x.toFixed(2)} ${c1y.toFixed(2)}, ${c2x.toFixed(2)} ${c2y.toFixed(2)}, ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;\n  }\n  return d;\n}\n\nexport const TpsSparkline = React.memo(function TpsSparkline({\n  series,\n  trendWin = 60,\n  trendRes = 8,\n  trendZoom = 2,\n  height = 20,\n  width = 40,\n  xpad = 4,\n  emaAlpha = 0.18,\n  fixedXFrac = 0.5,\n  yPadPx = 3,\n  pathAnimMs = 2400,\n}: TpsSparklineProps) {\n  const W = width, H = height, XPAD = xpad;\n  // per-instance unique IDs for gradients/masks to avoid collisions\n  const uid = React.useRef(`tps-${Math.random().toString(36).slice(2, 9)}`).current;\n  const gradStrokeId = `${uid}-stroke`;\n  const gradAreaId = `${uid}-area`;\n  const fadeRightId = `${uid}-fade`;\n  const maskRightId = `${uid}-mask`;\n  const strokeUrl = `url(#${gradStrokeId})`;\n  const areaUrl = `url(#${gradAreaId})`;\n  const fadeUrl = `url(#${fadeRightId})`;\n  const maskUrl = `url(#${maskRightId})`;\n  const smoothed = React.useMemo(() => rollingAverage(series ?? [], 12), [series]);\n  const windowed = React.useMemo(() => smoothed.slice(-trendWin), [smoothed, trendWin]);\n  const renderSeries = React.useMemo(() => {\n    const arr = upsampleLinear(windowed, trendRes);\n    if (arr.length >= 2) return arr;\n    const n = Math.max(2, trendRes * Math.max(2, trendWin));\n    return new Array(n).fill(0);\n  }, [windowed, trendRes, trendWin]);\n  // series actually displayed (frozen when not hovered)\n  const [displaySeries, setDisplaySeries] = React.useState<number[]>([]);\n  const seededRef = React.useRef(false);\n  const [isHovered, setIsHovered] = React.useState(false);\n  const hoverXFracRef = React.useRef<number>(fixedXFrac);\n  const pathAnimRef = React.useRef<number | null>(null);\n  const targetRef = React.useRef<number[]>([]);\n  const lastTsRef = React.useRef<number | null>(null);\n  // Smooth marker Y position (interpolated for fluid movement)\n  const markerYRef = React.useRef<number>(height / 2);\n  React.useEffect(() => {\n    if (!seededRef.current && renderSeries.length) {\n      setDisplaySeries(renderSeries);\n      seededRef.current = true;\n    }\n  }, [renderSeries]);\n  // Update target on new data\n  React.useEffect(() => { targetRef.current = renderSeries; }, [renderSeries]);\n  // Continuous smoothing loop while hovered\n  React.useEffect(() => {\n    function step(now: number) {\n      const prevTs = lastTsRef.current;\n      lastTsRef.current = now;\n      const dt = prevTs == null ? 16 : Math.max(0, now - prevTs);\n      const yT = yTargetRef.current;\n      if (yT) {\n        const cur = yRef.current;\n        const yTau = Math.max(2000, pathAnimMs * 2) / Math.max(emaAlpha, 0.01);\n        const aBase = 1 - Math.exp(-dt / yTau);\n        if (!cur) {\n          yRef.current = yT;\n        } else {\n          // faster contraction when domain shrinks (flat data)\n          const aRaiseMax = Math.max(aBase, 0.35);\n          const aRaiseMin = aBase * 0.5;\n          const aLowerMin = Math.max(aBase * 1.5, 0.08); // faster when lowering min\n          const aLowerMax = Math.max(aBase * 1.5, 0.08); // faster when lowering max\n          const aMin = yT.min > cur.min ? aRaiseMin : aLowerMin;\n          const aMax = yT.max > cur.max ? aRaiseMax : aLowerMax;\n          yRef.current = {\n            min: cur.min + aMin * (yT.min - cur.min),\n            max: cur.max + aMax * (yT.max - cur.max),\n          };\n        }\n      }\n      const to = targetRef.current;\n      if (to.length > 0) {\n        const outLen = to.length;\n        const base = (blendedRef.current && blendedRef.current.length) ? blendedRef.current : (displaySeries.length ? displaySeries : to);\n        const fromArr = resampleToLength(base, outLen);\n        const tgtArr = resampleToLength(to, outLen);\n        // Very smooth exponential interpolation for fluid transitions\n        const smoothFactor = 0.012; // Very low = very smooth (0.01-0.02 range)\n        const blended = new Array(outLen);\n        for (let i = 0; i < outLen; i++) {\n          const diff = tgtArr[i] - fromArr[i];\n          // Smooth exponential easing for fluid movement\n          blended[i] = fromArr[i] + diff * smoothFactor;\n        }\n        blendedRef.current = blended;\n        \n        // Update path with actual data (no artificial scrolling)\n        // Graph now reflects real tx/min changes - jumps up when rate increases!\n        // Higher smoothing (1.2) for very smooth curves\n        const d = trendToCurvePath(blended, W, H, 1.2, XPAD, yPadPx, yRef.current);\n        if (pathTopRef.current) pathTopRef.current.setAttribute('d', d);\n        if (areaRef.current) {\n          const areaD = `${d} L ${W - XPAD} ${H} L ${XPAD} ${H} Z`;\n          areaRef.current.setAttribute('d', areaD);\n        }\n        \n        // Marker in center\n        const MARKER_POS = 0.5; // 50% = center\n        const markX = XPAD + (W - 2 * XPAD) * MARKER_POS;\n        const stepX = (W - 2 * XPAD) / Math.max(outLen - 1, 1);\n        \n        // Use the same Y domain as the path to prevent marker from \"falling through\"\n        let dom = yRef.current ?? { min: 0, max: 1 };\n        // Adjust for zero data - same logic as trendToCurvePath\n        if (dom.max <= 0 && dom.min >= 0) {\n          dom = { min: -1, max: 2 };\n        }\n        const rawSpan = dom.max - dom.min;\n        const minSpan = 3;\n        const span = rawSpan < minSpan ? minSpan : rawSpan;\n        const pad = Math.max(0, Math.floor(yPadPx));\n        const scaleY = (v: number) => {\n          // Clamp value to domain before scaling\n          const clampedV = Math.max(dom.min, Math.min(dom.max, v));\n          const t = (clampedV - dom.min) / span;\n          const y = H - (pad + t * (H - 2 * pad));\n          // Extra clamping to ensure marker stays visible\n          return Math.max(pad + 1, Math.min(H - pad - 1, y));\n        };\n        \n        const pos = (markX - XPAD) / stepX;\n        const i = Math.max(0, Math.min(outLen - 1, Math.floor(pos)));\n        const j = Math.max(0, Math.min(outLen - 1, i + 1));\n        const f = Math.max(0, Math.min(1, pos - i));\n        \n        // Safely get values with fallback\n        const vi = blended[i] ?? 0;\n        const vj = blended[j] ?? vi;\n        const v = i === j ? vi : vi * (1 - f) + vj * f;\n        \n        if (markerRef.current && Number.isFinite(v)) {\n          const targetY = scaleY(v);\n          // Very smooth exponential easing for fluid marker movement\n          const markerSmooth = 0.02; // Very low = very smooth\n          markerYRef.current += (targetY - markerYRef.current) * markerSmooth;\n          \n          markerRef.current.setAttribute('cx', String(markX));\n          markerRef.current.setAttribute('cy', String(markerYRef.current));\n        }\n      }\n      pathAnimRef.current = requestAnimationFrame(step);\n    }\n    if (pathAnimRef.current) cancelAnimationFrame(pathAnimRef.current);\n    pathAnimRef.current = requestAnimationFrame(step);\n    return () => { if (pathAnimRef.current) cancelAnimationFrame(pathAnimRef.current); };\n  }, [pathAnimMs]);\n\n  // target y-domain based on incoming data to avoid per-frame domain changes\n  const yTarget = React.useMemo(() => {\n    const n = renderSeries.length;\n    if (n === 0) return undefined;\n    let mi = Infinity, ma = -Infinity;\n    for (let i = 0; i < n; i++) { const v = renderSeries[i]; if (v < mi) mi = v; if (v > ma) ma = v; }\n    // anchor floor at zero to avoid lifting the graph too high\n    mi = Math.min(0, mi);\n    let span = ma - mi;\n    // ensure minimum span so flat data still has visible height\n    const minSpan = Math.max(1, ma * 0.15, 5);\n    if (span < minSpan) {\n      const center = (mi + ma) / 2;\n      mi = center - minSpan / 2;\n      ma = center + minSpan / 2;\n      // keep floor at zero if center is positive\n      if (center >= 0) mi = Math.min(0, mi);\n      span = ma - mi;\n    }\n    const extra = span * (trendZoom - 1) / 2;\n    const pad = span * 0.1 + extra;\n    mi -= pad; ma += pad;\n    return { min: mi, max: ma };\n  }, [renderSeries, trendZoom]);\n\n  const yTargetRef = React.useRef<{ min: number; max: number } | undefined>(undefined);\n  React.useEffect(() => { yTargetRef.current = yTarget; }, [yTarget]);\n\n  const [yDomain, setYDomain] = React.useState<{ min: number; max: number } | undefined>(undefined);\n  const yRef = React.useRef<{ min: number; max: number } | undefined>(undefined);\n  React.useEffect(() => {\n    if (!yTarget) { yRef.current = undefined; setYDomain(undefined); return; }\n    if (!yRef.current) { yRef.current = yTarget; setYDomain(yTarget); }\n  }, [yTarget]);\n\n  React.useEffect(() => {\n    if (!isHovered) return;\n    setDisplaySeries(renderSeries);\n  }, [isHovered, renderSeries]);\n\n  const lastDeltaSrc = windowed;\n  const lastDelta = lastDeltaSrc.length > 1 ? lastDeltaSrc[lastDeltaSrc.length - 1] - lastDeltaSrc[lastDeltaSrc.length - 2] : 0;\n  const trendColor = lastDelta > 0 ? '#10b981' : lastDelta < 0 ? '#f59e0b' : '#7c3aed';\n  const colorStart = lastDelta > 0 ? '#34d399' : lastDelta < 0 ? '#fbbf24' : '#a78bfa';\n\n  // Keep last curve shape - only draw flat when data is truly empty\n  // Don't collapse to flat just because values are near zero (prevents flicker)\n  const drawFlat = displaySeries.length < 2;\n  const sparkPath = React.useMemo(\n    () => drawFlat ? flatPath(W, H, XPAD) : trendToCurvePath(displaySeries, W, H, 0.9, XPAD, yPadPx, yDomain),\n    [displaySeries, yDomain, drawFlat, W, H, XPAD, yPadPx]\n  );\n  const areaPath = React.useMemo(() => `${sparkPath} L ${W - XPAD} ${H} L ${XPAD} ${H} Z`, [sparkPath, W, H, XPAD]);\n\n  // marker initial position (center)\n  const [marker] = React.useState<{ x: number; y: number }>({ x: XPAD + (W - 2 * XPAD) * 0.5, y: H / 2 });\n\n  // refs for imperative updates to avoid rerender cost during RAF\n  const pathTopRef = React.useRef<SVGPathElement>(null);\n  const areaRef = React.useRef<SVGPathElement>(null);\n  const markerRef = React.useRef<SVGCircleElement>(null);\n  const blendedRef = React.useRef<number[]>([]);\n  React.useEffect(() => {\n    if (!isHovered && blendedRef.current.length) setDisplaySeries(blendedRef.current.slice());\n  }, [isHovered]);\n\n  return (\n    <svg\n      viewBox={`0 0 ${W} ${H}`}\n      className=\"w-full h-full\"\n      preserveAspectRatio=\"none\"\n      onMouseEnter={(e) => {\n        setIsHovered(true);\n        const rect = (e.currentTarget as SVGSVGElement).getBoundingClientRect();\n        const relX = (e as React.MouseEvent<SVGSVGElement>).clientX - rect.left;\n        const frac = (relX - XPAD) / Math.max(1, (W - 2 * XPAD));\n        hoverXFracRef.current = Math.max(0, Math.min(1, frac));\n      }}\n      onMouseLeave={() => { setIsHovered(false); }}\n      onMouseMove={(e) => {\n        const rect = (e.currentTarget as SVGSVGElement).getBoundingClientRect();\n        const relX = e.clientX - rect.left;\n        const frac = (relX - XPAD) / Math.max(1, (W - 2 * XPAD));\n        hoverXFracRef.current = Math.max(0, Math.min(1, frac));\n      }}\n    >\n      <defs>\n        <linearGradient id={gradStrokeId} x1=\"0\" x2=\"1\" y1=\"0\" y2=\"0\">\n          <stop offset=\"0%\" stopColor={colorStart} />\n          <stop offset=\"100%\" stopColor={trendColor} />\n        </linearGradient>\n        <linearGradient id={gradAreaId} x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">\n          <stop offset=\"0%\" stopColor={colorStart} stopOpacity={0.12} />\n          <stop offset=\"100%\" stopColor={trendColor} stopOpacity={0.01} />\n        </linearGradient>\n        <linearGradient id={fadeRightId} x1=\"0\" x2=\"1\" y1=\"0\" y2=\"0\">\n          <stop offset=\"80%\" stopColor=\"white\" stopOpacity=\"1\" />\n          <stop offset=\"100%\" stopColor=\"white\" stopOpacity=\"0\" />\n        </linearGradient>\n        <mask id={maskRightId}>\n          <rect x={0} y={0} width={W} height={H} fill={fadeUrl} />\n        </mask>\n      </defs>\n      <g stroke=\"#e5e7eb\" strokeOpacity={0.25} strokeWidth={0.5} shapeRendering=\"crispEdges\">\n        <line x1={0} y1={H * 0.25} x2={W} y2={H * 0.25} />\n        <line x1={0} y1={H * 0.5} x2={W} y2={H * 0.5} />\n        <line x1={0} y1={H * 0.75} x2={W} y2={H * 0.75} />\n      </g>\n      {/* Always show area (even when flat) to avoid flicker */}\n      <path ref={areaRef} d={areaPath} fill={areaUrl} stroke=\"none\" mask={maskUrl} />\n      <path ref={pathTopRef} d={sparkPath} fill=\"none\" stroke={strokeUrl} strokeWidth={0.5} strokeLinecap=\"round\" strokeLinejoin=\"round\" />\n      <circle ref={markerRef} cx={marker.x} cy={marker.y} r={0.8} fill={trendColor} stroke=\"#fff\" strokeWidth={0.3} />\n    </svg>\n  );\n});\n\nexport default TpsSparkline;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\TransactionDetailsModal.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3544,3547],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3544,3547],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3600,3603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3600,3603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3659,3662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3659,3662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3723,3726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3723,3726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3786,3789],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3786,3789],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3848,3851],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3848,3851],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":131,"column":83,"nodeType":"BlockStatement","messageId":"unexpected","endLine":131,"endColumn":85,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[5971,5971],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":132,"column":97,"nodeType":"BlockStatement","messageId":"unexpected","endLine":132,"endColumn":99,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6087,6087],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6237,6240],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6237,6240],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6307,6310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6307,6310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6368,6371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6368,6371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6429,6432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6429,6432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":139,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6486,6489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6486,6489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6559,6562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6559,6562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":172,"column":13,"nodeType":"BlockStatement","messageId":"unexpected","endLine":172,"endColumn":15,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[8199,8199],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":180,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8545,8548],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8545,8548],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":181,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8604,8607],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8604,8607],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":198,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":198,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[9469,9469],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'transfer'. Either include it or remove the dependency array.","line":202,"column":6,"nodeType":"ArrayExpression","endLine":202,"endColumn":135,"suggestions":[{"desc":"Update the dependencies array to be: [open, transfer.extrinsicHash, transfer.extrinsicId, apollo, transfer]","fix":{"range":[9540,9669],"text":"[open, transfer.extrinsicHash, transfer.extrinsicId, apollo, transfer]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":202,"column":61,"nodeType":"ChainExpression","endLine":202,"endColumn":91},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":202,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9608,9611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9608,9611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":202,"column":93,"nodeType":"ChainExpression","endLine":202,"endColumn":126},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":202,"column":106,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":109,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9640,9643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9640,9643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":207,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9912,9915],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9912,9915],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9968,9971],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9968,9971],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":209,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10027,10030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10027,10030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":230,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":230,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[11368,11368],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'transfer'. Either include it or remove the dependency array.","line":233,"column":6,"nodeType":"ArrayExpression","endLine":233,"endColumn":166,"suggestions":[{"desc":"Update the dependencies array to be: [open, transfer.extrinsicHash, transfer.extrinsicId, apollo, transfer]","fix":{"range":[11428,11588],"text":"[open, transfer.extrinsicHash, transfer.extrinsicId, apollo, transfer]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":233,"column":61,"nodeType":"ChainExpression","endLine":233,"endColumn":91},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11496,11499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11496,11499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":233,"column":93,"nodeType":"ChainExpression","endLine":233,"endColumn":126},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":106,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":109,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11528,11531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11528,11531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":233,"column":128,"nodeType":"ChainExpression","endLine":233,"endColumn":157},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":233,"column":141,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":144,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11563,11566],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11563,11566],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":241,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11951,11954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11951,11954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":241,"column":99,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":102,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11993,11996],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11993,11996],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12101,12104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12101,12104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":106,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":109,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12146,12149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12146,12149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12257,12260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12257,12260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":98,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":101,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12298,12301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12298,12301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":245,"column":115,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":118,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12578,12581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12578,12581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":245,"column":146,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":149,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12609,12612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12609,12612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":245,"column":184,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":187,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12647,12650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12647,12650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":245,"column":214,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":217,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12677,12680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12677,12680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":255,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13311,13314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13311,13314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":274,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":274,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14556,14559],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14556,14559],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":275,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":275,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14679,14682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14679,14682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":40,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isReefToken, toFloatAmount } from '@/utils/token-helpers';\r\nimport { useEffect, useState } from 'react';\r\nimport { useApolloClient } from '@apollo/client';\r\nimport type { ApolloClient, NormalizedCacheObject } from '@apollo/client';\r\nimport type { UiTransfer } from '@/data/transfer-mapper';\r\nimport { AddressDisplay } from './AddressDisplay';\r\nimport { ExternalLink } from './ui/external-link';\r\nimport { Badge } from './ui/badge';\r\nimport { Button } from './ui/button';\r\nimport { REEFSCAN_ORIGIN } from '@/constants/reefscan';\r\nimport { formatTimestampFull, formatTokenAmount, shortenHash } from '@/utils/formatters';\r\nimport { fetchExtrinsicIdentityOnce, fetchAnyTransferIndicesOnce } from '@/data/transfers';\r\nimport { Copy, Check, ChevronRight, ChevronDown, Info } from 'lucide-react';\r\nimport { useReefPriceHistory } from '@/hooks/use-reef-price-history';\r\nimport { useTokenUsdThenFromSwap } from '@/hooks/use-token-usd-then';\r\nimport { PnLDualMiniChart } from './PnLDualMiniChart';\r\n\r\ninterface TransactionDetailsModalProps {\r\n  open: boolean;\r\n  transfer: UiTransfer | null;\r\n  onClose: () => void;\r\n  pricesById?: Record<string, number | null>;\r\n  reefUsd?: number | null;\r\n}\r\n\r\n// Numeric helpers for USD computation and formatting\r\nfunction usdNumberFor(token: { id?: string; name?: string; decimals: number }, amount: string, pricesById?: Record<string, number | null>, reefUsd?: number | null): number | null {\r\n  const n = toFloatAmount(amount, token.decimals);\r\n  if (n <= 0) return null;\r\n  let usdPerUnit: number | undefined;\r\n  if (isReefToken(token) && typeof reefUsd === 'number') usdPerUnit = reefUsd as number;\r\n  else if (token.decimals > 0 && token.id && pricesById) usdPerUnit = pricesById[(token.id || '').toLowerCase()] ?? undefined;\r\n  if (typeof usdPerUnit !== 'number' || !Number.isFinite(usdPerUnit)) return null;\r\n  const usd = n * usdPerUnit;\r\n  return Number.isFinite(usd) ? usd : null;\r\n}\r\n\r\nfunction formatUsd(n: number | null): string | null {\r\n  if (n == null || !Number.isFinite(n)) return null;\r\n  return n.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 });\r\n}\r\n\r\nfunction fmt4(n: number | null): string {\r\n  if (n == null || !Number.isFinite(Number(n))) return '—';\r\n  return Number(n).toLocaleString('en-US', { maximumFractionDigits: 4 });\r\n}\r\n\r\n\r\nfunction buildReefscanLink(t: UiTransfer): { href: string; title: string } {\r\n  let href = `${REEFSCAN_ORIGIN}/`;\r\n  let source = 'home';\r\n\r\n  const candidate = (t.method === 'swap' && t.swapInfo?.preferredTransferId)\r\n    ? t.swapInfo.preferredTransferId!\r\n    : (t.id || '');\r\n\r\n  const mAnchored = /^0*(\\d+)-0*(\\d+)-0*(\\d+)(?:-|$)/.exec(candidate);\r\n\r\n  let eventFromCandidate: string | undefined;\r\n  {\r\n    const parts = candidate.split('-');\r\n    if (parts.length >= 3) {\r\n      const evDigits = parts[2]?.match(/\\d+/g)?.pop();\r\n      if (evDigits) eventFromCandidate = String(Number(evDigits));\r\n    }\r\n  }\r\n\r\n  if (t.extrinsicId) {\r\n    const mEx = /^0*(\\d+)-0*(\\d+)$/.exec(t.extrinsicId);\r\n    if (mEx) {\r\n      const [, block, extrinsic] = mEx;\r\n      const evCandidate = (t.eventIndex ?? eventFromCandidate);\r\n      if (evCandidate !== undefined && Number.isFinite(Number(evCandidate))) {\r\n        const event = String(Number(evCandidate));\r\n        href = `${REEFSCAN_ORIGIN}/transfer/${block}/${extrinsic}/${event}`;\r\n        source = 'extrinsicId';\r\n        const title = `${href} (${source})`;\r\n        return { href, title };\r\n      }\r\n    }\r\n  }\r\n\r\n  if (\r\n    Number.isFinite(Number((t as any).blockHeight)) &&\r\n    Number.isFinite(Number((t as any).extrinsicIndex)) &&\r\n    Number.isFinite(Number((t as any).eventIndex))\r\n  ) {\r\n    const block = String(Number((t as any).blockHeight));\r\n    const extrinsic = String(Number((t as any).extrinsicIndex));\r\n    const event = String(Number((t as any).eventIndex));\r\n    href = `${REEFSCAN_ORIGIN}/transfer/${block}/${extrinsic}/${event}`;\r\n    source = 'indices';\r\n  } else if (mAnchored) {\r\n    const [, block, extrinsic, event] = mAnchored;\r\n    href = `${REEFSCAN_ORIGIN}/transfer/${block}/${extrinsic}/${event}`;\r\n    source = 'anchored-id';\r\n  } else if (t.extrinsicHash) {\r\n    href = `${REEFSCAN_ORIGIN}/extrinsic/${t.extrinsicHash}`;\r\n    source = 'hash';\r\n  }\r\n  const title = `${href} (${source})`;\r\n  return { href, title };\r\n}\r\n\r\nexport function TransactionDetailsModal({ open, transfer, onClose, pricesById, reefUsd }: TransactionDetailsModalProps) {\r\n  useEffect(() => {\r\n    function onKey(e: KeyboardEvent) {\r\n      if (e.key === 'Escape') onClose();\r\n    }\r\n    if (open) document.addEventListener('keydown', onKey);\r\n    return () => document.removeEventListener('keydown', onKey);\r\n  }, [open, onClose]);\r\n\r\n  // Keep hooks above any conditional returns to preserve hook order\r\n  const [expandTech, setExpandTech] = useState(false);\r\n  const [copied, setCopied] = useState<{ hash?: boolean; exid?: boolean; idx?: boolean; from?: boolean; to?: boolean }>({});\r\n  const [exHashLocal, setExHashLocal] = useState<string | null>(null);\r\n  const [exIdLocal, setExIdLocal] = useState<string | null>(null);\r\n  const [blockLocal, setBlockLocal] = useState<number | null>(null);\r\n  const [extrinsicLocal, setExtrinsicLocal] = useState<number | null>(null);\r\n  const [eventLocal, setEventLocal] = useState<number | null>(null);\r\n  const apollo = useApolloClient() as ApolloClient<NormalizedCacheObject>;\r\n  const { history: reefHistory } = useReefPriceHistory('max');\r\n  const [viewMode, setViewMode] = useState<'basic' | 'advanced'>(() => {\r\n    try { return (localStorage.getItem('tx_view_mode') === 'advanced') ? 'advanced' : 'basic'; } catch { return 'basic'; }\r\n  });\r\n  const [showInverse, setShowInverse] = useState<boolean>(() => {\r\n    try { return localStorage.getItem('tx_show_inv') === '1'; } catch { return false; }\r\n  });\r\n  // Persist lightweight UI preferences\r\n  useEffect(() => { try { localStorage.setItem('tx_view_mode', viewMode); } catch {} }, [viewMode]);\r\n  useEffect(() => { try { localStorage.setItem('tx_show_inv', showInverse ? '1' : '0'); } catch {} }, [showInverse]);\r\n\r\n  // Prepare inputs for historical USD hooks (safe even when transfer is null)\r\n  const hookBlockHeight = Number((transfer as any)?.blockHeight);\r\n  const hookExtrinsicIndex = Number((transfer as any)?.extrinsicIndex);\r\n  const hookTimestamp = (transfer as any)?.timestamp ?? null;\r\n  const normalToken = (transfer as any)?.token ?? null;\r\n  const boughtToken = (transfer as any)?.swapInfo?.bought?.token ?? null;\r\n  const soldToken = (transfer as any)?.swapInfo?.sold?.token ?? null;\r\n  // Call hooks unconditionally to preserve order; they are no-ops when inputs are missing\r\n  const { usdThenPerUnit: usdThenPerUnitNormal } = useTokenUsdThenFromSwap({\r\n    tokenId: normalToken?.id,\r\n    decimals: normalToken?.decimals,\r\n    blockHeight: Number.isFinite(hookBlockHeight) ? hookBlockHeight : undefined,\r\n    extrinsicIndex: Number.isFinite(hookExtrinsicIndex) ? hookExtrinsicIndex : undefined,\r\n    timestamp: hookTimestamp,\r\n  });\r\n  // Midpoint (T+7d) per-unit USD via nearest swap at timestamp\r\n  // mid horizon lookup removed\r\n  const { usdThenPerUnit: usdThenPerUnitBought } = useTokenUsdThenFromSwap({\r\n    tokenId: boughtToken?.id,\r\n    decimals: boughtToken?.decimals,\r\n    blockHeight: Number.isFinite(hookBlockHeight) ? hookBlockHeight : undefined,\r\n    extrinsicIndex: Number.isFinite(hookExtrinsicIndex) ? hookExtrinsicIndex : undefined,\r\n    timestamp: hookTimestamp,\r\n  });\r\n  const { usdThenPerUnit: usdThenPerUnitSold } = useTokenUsdThenFromSwap({\r\n    tokenId: soldToken?.id,\r\n    decimals: soldToken?.decimals,\r\n    blockHeight: Number.isFinite(hookBlockHeight) ? hookBlockHeight : undefined,\r\n    extrinsicIndex: Number.isFinite(hookExtrinsicIndex) ? hookExtrinsicIndex : undefined,\r\n    timestamp: hookTimestamp,\r\n  });\r\n\r\n  function copyToClipboard(text: string, key: 'hash' | 'exid' | 'idx' | 'from' | 'to') {\r\n    try {\r\n      navigator.clipboard?.writeText(text).then(() => {\r\n        setCopied(prev => ({ ...prev, [key]: true }));\r\n        window.setTimeout(() => setCopied(prev => ({ ...prev, [key]: false })), 1200);\r\n      }).catch(() => {});\r\n    } catch {}\r\n  }\r\n\r\n  // On-demand resolve extrinsic identity (hash/id) if missing (typical for swap items)\r\n  useEffect(() => {\r\n    if (!open || !transfer) { setExHashLocal(null); setExIdLocal(null); return; }\r\n    const hasHash = Boolean(transfer.extrinsicHash);\r\n    const hasId = Boolean(transfer.extrinsicId);\r\n    const height = Number((transfer as any)?.blockHeight);\r\n    const index = Number((transfer as any)?.extrinsicIndex);\r\n    if (hasHash && hasId) { setExHashLocal(transfer.extrinsicHash || null); setExIdLocal(transfer.extrinsicId || null); return; }\r\n    if (!hasHash || !hasId) {\r\n      if (!hasHash && !hasId && !(Number.isFinite(height) && Number.isFinite(index))) return;\r\n      let cancelled = false;\r\n      (async () => {\r\n        try {\r\n          const res = await fetchExtrinsicIdentityOnce(apollo, {\r\n            hash: transfer.extrinsicHash || undefined,\r\n            extrinsicId: transfer.extrinsicId || undefined,\r\n            height: Number.isFinite(height) ? height : undefined,\r\n            index: Number.isFinite(index) ? index : undefined,\r\n          });\r\n          if (!cancelled && res) {\r\n            if (!hasHash && res.hash) setExHashLocal(res.hash);\r\n            if (!hasId && res.id) setExIdLocal(res.id);\r\n          }\r\n        } catch {}\r\n      })();\r\n      return () => { cancelled = true; };\r\n    }\r\n  }, [open, transfer?.extrinsicHash, transfer?.extrinsicId, (transfer as any)?.blockHeight, (transfer as any)?.extrinsicIndex, apollo]);\r\n\r\n  // On-demand resolve indices (block/extrinsic/event) if any is missing\r\n  useEffect(() => {\r\n    if (!open || !transfer) { setBlockLocal(null); setExtrinsicLocal(null); setEventLocal(null); return; }\r\n    const b = Number((transfer as any)?.blockHeight);\r\n    const ex = Number((transfer as any)?.extrinsicIndex);\r\n    const ev = Number((transfer as any)?.eventIndex);\r\n    const hasAll = Number.isFinite(b) && Number.isFinite(ex) && Number.isFinite(ev);\r\n    if (hasAll) { setBlockLocal(b); setExtrinsicLocal(ex); setEventLocal(ev); return; }\r\n    const hasHashOrId = Boolean(transfer.extrinsicHash) || Boolean(transfer.extrinsicId) || (Number.isFinite(b) && Number.isFinite(ex));\r\n    if (!hasHashOrId) return;\r\n    let cancelled = false;\r\n    (async () => {\r\n      try {\r\n        const res = await fetchAnyTransferIndicesOnce(apollo, {\r\n          hash: transfer.extrinsicHash || undefined,\r\n          extrinsicId: transfer.extrinsicId || undefined,\r\n          height: Number.isFinite(b) ? b : undefined,\r\n          index: Number.isFinite(ex) ? ex : undefined,\r\n        });\r\n        if (!cancelled && res) {\r\n          if (!Number.isFinite(b) && Number.isFinite(Number(res.blockHeight))) setBlockLocal(Number(res.blockHeight));\r\n          if (!Number.isFinite(ex) && Number.isFinite(Number(res.extrinsicIndex))) setExtrinsicLocal(Number(res.extrinsicIndex));\r\n          if (!Number.isFinite(ev) && Number.isFinite(Number(res.eventIndex))) setEventLocal(Number(res.eventIndex));\r\n          if (!transfer.extrinsicHash && res.extrinsicHash) setExHashLocal(res.extrinsicHash);\r\n          if (!transfer.extrinsicId && res.extrinsicId) setExIdLocal(res.extrinsicId);\r\n        }\r\n      } catch {}\r\n    })();\r\n    return () => { cancelled = true; };\r\n  }, [open, transfer?.extrinsicHash, transfer?.extrinsicId, (transfer as any)?.blockHeight, (transfer as any)?.extrinsicIndex, (transfer as any)?.eventIndex, apollo]);\r\n\r\n  if (!open || !transfer) return null;\r\n\r\n  const isSwap = transfer.method === 'swap' && transfer.swapInfo;\r\n  const ts = formatTimestampFull(transfer.timestamp, 'en-US');\r\n  const exHashShow = transfer.extrinsicHash || exHashLocal || '';\r\n  const exIdShow = transfer.extrinsicId || exIdLocal || '';\r\n  const blockShow = Number.isFinite(Number((transfer as any)?.blockHeight)) ? Number((transfer as any).blockHeight) : (blockLocal ?? undefined);\r\n  const extrinsicShow = Number.isFinite(Number((transfer as any)?.extrinsicIndex)) ? Number((transfer as any).extrinsicIndex) : (extrinsicLocal ?? undefined);\r\n  const eventShow = Number.isFinite(Number((transfer as any)?.eventIndex)) ? Number((transfer as any).eventIndex) : (eventLocal ?? undefined);\r\n  const patchedTransfer = (exHashShow || exIdShow || blockShow != null || extrinsicShow != null || eventShow != null)\r\n    ? { ...transfer, extrinsicHash: exHashShow || transfer.extrinsicHash, extrinsicId: (exIdShow || undefined) as any, blockHeight: blockShow as any, extrinsicIndex: extrinsicShow as any, eventIndex: eventShow as any }\r\n    : transfer;\r\n  const reefscan = buildReefscanLink(patchedTransfer);\r\n\r\n  // Compute block-time USD (via daily REEF history) and current USD for amounts\r\n  const txMs = (() => { try { const n = Date.parse(String(transfer.timestamp)); return Number.isFinite(n) ? n : NaN; } catch { return NaN; } })();\r\n  const dayKey = Number.isFinite(txMs) ? new Date(txMs).toISOString().slice(0, 10) : null;\r\n  const reefUsdBlock = dayKey && reefHistory ? (typeof reefHistory[dayKey] === 'number' ? reefHistory[dayKey]! : null) : null;\r\n\r\n  // Regular transfer (non-swap)\r\n  const nowUsdTransfer = !isSwap ? usdNumberFor(transfer.token as any, transfer.amount, pricesById, reefUsd) : null;\r\n  let blockUsdTransfer = (!isSwap && reefUsdBlock != null && isReefToken(transfer.token))\r\n    ? (() => { const q = toFloatAmount(transfer.amount, transfer.token.decimals); return (q > 0) ? (q * reefUsdBlock) : null; })()\r\n    : null;\r\n  if (!isSwap && blockUsdTransfer == null && usdThenPerUnitNormal != null) {\r\n    const q = toFloatAmount(transfer.amount, transfer.token.decimals);\r\n    blockUsdTransfer = (q > 0) ? (q * usdThenPerUnitNormal) : null;\r\n  }\r\n  const deltaTransfer = (nowUsdTransfer != null && blockUsdTransfer != null && blockUsdTransfer > 0)\r\n    ? ((nowUsdTransfer - blockUsdTransfer) / blockUsdTransfer * 100)\r\n    : null;\r\n\r\n  // Swap legs\r\n  const boughtTok = isSwap ? transfer.swapInfo!.bought.token : null;\r\n  const soldTok = isSwap ? transfer.swapInfo!.sold.token : null;\r\n  const boughtQty = isSwap ? toFloatAmount(transfer.swapInfo!.bought.amount, boughtTok!.decimals) : null;\r\n  const soldQty = isSwap ? toFloatAmount(transfer.swapInfo!.sold.amount, soldTok!.decimals) : null;\r\n  const boughtIsReef = isSwap ? isReefToken(boughtTok!) : false;\r\n  const soldIsReef = isSwap ? isReefToken(soldTok!) : false;\r\n  const nowUsdBought = isSwap ? usdNumberFor(boughtTok as any, transfer.swapInfo!.bought.amount, pricesById, reefUsd) : null;\r\n  const nowUsdSold = isSwap ? usdNumberFor(soldTok as any, transfer.swapInfo!.sold.amount, pricesById, reefUsd) : null;\r\n  let blockUsdBought: number | null = null;\r\n  let blockUsdSold: number | null = null;\r\n  if (isSwap && reefUsdBlock != null && boughtQty != null && soldQty != null) {\r\n    if (boughtIsReef && !soldIsReef) {\r\n      // Bought REEF, sold TOKEN\r\n      blockUsdBought = boughtQty * reefUsdBlock;\r\n      const reefPerSold = boughtQty / soldQty; // REEF per 1 sold TOKEN\r\n      const usdPerSold = reefUsdBlock * reefPerSold;\r\n      blockUsdSold = soldQty * usdPerSold;\r\n    } else if (!boughtIsReef && soldIsReef) {\r\n      // Bought TOKEN, sold REEF\r\n      blockUsdSold = soldQty * reefUsdBlock;\r\n      const reefPerBought = soldQty / boughtQty; // REEF per 1 bought TOKEN\r\n      const usdPerBought = reefUsdBlock * reefPerBought;\r\n      blockUsdBought = boughtQty * usdPerBought;\r\n    }\r\n  }\r\n  // Fallback via nearest swap for non-REEF legs when REEF history path not applicable\r\n  if (isSwap) {\r\n    if (blockUsdBought == null && boughtQty != null && usdThenPerUnitBought != null) {\r\n      blockUsdBought = boughtQty * usdThenPerUnitBought;\r\n    }\r\n    if (blockUsdSold == null && soldQty != null && usdThenPerUnitSold != null) {\r\n      blockUsdSold = soldQty * usdThenPerUnitSold;\r\n    }\r\n  }\r\n  // Fixed USD units for chart\r\n  const aThenVal = blockUsdBought ?? null;\r\n  const aNowVal = nowUsdBought ?? null;\r\n  const bThenVal = blockUsdSold ?? null;\r\n  const bNowVal = nowUsdSold ?? null;\r\n  const midUsdThenBought = (isSwap && boughtQty != null && usdThenPerUnitBought != null) ? (boughtQty * usdThenPerUnitBought) : null;\r\n  const midUsdThenSold = (isSwap && soldQty != null && usdThenPerUnitSold != null) ? (soldQty * usdThenPerUnitSold) : null;\r\n  const aMidThenVal = midUsdThenBought ?? null;\r\n  const bMidThenVal = midUsdThenSold ?? null;\r\n\r\n  const exeReefPerToken = (() => {\r\n    if (!isSwap || boughtQty == null || soldQty == null) return null as number | null;\r\n    if (boughtIsReef && !soldIsReef && soldQty > 0) return boughtQty / soldQty;\r\n    if (!boughtIsReef && soldIsReef && boughtQty > 0) return soldQty / boughtQty;\r\n    return null as number | null;\r\n  })();\r\n  const exeTokenName = (() => {\r\n    if (!isSwap) return '';\r\n    if (boughtIsReef && !soldIsReef) return soldTok!.name;\r\n    if (!boughtIsReef && soldIsReef) return boughtTok!.name;\r\n    return '';\r\n  })();\r\n  const nowReefPerToken = (() => {\r\n    if (!isSwap || !reefUsd || !Number.isFinite(Number(reefUsd)) || Number(reefUsd) <= 0) return null as number | null;\r\n    if (boughtIsReef && !soldIsReef) {\r\n      const id = (soldTok?.id || '').toLowerCase();\r\n      const usdPer = pricesById ? (pricesById[id] as number | undefined) : undefined;\r\n      return (typeof usdPer === 'number' && Number.isFinite(usdPer) && usdPer > 0) ? (usdPer / (reefUsd as number)) : null;\r\n    }\r\n    if (!boughtIsReef && soldIsReef) {\r\n      const id = (boughtTok?.id || '').toLowerCase();\r\n      const usdPer = pricesById ? (pricesById[id] as number | undefined) : undefined;\r\n      return (typeof usdPer === 'number' && Number.isFinite(usdPer) && usdPer > 0) ? (usdPer / (reefUsd as number)) : null;\r\n    }\r\n    return null as number | null;\r\n  })();\r\n  const spotReefPerToken = (() => {\r\n    if (!isSwap || reefUsdBlock == null) return null as number | null;\r\n    if (!boughtIsReef && usdThenPerUnitBought != null) return usdThenPerUnitBought / reefUsdBlock;\r\n    if (!soldIsReef && usdThenPerUnitSold != null) return usdThenPerUnitSold / reefUsdBlock;\r\n    return null as number | null;\r\n  })();\r\n  const impactPct = (exeReefPerToken != null && spotReefPerToken != null && spotReefPerToken > 0)\r\n    ? ((exeReefPerToken - spotReefPerToken) / spotReefPerToken * 100)\r\n    : null;\r\n  const riskChips: Array<string> = [];\r\n  if (impactPct != null && Math.abs(impactPct) > 10) riskChips.push('High price impact');\r\n  if ((boughtTok && (!Number.isFinite(Number(boughtTok.decimals)) || !boughtTok.id)) || (soldTok && (!Number.isFinite(Number(soldTok.decimals)) || !soldTok.id))) riskChips.push('Unknown token metadata');\r\n  if (aMidThenVal == null && bMidThenVal == null) riskChips.push('Illiquid route');\r\n  const riskClass = (t: string) => {\r\n    if (t === 'High price impact') return 'bg-red-100 text-red-800 border border-red-200';\r\n    if (t === 'Unknown token metadata') return 'bg-gray-100 text-gray-800 border border-gray-200';\r\n    if (t === 'Illiquid route') return 'bg-yellow-100 text-yellow-800 border border-yellow-200';\r\n    return 'bg-gray-100 text-gray-800 border border-gray-200';\r\n  };\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 z-50\">\r\n      <div className=\"absolute inset-0 bg-black/40\" onClick={onClose} />\r\n      <div className=\"absolute inset-0 flex items-center justify-center p-4\">\r\n        <div className=\"w-full max-w-3xl rounded-xl bg-white shadow-2xl border border-gray-200\">\r\n          <div className=\"flex items-center justify-between px-5 py-4 border-b bg-gray-50 rounded-t-xl\">\r\n            <div className=\"flex items-center gap-3\">\r\n              <h3 className=\"text-lg font-semibold text-gray-900\">Transaction Details</h3>\r\n              <Badge className={transfer.success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}>\r\n                {transfer.success ? 'Success' : 'Failed'}\r\n              </Badge>\r\n              {isSwap ? (\r\n                <Badge className=\"bg-indigo-100 text-indigo-800\">SWAP</Badge>\r\n              ) : (\r\n                <Badge className=\"bg-blue-100 text-blue-800\">TRANSFER</Badge>\r\n              )}\r\n            </div>\r\n            <Button variant=\"ghost\" onClick={onClose}>Close</Button>\r\n          </div>\r\n          {/* Removed duplicate SWAP summary line to avoid redundancy */}\r\n          {isSwap && riskChips.length > 0 ? (\r\n            <div className=\"px-5 pt-1 flex flex-wrap gap-2 text-[11px]\">\r\n              {riskChips.map((t, i) => (\r\n                <span key={i} className={`inline-flex items-center px-2 py-0.5 rounded-full ${riskClass(t)}`}>{t}</span>\r\n              ))}\r\n            </div>\r\n          ) : null}\r\n          {isSwap ? (\r\n            <div className=\"px-5 pt-1 text-xs text-gray-600 flex items-center gap-2\">\r\n              <span className=\"text-gray-500\">View:</span>\r\n              <button className={`px-2 py-0.5 border rounded ${viewMode === 'basic' ? 'bg-gray-100' : 'bg-white'}`} onClick={() => setViewMode('basic')}>Basic</button>\r\n              <button className={`px-2 py-0.5 border rounded ${viewMode === 'advanced' ? 'bg-gray-100' : 'bg-white'}`} onClick={() => setViewMode('advanced')}>Advanced</button>\r\n            </div>\r\n          ) : null}\r\n\r\n          <div className=\"px-5 py-4 grid grid-cols-1 md:grid-cols-2 gap-6\">\r\n            <div>\r\n              <h4 className=\"text-sm font-semibold text-gray-700 mb-2\">General</h4>\r\n              <table className=\"w-full text-[13px]\">\r\n                <tbody className=\"divide-y\">\r\n                  <tr>\r\n                    <td className=\"py-1 text-gray-500\">Timestamp</td>\r\n                    <td className=\"py-1 text-gray-900\">{ts}</td>\r\n                  </tr>\r\n                  <tr>\r\n                    <td className=\"py-1 text-gray-500\">Type</td>\r\n                    <td className=\"py-1 text-gray-900\">{transfer.type}</td>\r\n                  </tr>\r\n                </tbody>\r\n              </table>\r\n            </div>\r\n\r\n            <div>\r\n              <h4 className=\"text-sm font-semibold text-gray-700 mb-2\">Participants</h4>\r\n              <table className=\"w-full text-[13px]\">\r\n                <tbody className=\"divide-y\">\r\n                  <tr>\r\n                    <td className=\"py-1.5 text-gray-500\">From</td>\r\n                    <td className=\"py-1.5 text-gray-900\">\r\n                      <div className=\"flex items-center justify-between gap-2\">\r\n                        <AddressDisplay address={transfer.from} />\r\n                        <button\r\n                          className=\"no-row-open p-1 rounded hover:bg-gray-100\"\r\n                          title=\"Copy from address\"\r\n                          onClick={() => copyToClipboard(transfer.from, 'from')}\r\n                        >\r\n                          {copied.from ? <Check className=\"h-4 w-4 text-green-600\" /> : <Copy className=\"h-4 w-4 text-gray-600\" />}\r\n                        </button>\r\n                      </div>\r\n                    </td>\r\n                  </tr>\r\n                  <tr>\r\n                    <td className=\"py-1.5 text-gray-500\">To</td>\r\n                    <td className=\"py-1.5 text-gray-900\">\r\n                      <div className=\"flex items-center justify-between gap-2\">\r\n                        <AddressDisplay address={transfer.to} />\r\n                        <button\r\n                          className=\"no-row-open p-1 rounded hover:bg-gray-100\"\r\n                          title=\"Copy to address\"\r\n                          onClick={() => copyToClipboard(transfer.to, 'to')}\r\n                        >\r\n                          {copied.to ? <Check className=\"h-4 w-4 text-green-600\" /> : <Copy className=\"h-4 w-4 text-gray-600\" />}\r\n                        </button>\r\n                      </div>\r\n                    </td>\r\n                  </tr>\r\n                </tbody>\r\n              </table>\r\n            </div>\r\n            \r\n            <div>\r\n              <h4 className=\"text-sm font-semibold text-gray-700 mb-2\">Amounts</h4>\r\n              <table className=\"w-full text-[13px]\">\r\n                <tbody className=\"divide-y\">\r\n                  {isSwap ? (\r\n                    <>\r\n                      <tr>\r\n                        <td className=\"py-1.5 text-gray-500\">PnL</td>\r\n                        <td className=\"py-1.5 text-gray-900\">\r\n                          {/* Execution/Spot/Impact/Now only in Advanced */}\r\n                          {viewMode === 'advanced' && (\r\n                            <div className=\"no-row-open mb-2 text-[11px] text-gray-700 space-y-0.5\">\r\n                              {exeTokenName && exeReefPerToken != null ? (\r\n                                <>\r\n                                  <div className=\"flex items-center justify-end mb-1 gap-2\">\r\n                                    <label className=\"inline-flex items-center gap-1 text-[10px] text-gray-500\" title=\"Show inverse rate (REEF per token and token per REEF)\">\r\n                                      <input type=\"checkbox\" checked={showInverse} onChange={(e) => setShowInverse(e.target.checked)} />\r\n                                      <span>Inverse rate</span>\r\n                                    </label>\r\n                                    <span className=\"inline-flex\" title=\"Execution — actual trade rate; Now — current market rate (from USD prices); Spot — reference rate at trade time; Δ — execution vs spot difference\">\r\n                                      <Info className=\"h-3.5 w-3.5 text-gray-400\" />\r\n                                    </span>\r\n                                  </div>\r\n                                  <div className=\"font-mono\" title={`Execution: 1 ${exeTokenName} = ${fmt4(exeReefPerToken)} REEF${nowReefPerToken != null ? ` • Now: 1 ${exeTokenName} = ${fmt4(nowReefPerToken)} REEF` : ''}${spotReefPerToken != null ? ` • Spot: ${fmt4(spotReefPerToken)} REEF per 1 ${exeTokenName}` : ''}`}>\r\n                                    <span className=\"text-gray-500\" title=\"Execution price from the actual trade volumes\">{exeTokenName}/REEF:</span>\r\n                                    <span className=\"ml-2\">{fmt4(exeReefPerToken)}</span>\r\n                                    {nowReefPerToken != null ? (\r\n                                      <>\r\n                                        <span className=\"mx-1\">→</span>\r\n                                        <span title=\"Current market rate derived from USD prices\">{fmt4(nowReefPerToken)}</span>\r\n                                      </>\r\n                                    ) : null}\r\n                                    {spotReefPerToken != null ? (\r\n                                      <span className=\"ml-2 text-gray-500\" title=\"Reference spot rate at the time of trade\">(spot {fmt4(spotReefPerToken)})</span>\r\n                                    ) : null}\r\n                                    {impactPct != null ? (\r\n                                      <>\r\n                                        <span className=\"ml-2 text-gray-500\" title=\"Difference between execution and spot\">Δ</span>\r\n                                        <span className={`ml-1 ${impactPct >= 0 ? 'text-green-600' : 'text-red-600'}`}>{impactPct >= 0 ? '+' : ''}{impactPct.toFixed(2)}%</span>\r\n                                      </>\r\n                                    ) : null}\r\n                                  </div>\r\n                                  {showInverse && (\r\n                                    <div className=\"font-mono text-gray-500\" title={`Inverse rate • Execution: 1 REEF = ${fmt4(1 / exeReefPerToken)} ${exeTokenName}${nowReefPerToken != null ? ` • Now: 1 REEF = ${fmt4(1 / nowReefPerToken)} ${exeTokenName}` : ''}`}>\r\n                                      <span title=\"Inverse rate\">REEF/{exeTokenName}:</span>\r\n                                      <span className=\"ml-2\">{fmt4(1 / exeReefPerToken)}</span>\r\n                                      {nowReefPerToken != null ? (\r\n                                        <>\r\n                                          <span className=\"mx-1\">→</span>\r\n                                          <span>{fmt4(1 / nowReefPerToken)}</span>\r\n                                        </>\r\n                                      ) : null}\r\n                                    </div>\r\n                                  )}\r\n                                </>\r\n                              ) : null}\r\n                            </div>\r\n                          )}\r\n                          <PnLDualMiniChart\r\n                            aLabel={transfer.swapInfo!.bought.token.name}\r\n                            aQtyText={formatTokenAmount(transfer.swapInfo!.bought.amount, transfer.swapInfo!.bought.token.decimals, transfer.swapInfo!.bought.token.name)}\r\n                            aThenUsd={aThenVal}\r\n                            aNowUsd={aNowVal}\r\n                            bLabel={transfer.swapInfo!.sold.token.name}\r\n                            bQtyText={formatTokenAmount(transfer.swapInfo!.sold.amount, transfer.swapInfo!.sold.token.decimals, transfer.swapInfo!.sold.token.name)}\r\n                            bThenUsd={bThenVal}\r\n                            bNowUsd={bNowVal}\r\n                            aMidThen={aMidThenVal}\r\n                            bMidThen={bMidThenVal}\r\n                            \r\n                          />\r\n                        </td>\r\n                      </tr>\r\n                    </>\r\n                  ) : (\r\n                    <tr>\r\n                      <td className=\"py-1.5 text-gray-500\">Amount</td>\r\n                      <td className=\"py-1.5 text-gray-900\">\r\n                        {formatTokenAmount(transfer.amount, transfer.token.decimals, transfer.token.name)}\r\n                        {(() => {\r\n                          const currStr = formatUsd(nowUsdTransfer);\r\n                          const blockStr = formatUsd(blockUsdTransfer);\r\n                          const dStr = (deltaTransfer != null) ? `${deltaTransfer >= 0 ? '+' : ''}${deltaTransfer.toFixed(2)}%` : null;\r\n                          return (currStr || blockStr) ? (\r\n                            <span className=\"ml-2 text-gray-600\">\r\n                              {blockStr ? `≈ ${blockStr} then` : ''}{blockStr && currStr ? ' • ' : ''}{currStr ? `${blockStr ? '' : '≈ '}${currStr} now` : ''}{dStr ? ` • Δ ${dStr}` : ''}\r\n                            </span>\r\n                          ) : null;\r\n                        })()}\r\n                      </td>\r\n                    </tr>\r\n                  )}\r\n                </tbody>\r\n              </table>\r\n            </div>\r\n\r\n            <div>\r\n              <h4 className=\"text-sm font-semibold text-gray-700 mb-2\">Network</h4>\r\n              <table className=\"w-full text-sm\">\r\n                <tbody className=\"divide-y\">\r\n                  <tr>\r\n                    <td className=\"py-2 text-gray-500\">Block • Extrinsic • Event</td>\r\n                    <td className=\"py-2 text-gray-900\">\r\n                      <div className=\"flex items-center justify-between gap-2\">\r\n                        <span className=\"font-mono text-[13px]\">\r\n                          {(blockShow ?? '—')} • {(extrinsicShow ?? '—')} • {(eventShow ?? '—')}\r\n                        </span>\r\n                        <button\r\n                          className=\"no-row-open p-1 rounded hover:bg-gray-100\"\r\n                          title=\"Copy block/extrinsic/event\"\r\n                          onClick={() => {\r\n                            const b = (blockShow ?? '');\r\n                            const ex = (extrinsicShow ?? '');\r\n                            const ev = (eventShow ?? '');\r\n                            const text = `${b}-${ex}-${ev}`;\r\n                            copyToClipboard(text, 'idx');\r\n                          }}\r\n                        >\r\n                          {copied.idx ? <Check className=\"h-4 w-4 text-green-600\" /> : <Copy className=\"h-4 w-4 text-gray-600\" />}\r\n                        </button>\r\n                      </div>\r\n                    </td>\r\n                  </tr>\r\n                  <>\r\n                    <tr>\r\n                      <td className=\"py-2 text-gray-500\">Technical details</td>\r\n                      <td className=\"py-2 text-gray-900\">\r\n                        <button\r\n                          className=\"no-row-open inline-flex items-center gap-1 px-2 py-1 border rounded hover:bg-gray-50 text-sm text-gray-700\"\r\n                          onClick={() => setExpandTech(v => !v)}\r\n                          title={expandTech ? 'Hide technical details' : 'Show technical details'}\r\n                        >\r\n                          {expandTech ? <ChevronDown className=\"h-4 w-4\" /> : <ChevronRight className=\"h-4 w-4\" />}\r\n                          <span>{expandTech ? 'Hide' : 'Show'}</span>\r\n                        </button>\r\n                      </td>\r\n                    </tr>\r\n                    {expandTech && (\r\n                      <>\r\n                        <tr>\r\n                          <td className=\"py-2 text-gray-500\">Extrinsic hash</td>\r\n                          <td className=\"py-2 text-gray-900\">\r\n                            {exHashShow ? (\r\n                              <div className=\"flex items-center justify-between gap-2\">\r\n                                <span className=\"truncate font-mono text-[13px]\">\r\n                                  {shortenHash(exHashShow, 8, 8)}\r\n                                </span>\r\n                                <div className=\"flex items-center gap-1\">\r\n                                  <button\r\n                                    className=\"no-row-open p-1 rounded hover:bg-gray-100\"\r\n                                    title=\"Copy full hash\"\r\n                                    onClick={() => copyToClipboard(exHashShow!, 'hash')}\r\n                                  >\r\n                                    {copied.hash ? <Check className=\"h-4 w-4 text-green-600\" /> : <Copy className=\"h-4 w-4 text-gray-600\" />}\r\n                                  </button>\r\n                                </div>\r\n                              </div>\r\n                            ) : '—'}\r\n                          </td>\r\n                        </tr>\r\n                        <tr>\r\n                          <td className=\"py-2 text-gray-500\">Extrinsic id</td>\r\n                          <td className=\"py-2 text-gray-900\">\r\n                            {exIdShow ? (\r\n                              <div className=\"flex items-center justify-between gap-2\">\r\n                                <span className=\"truncate font-mono text-[13px]\">\r\n                                  {shortenHash(exIdShow, 6, 6)}\r\n                                </span>\r\n                                <div className=\"flex items-center gap-1\">\r\n                                  <button\r\n                                    className=\"no-row-open p-1 rounded hover:bg-gray-100\"\r\n                                    title=\"Copy extrinsic id\"\r\n                                    onClick={() => copyToClipboard(exIdShow!, 'exid')}\r\n                                  >\r\n                                    {copied.exid ? <Check className=\"h-4 w-4 text-green-600\" /> : <Copy className=\"h-4 w-4 text-gray-600\" />}\r\n                                  </button>\r\n                                </div>\r\n                              </div>\r\n                            ) : '—'}\r\n                          </td>\r\n                        </tr>\r\n                      </>\r\n                    )}\r\n                  </>\r\n                </tbody>\r\n              </table>\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"px-5 pb-5 pt-3 border-t flex items-center justify-end bg-gray-50 rounded-b-xl\">\r\n            <div className=\"flex items-center gap-3\">\r\n              <ExternalLink href={reefscan.href} title={reefscan.title} />\r\n              <Button onClick={onClose} variant=\"secondary\">Close</Button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\TransactionHistoryWithBlocks.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useEffect has missing dependencies: 'setDirection', 'setMaxAmountInput', 'setMinAmountInput', 'setTokenFilter', and 'setTxType'. Either include them or remove the dependency array.","line":362,"column":6,"nodeType":"ArrayExpression","endLine":362,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [setDirection, setMaxAmountInput, setMinAmountInput, setTokenFilter, setTxType]","fix":{"range":[15000,15002],"text":"[setDirection, setMaxAmountInput, setMinAmountInput, setTokenFilter, setTxType]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\TransactionTableWithTanStack.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":398,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":398,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18548,18551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18548,18551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":399,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18608,18611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18608,18611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  flexRender,\r\n  Table,\r\n  Row,\r\n} from '@tanstack/react-table';\r\nimport { Loader2 } from 'lucide-react';\r\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\r\nimport { useVirtualizer } from '@tanstack/react-virtual';\r\nimport { transactionColumns } from './transaction-columns';\r\nimport type { UiTransfer } from '../data/transfer-mapper';\r\nimport { TransactionDetailsModal } from './TransactionDetailsModal';\r\n\r\ninterface TransactionRowProps {\r\n  row: Row<UiTransfer>;\r\n  newTransfers: string[];\r\n  onRowClick: (e: React.MouseEvent, transfer: UiTransfer) => void;\r\n  onRowKeyDown: (e: React.KeyboardEvent, transfer: UiTransfer) => void;\r\n}\r\n\r\nconst TransactionRow = React.memo(function TransactionRow({ row, newTransfers, onRowClick, onRowKeyDown }: TransactionRowProps) {\r\n  return (\r\n    <tr\r\n      key={row.id}\r\n      data-testid=\"tx-row\"\r\n      data-transfer-id={row.original.id}\r\n      onClick={(e) => onRowClick(e, row.original)}\r\n      onKeyDown={(e) => onRowKeyDown(e, row.original)}\r\n      tabIndex={0}\r\n      aria-label=\"Open transaction details\"\r\n      className={`group transition-colors transition-transform duration-200 cursor-pointer hover:bg-gray-50 hover:-translate-y-px focus-visible:bg-blue-50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 focus-visible:ring-offset-white ${row.index % 2 === 0 ? 'bg-white' : 'bg-slate-50/30'} ${newTransfers.includes(row.original.id) ? 'row-wash' : ''}`}\r\n    >\r\n      {row.getVisibleCells().map(cell => (\r\n        <td\r\n          key={cell.id}\r\n          className={\r\n            cell.column.id === 'actions' ? 'px-1 py-5 text-center w-8' :\r\n            cell.column.id === 'timestamp' ? 'px-2 py-5 whitespace-nowrap' :\r\n            cell.column.id === 'value' ? 'px-2 py-5 text-right whitespace-nowrap' :\r\n            (cell.column.id === 'from' || cell.column.id === 'to') ? 'px-3 py-5' :\r\n            'px-4 py-5'\r\n          }\r\n        >\r\n          {cell.column.id === 'actions'\r\n            ? flexRender(cell.column.columnDef.cell, cell.getContext())\r\n            : (cell.column.id === 'from' || cell.column.id === 'to')\r\n              ? <div className=\"truncate\">{flexRender(cell.column.columnDef.cell, cell.getContext())}</div>\r\n              : flexRender(cell.column.columnDef.cell, cell.getContext())}\r\n        </td>\r\n      ))}\r\n    </tr>\r\n  );\r\n});\r\n\r\ninterface TransactionTableWithTanStackProps {\r\n  newTransfers?: string[];\r\n  table: Table<UiTransfer>;\r\n  isLoading: boolean;\r\n  isFetching?: boolean;\r\n  totalCount?: number;\r\n  loadedCount?: number;\r\n  /** Optional adapter-level deep jump to avoid TanStack clamping */\r\n  goToPage?: (pageIndex: number) => void;\r\n  /** Page-level loading progress for deep jumps */\r\n  isPageLoading?: boolean;\r\n  pageLoadProgress?: number; // 0..1\r\n  /** Exact total known vs heuristic */\r\n  hasExactTotal?: boolean;\r\n  /** When true, adapter is using offset/limit fast mode */\r\n  fastModeActive?: boolean;\r\n  /** Optional hint to show when the table has no rows (overrides spinner) */\r\n  emptyHint?: string;\r\n}\r\n\r\nexport function TransactionTableWithTanStack({ table, isLoading, isFetching, totalCount, loadedCount, newTransfers = [], goToPage, isPageLoading, pageLoadProgress, hasExactTotal = false, fastModeActive = false, emptyHint }: TransactionTableWithTanStackProps) {\r\n  const rows = table.getRowModel().rows;\r\n  const enableVirtual = rows.length > 30;\r\n  const parentRef = useRef<HTMLDivElement | null>(null);\r\n  const [detailsFor, setDetailsFor] = useState<UiTransfer | null>(null);\r\n  const [hasRequestedData, setHasRequestedData] = useState<boolean>(false);\r\n  const [showEmptyState, setShowEmptyState] = useState<boolean>(false);\r\n  useEffect(() => {\r\n    if (isLoading || isFetching || isPageLoading) setHasRequestedData(true);\r\n  }, [isLoading, isFetching, isPageLoading]);\r\n  useEffect(() => {\r\n    const hasFiniteTotal = typeof totalCount === 'number' && Number.isFinite(totalCount);\r\n    const isEmptyCandidate =\r\n      rows.length === 0 &&\r\n      !isLoading &&\r\n      !isPageLoading &&\r\n      hasRequestedData &&\r\n      (emptyHint != null || (hasExactTotal && hasFiniteTotal && totalCount === 0));\r\n\r\n    if (!isEmptyCandidate) {\r\n      setShowEmptyState(false);\r\n      return;\r\n    }\r\n\r\n    const id = window.setTimeout(() => setShowEmptyState(true), 250);\r\n    return () => window.clearTimeout(id);\r\n  }, [rows.length, isLoading, isPageLoading, hasRequestedData, emptyHint, hasExactTotal, totalCount]);\r\n  const rowVirtualizer = useVirtualizer({\r\n    count: enableVirtual ? rows.length : 0,\r\n    getScrollElement: () => parentRef.current,\r\n    estimateSize: () => 52,\r\n    overscan: 8,\r\n  });\r\n  const virtualItems = rowVirtualizer.getVirtualItems();\r\n  const totalSize = rowVirtualizer.getTotalSize();\r\n  const paddingTop = virtualItems.length > 0 ? virtualItems[0]!.start : 0;\r\n  const paddingBottom = virtualItems.length > 0\r\n    ? totalSize - (virtualItems[virtualItems.length - 1]!.start + virtualItems[virtualItems.length - 1]!.size)\r\n    : 0;\r\n\r\n  // Sorting badge label\r\n  const sortBadge = useMemo(() => {\r\n    const s = (table.getState().sorting || [])[0] as { id?: string; desc?: boolean } | undefined;\r\n    if (!s || !s.id) return null;\r\n    const label = s.id === 'amount' ? 'Amount' : s.id === 'timestamp' ? 'Timestamp' : String(s.id);\r\n    return `${label} ${s.desc ? '↓' : '↑'}`;\r\n  }, [table]);\r\n\r\n  // Quick jump helpers\r\n  const pageIndex = table.getState().pagination.pageIndex;\r\n  const pageCount = table.getPageCount();\r\n  const [jumpInput, setJumpInput] = useState<string>('');\r\n  const quickPages = useMemo(() => {\r\n    if (!pageCount || pageCount < 1) return [] as number[];\r\n    const step = 5;\r\n    const pages = new Set<number>();\r\n    // Always include page 1\r\n    pages.add(1);\r\n    // Add step-based pages\r\n    for (let p = step; p <= pageCount; p += step) pages.add(p);\r\n    // Include last page only when exact total is known\r\n    if (hasExactTotal) pages.add(pageCount);\r\n    // Sort ascending and limit to avoid overflow\r\n    return Array.from(pages).sort((a, b) => a - b).slice(0, 12);\r\n  }, [pageCount, hasExactTotal]);\r\n  // Validate and clamp jump target to [1..pageCount]\r\n  const jumpMax = Math.max(1, pageCount || 1);\r\n  const jumpNum = (() => { const n = Number(jumpInput); return Number.isFinite(n) ? Math.floor(n) : NaN; })();\r\n  const jumpValid = Number.isFinite(jumpNum) && jumpNum >= 1 && jumpNum <= jumpMax;\r\n  function handleGo() {\r\n    if (!jumpValid) return;\r\n    const clamped = Math.min(Math.max(1, jumpNum as number), jumpMax);\r\n    if (goToPage) goToPage(clamped - 1);\r\n    else table.setPageIndex(clamped - 1);\r\n  }\r\n\r\n  // Open details modal for a row; ignore clicks originating from links/buttons\r\n  function onRowClick(e: React.MouseEvent, transfer: UiTransfer) {\r\n    const target = e.target as HTMLElement;\r\n    if (target.closest('a,button,[role=\"button\"],.no-row-open')) return;\r\n    setDetailsFor(transfer);\r\n  }\r\n  function onRowKeyDown(e: React.KeyboardEvent, transfer: UiTransfer) {\r\n    if (e.key === 'Enter' || e.key === ' ') {\r\n      e.preventDefault();\r\n      setDetailsFor(transfer);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <div className=\"relative p-6 bg-white rounded-xl border border-gray-100 shadow-sm overflow-hidden\">\r\n      {sortBadge ? (\r\n        <div className=\"absolute top-2 right-3\">\r\n          <span className=\"text-[10px] font-medium px-2 py-0.5 rounded-full border border-gray-200 bg-gray-50 text-gray-700\">\r\n            Sorted by {sortBadge}\r\n          </span>\r\n        </div>\r\n      ) : null}\r\n      <div className=\"overflow-x-auto md:overflow-x-visible\">\r\n        <div ref={parentRef} className={enableVirtual ? 'max-h-[70vh] overflow-auto' : undefined}>\r\n          <table className=\"w-full table-fixed divide-y divide-gray-200\">\r\n          <thead className=\"bg-white\">\r\n            {table.getHeaderGroups().map(headerGroup => (\r\n              <tr key={headerGroup.id} className=\"border-b-2 border-slate-200\">\r\n                {headerGroup.headers.map(header => (\r\n                  <th\r\n                    key={header.id}\r\n                    className={`px-4 py-3 text-[13px] font-semibold text-slate-700 font-sans\r\n                      ${header.column.id === 'actions' ? 'w-8 text-center px-1' : ''}\r\n                      ${header.column.id === 'timestamp' ? 'w-52 md:w-60 text-left' : ''}\r\n                      ${header.column.id === 'value' ? 'w-28 md:w-32 text-right px-2' : ''}\r\n                      ${!(header.column.id === 'actions' || header.column.id === 'timestamp' || header.column.id === 'value') ? 'text-left' : ''}\r\n                    `}\r\n                  >\r\n                    {header.isPlaceholder\r\n                      ? null\r\n                      : flexRender(\r\n                          header.column.columnDef.header,\r\n                          header.getContext()\r\n                        )}\r\n                  </th>\r\n                ))}\r\n              </tr>\r\n            ))}\r\n          </thead>\r\n          <tbody className=\"bg-white divide-y divide-gray-200 fade-in\">\r\n            {(() => {\r\n              const hasFiniteTotal = typeof totalCount === 'number' && Number.isFinite(totalCount);\r\n              const isConfirmedEmpty = showEmptyState;\r\n\r\n              const shouldShowLoading =\r\n                rows.length === 0 &&\r\n                (isLoading ||\r\n                  isPageLoading ||\r\n                  (!hasRequestedData && pageIndex === 0) ||\r\n                  // Prevent empty-state flash when total is known >0 but rows haven't materialized yet\r\n                  (pageIndex === 0 && hasFiniteTotal && totalCount > 0 && !isConfirmedEmpty) ||\r\n                  // If adapter already reports some loaded items, avoid claiming empty\r\n                  (pageIndex === 0 && typeof loadedCount === 'number' && loadedCount > 0 && !isConfirmedEmpty));\r\n\r\n              if (shouldShowLoading) {\r\n                return (\r\n              <tr>\r\n                <td colSpan={transactionColumns.length} className=\"text-center py-6 text-gray-600\">\r\n                  <div className=\"inline-flex items-center gap-2 justify-center\">\r\n                    {pageIndex === 0 ? (\r\n                      <>\r\n                        <Loader2 className=\"h-5 w-5 animate-spin\" />\r\n                        <span>Loading…</span>\r\n                      </>\r\n                    ) : null}\r\n                  </div>\r\n                </td>\r\n              </tr>\r\n                );\r\n              }\r\n\r\n              if (isConfirmedEmpty) {\r\n                return (\r\n              <tr>\r\n                <td colSpan={transactionColumns.length} className=\"text-center py-6 text-gray-500\">\r\n                  {emptyHint ?? 'No transactions found for this address.'}\r\n                </td>\r\n              </tr>\r\n                );\r\n              }\r\n\r\n              if (rows.length === 0) return null;\r\n\r\n              if (enableVirtual) {\r\n                return (\r\n              <>\r\n                {paddingTop > 0 && (\r\n                  <tr>\r\n                    <td colSpan={transactionColumns.length} style={{ height: paddingTop }} />\r\n                  </tr>\r\n                )}\r\n                {virtualItems.map(vItem => {\r\n                  const row = rows[vItem.index]!;\r\n                  return (\r\n                    <TransactionRow\r\n                      key={row.id}\r\n                      row={row}\r\n                      newTransfers={newTransfers}\r\n                      onRowClick={onRowClick}\r\n                      onRowKeyDown={onRowKeyDown}\r\n                    />\r\n                  );\r\n                })}\r\n                {paddingBottom > 0 && (\r\n                  <tr>\r\n                    <td colSpan={transactionColumns.length} style={{ height: paddingBottom }} />\r\n                  </tr>\r\n                )}\r\n                {isFetching && (\r\n                  <tr>\r\n                    <td colSpan={transactionColumns.length} className=\"text-center py-4 text-gray-500\">\r\n                      Loading more...\r\n                    </td>\r\n                  </tr>\r\n                )}\r\n              </>\r\n                );\r\n              }\r\n\r\n              return (\r\n              <>\r\n                {rows.map((row) => (\r\n                  <TransactionRow\r\n                    key={row.id}\r\n                    row={row}\r\n                    newTransfers={newTransfers}\r\n                    onRowClick={onRowClick}\r\n                    onRowKeyDown={onRowKeyDown}\r\n                  />\r\n                ))}\r\n                {isFetching && (\r\n                  <tr>\r\n                    <td colSpan={transactionColumns.length} className=\"text-center py-4 text-gray-500\">\r\n                      Loading more...\r\n                    </td>\r\n                  </tr>\r\n                )}\r\n              </>\r\n              );\r\n            })()}\r\n          </tbody>\r\n          </table>\r\n        </div>\r\n      </div>\r\n      {/* Centered overlay for deep-page loading */}\r\n      {isPageLoading && pageIndex > 0 ? (\r\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\r\n          <div className=\"flex items-center gap-2 rounded-full border border-gray-200 bg-white/95 px-3 py-1 shadow\">\r\n            {fastModeActive ? (\r\n              <Loader2 className=\"h-4 w-4 animate-spin text-gray-600\" aria-label=\"loading\" />\r\n            ) : (\r\n              <span className=\"text-xs text-gray-700\" data-testid=\"page-loading-progress\">\r\n                {`Loading ${Math.round(((pageLoadProgress || 0) * 100))}%`}\r\n              </span>\r\n            )}\r\n          </div>\r\n        </div>\r\n      ) : null}\r\n\r\n      <div className=\"mt-4 flex flex-col gap-3\">\r\n        <div className=\"flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between\">\r\n          <button\r\n            onClick={() => { if (goToPage) goToPage(pageIndex - 1); else table.previousPage(); }}\r\n            disabled={!table.getCanPreviousPage() || isFetching}\r\n            className=\"inline-flex h-9 items-center justify-center gap-2 rounded-md border border-gray-200 bg-white px-4 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 focus-visible:ring-offset-white disabled:cursor-not-allowed disabled:opacity-50\"\r\n          >\r\n            <span>Previous</span>\r\n            {fastModeActive && (\r\n              <span className=\"text-[10px] font-bold px-1.5 py-0.5 rounded bg-amber-100 text-amber-800 border border-amber-200\">FAST</span>\r\n            )}\r\n          </button>\r\n\r\n          <div className=\"inline-flex items-center justify-center rounded-md border border-gray-200 bg-gray-50 px-3 py-2 text-sm text-gray-700\">\r\n            <span>\r\n              Page{' '}\r\n              <strong>\r\n                {table.getState().pagination.pageIndex + 1} of {(() => { const pc = table.getPageCount(); return (!hasExactTotal && pc > 1) ? `~${pc}` : String(pc); })()}\r\n              </strong>\r\n            </span>\r\n          </div>\r\n\r\n          <button\r\n            onClick={() => { if (goToPage) goToPage(pageIndex + 1); else table.nextPage(); }}\r\n            disabled={!table.getCanNextPage() || isFetching}\r\n            className=\"inline-flex h-9 items-center justify-center gap-2 rounded-md border border-gray-200 bg-white px-4 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 focus-visible:ring-offset-white disabled:cursor-not-allowed disabled:opacity-50\"\r\n          >\r\n            <span>Next</span>\r\n            {fastModeActive && (\r\n              <span className=\"text-[10px] font-bold px-1.5 py-0.5 rounded bg-amber-100 text-amber-800 border border-amber-200\">FAST</span>\r\n            )}\r\n          </button>\r\n        </div>\r\n\r\n        {/* Quick jump row */}\r\n        <div className=\"flex flex-col gap-3 md:flex-row md:items-center md:justify-between\">\r\n          <div className=\"flex flex-wrap items-center gap-2\">\r\n            <label className=\"text-sm text-gray-600\">Go to page</label>\r\n            <input\r\n              type=\"number\"\r\n              min={1}\r\n              max={pageCount || undefined}\r\n              value={jumpInput}\r\n              onChange={(e) => setJumpInput(e.target.value)}\r\n              onKeyDown={(e) => { if (e.key === 'Enter') handleGo(); }}\r\n              placeholder=\"e.g. 5\"\r\n              className=\"h-9 w-24 rounded-md border border-gray-200 bg-white px-3 text-sm text-gray-900 shadow-sm placeholder:text-gray-400 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 focus-visible:ring-offset-white\"\r\n              data-testid=\"goto-page-input\"\r\n            />\r\n            <button\r\n              onClick={handleGo}\r\n              disabled={isFetching || !jumpValid}\r\n              className=\"inline-flex h-9 items-center justify-center rounded-md border border-gray-200 bg-white px-3 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 focus-visible:ring-offset-white disabled:cursor-not-allowed disabled:opacity-50\"\r\n              data-testid=\"goto-page-button\"\r\n            >\r\n              Go\r\n            </button>\r\n          </div>\r\n\r\n          <div className=\"flex flex-wrap items-center gap-2\">\r\n            <span className=\"text-sm text-gray-600\">Quick:</span>\r\n            {quickPages.map((p) => (\r\n              <button\r\n                key={p}\r\n                onClick={() => { if (goToPage) goToPage(p - 1); else table.setPageIndex(p - 1); }}\r\n                disabled={isFetching || (p - 1) === pageIndex}\r\n                className={`inline-flex h-9 min-w-9 items-center justify-center rounded-md border px-3 text-sm shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-1 focus-visible:ring-offset-white disabled:cursor-not-allowed disabled:opacity-50 ${((p - 1) === pageIndex) ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700 border-gray-200 hover:bg-gray-50'}`}\r\n              >\r\n                {p}\r\n              </button>\r\n            ))}\r\n          </div>\r\n        </div>\r\n      </div>\r\n      {/* Details modal */}\r\n      <TransactionDetailsModal\r\n        open={!!detailsFor}\r\n        transfer={detailsFor}\r\n        onClose={() => setDetailsFor(null)}\r\n        pricesById={(table.options as any)?.meta?.pricesById}\r\n        reefUsd={(table.options as any)?.meta?.reefUsd}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\TransactionsFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\VirtualizedGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\WsStatusToast.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1730,1733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1730,1733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2017,2020],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2017,2020],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2266,2269],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2266,2269],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { CheckCircle2, AlertTriangle, XCircle, RefreshCw } from 'lucide-react';\r\n\r\ninterface ToastState {\r\n  text: string;\r\n  tone: 'success' | 'warning' | 'error' | 'info';\r\n  visible: boolean;\r\n}\r\n\r\nfunction toneStyles(tone: ToastState['tone']) {\r\n  if (tone === 'success') return 'bg-green-50 border-green-200 text-green-900';\r\n  if (tone === 'warning') return 'bg-yellow-50 border-yellow-200 text-yellow-900';\r\n  if (tone === 'error') return 'bg-red-50 border-red-200 text-red-900';\r\n  return 'bg-gray-50 border-gray-200 text-gray-900';\r\n}\r\n\r\nfunction toneIcon(tone: ToastState['tone']) {\r\n  if (tone === 'success') return <CheckCircle2 className=\"h-5 w-5\" />;\r\n  if (tone === 'warning') return <AlertTriangle className=\"h-5 w-5\" />;\r\n  if (tone === 'error') return <XCircle className=\"h-5 w-5\" />;\r\n  return <RefreshCw className=\"h-5 w-5\" />;\r\n}\r\n\r\nexport function WsStatusToast() {\r\n  const [state, setState] = React.useState<ToastState>({ text: '', tone: 'info', visible: false });\r\n  const hideTimer = React.useRef<number | null>(null);\r\n  const hadIssueRef = React.useRef<boolean>(false);\r\n\r\n  function show(text: string, tone: ToastState['tone'], ttlMs: number) {\r\n    if (hideTimer.current) {\r\n      window.clearTimeout(hideTimer.current);\r\n      hideTimer.current = null;\r\n    }\r\n    setState({ text, tone, visible: true });\r\n    hideTimer.current = window.setTimeout(() => setState((s) => ({ ...s, visible: false })), ttlMs);\r\n  }\r\n\r\n  React.useEffect(() => {\r\n    const onOpened = () => { /* no toast on initial open */ };\r\n    const onConnected = () => { if (hadIssueRef.current) show('WebSocket restored', 'success', 2500); };\r\n    const onClosed = (e: Event) => {\r\n      const detail: any = (e as CustomEvent).detail ?? {};\r\n      const code = detail.code != null ? ` (code ${detail.code})` : '';\r\n      hadIssueRef.current = true;\r\n      show(`WebSocket closed${code}. Reconnecting...`, 'warning', 5000);\r\n    };\r\n    const onError = (e: Event) => {\r\n      const detail: any = (e as CustomEvent).detail ?? {};\r\n      const msg = detail.message ?? 'Unknown error';\r\n      hadIssueRef.current = true;\r\n      show(`WebSocket error: ${msg}`, 'error', 6000);\r\n    };\r\n    const onRetry = (e: Event) => {\r\n      const detail: any = (e as CustomEvent).detail ?? {};\r\n      const tries = detail.tries ?? 1;\r\n      const delayMs = detail.delayMs ?? 0;\r\n      const secs = Math.max(0.1, Math.round(delayMs / 100) / 10);\r\n      hadIssueRef.current = true;\r\n      show(`Reconnecting in ${secs}s (attempt ${tries})`, 'warning', Math.min(4000, delayMs + 1000));\r\n    };\r\n\r\n    window.addEventListener('ws-opened', onOpened as EventListener);\r\n    window.addEventListener('ws-connected', onConnected as EventListener);\r\n    window.addEventListener('ws-closed', onClosed as EventListener);\r\n    window.addEventListener('ws-error', onError as EventListener);\r\n    window.addEventListener('ws-retry', onRetry as EventListener);\r\n    return () => {\r\n      window.removeEventListener('ws-opened', onOpened as EventListener);\r\n      window.removeEventListener('ws-connected', onConnected as EventListener);\r\n      window.removeEventListener('ws-closed', onClosed as EventListener);\r\n      window.removeEventListener('ws-error', onError as EventListener);\r\n      window.removeEventListener('ws-retry', onRetry as EventListener);\r\n    };\r\n  }, []);\r\n\r\n  if (!state.visible) return null;\r\n\r\n  return (\r\n    <div\r\n      className={`fixed bottom-6 right-6 z-50 max-w-sm w-[360px] p-3 rounded-lg shadow-lg border ${toneStyles(state.tone)}`}\r\n      role=\"status\"\r\n      aria-live=\"polite\"\r\n    >\r\n      <div className=\"flex items-start gap-3\">\r\n        <div>{toneIcon(state.tone)}</div>\r\n        <div className=\"text-sm leading-snug\">{state.text}</div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\media\\nft-media-viewer.tsx","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":43,"column":55,"nodeType":"BlockStatement","messageId":"unexpected","endLine":43,"endColumn":57,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1748,1748],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":44,"column":32,"nodeType":"BlockStatement","messageId":"unexpected","endLine":44,"endColumn":34,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[1783,1783],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1914,1917],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1914,1917],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1947,1950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1947,1950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":133,"column":61,"nodeType":"BlockStatement","messageId":"unexpected","endLine":133,"endColumn":63,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[5162,5162],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":134,"column":38,"nodeType":"BlockStatement","messageId":"unexpected","endLine":134,"endColumn":40,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[5203,5203],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":175,"column":37,"nodeType":"BlockStatement","messageId":"unexpected","endLine":175,"endColumn":39,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6754,6754],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":176,"column":46,"nodeType":"BlockStatement","messageId":"unexpected","endLine":176,"endColumn":48,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6803,6803],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":177,"column":42,"nodeType":"BlockStatement","messageId":"unexpected","endLine":177,"endColumn":44,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6848,6848],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6874,6877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6874,6877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":178,"column":55,"nodeType":"BlockStatement","messageId":"unexpected","endLine":178,"endColumn":57,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6906,6906],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":179,"column":45,"nodeType":"BlockStatement","messageId":"unexpected","endLine":179,"endColumn":47,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6954,6954],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":180,"column":52,"nodeType":"BlockStatement","messageId":"unexpected","endLine":180,"endColumn":54,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[7009,7009],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":181,"column":36,"nodeType":"BlockStatement","messageId":"unexpected","endLine":181,"endColumn":38,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[7048,7048],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { buildCandidates } from '../../utils/ipfs';\r\n\r\ninterface NftMediaViewerProps {\r\n  src?: string | null;\r\n  poster?: string | null;\r\n  mime?: string | null;\r\n  name?: string | null;\r\n  className?: string;\r\n}\r\n\r\nfunction getKindFromMime(mime?: string | null): 'video' | 'audio' | 'image' | null {\r\n  if (!mime) return null;\r\n  if (mime.startsWith('video/')) return 'video';\r\n  if (mime.startsWith('audio/')) return 'audio';\r\n  if (mime.startsWith('image/')) return 'image';\r\n  return null;\r\n}\r\n\r\nfunction getKindFromUrl(url?: string | null): 'video' | 'audio' | 'image' | null {\r\n  if (!url) return null;\r\n  const u = url.split('?')[0].toLowerCase();\r\n  if (/(\\.mp4|\\.webm|\\.ogg|\\.ogv|\\.mov|\\.mkv|\\.m4v)$/.test(u)) return 'video';\r\n  if (/(\\.mp3|\\.wav|\\.m4a|\\.oga|\\.ogg|\\.flac|\\.aac)$/.test(u)) return 'audio';\r\n  if (/(\\.png|\\.jpg|\\.jpeg|\\.gif|\\.webp|\\.avif|\\.bmp|\\.svg)$/.test(u)) return 'image';\r\n  return null;\r\n}\r\n\r\nexport function NftMediaViewer({ src, poster, mime, name, className }: NftMediaViewerProps) {\r\n  const kindHint = getKindFromMime(mime) ?? getKindFromUrl(src);\r\n  const [videoFailed, setVideoFailed] = React.useState(false);\r\n  const [imgIdx, setImgIdx] = React.useState(0);\r\n  const vidRef = React.useRef<HTMLVideoElement | null>(null);\r\n  const [mutedAuto, setMutedAuto] = React.useState(false);\r\n  const [ratio, setRatio] = React.useState<number | null>(null);\r\n  const [showPoster, setShowPoster] = React.useState(false);\r\n  const [snapshotUrl, setSnapshotUrl] = React.useState<string | null>(null);\r\n\r\n  function restoreAndPlay() {\r\n    const el = vidRef.current;\r\n    if (!el) return;\r\n    if (!el.getAttribute('src') && videoSrc) {\r\n      try { el.setAttribute('src', videoSrc); } catch {}\r\n      try { el.load(); } catch {}\r\n    }\r\n    setShowPoster(false);\r\n    setSnapshotUrl(null);\r\n    try {\r\n      const p = el.play();\r\n      if (p && typeof (p as any).catch === 'function') (p as any).catch(() => undefined);\r\n    } catch { /* ignore play errors */ }\r\n  }\r\n\r\n  React.useEffect(() => {\r\n    setVideoFailed(false);\r\n    setImgIdx(0);\r\n    setRatio(null);\r\n    setShowPoster(false);\r\n    setSnapshotUrl(null);\r\n  }, [src, mime]);\r\n\r\n  // IPFS candidates via shared helper\r\n\r\n  const srcCandidates = buildCandidates(src);\r\n  const posterCandidates = buildCandidates(poster);\r\n  const posterSrc = posterCandidates[0] ?? undefined;\r\n  const imgCandidates = srcCandidates.length ? srcCandidates : (src ? [src] : []);\r\n  const imgSrc = imgCandidates[imgIdx];\r\n  const [vidIdx, setVidIdx] = React.useState(0);\r\n  const [audIdx, setAudIdx] = React.useState(0);\r\n  const videoSrc = (srcCandidates[vidIdx] ?? src) ?? undefined;\r\n  const audioSrc = (srcCandidates[audIdx] ?? src) ?? undefined;\r\n\r\n  if (!src) {\r\n    return (\r\n      <div className={className ?? 'w-full h-64 bg-gray-100 rounded-md flex items-center justify-center text-gray-500'}>\r\n        No media\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Prefer video if explicit or if type unknown; fall back to image on error\r\n  if (!videoFailed && (kindHint === 'video' || kindHint == null)) {\r\n    return (\r\n      <div className={className ?? 'max-w-full max-h-[80vh] rounded-md bg-black'} style={{ aspectRatio: ratio ?? '16 / 9', minHeight: 200, position: 'relative' }}>\r\n        <button\r\n          type=\"button\"\r\n          aria-label=\"Replay\"\r\n          title=\"Replay\"\r\n          onClick={restoreAndPlay}\r\n          onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); restoreAndPlay(); } }}\r\n          className=\"absolute inset-0 z-10\"\r\n          style={{ opacity: showPoster ? 1 : 0, pointerEvents: showPoster ? 'auto' : 'none', transition: 'opacity 150ms ease', background: 'transparent' }}\r\n        >\r\n          {posterSrc || snapshotUrl ? (\r\n            <img\r\n              src={snapshotUrl ?? posterSrc}\r\n              alt={name ?? 'NFT poster'}\r\n              className=\"w-full h-full object-contain rounded-md\"\r\n              draggable={false}\r\n            />\r\n          ) : (\r\n            <div className=\"w-full h-full flex items-center justify-center\">\r\n              <div className=\"px-3 py-1 rounded-full bg-white/80 text-gray-800 text-sm shadow\">Replay</div>\r\n            </div>\r\n          )}\r\n        </button>\r\n        <video\r\n          ref={vidRef}\r\n          className={'w-full h-full rounded-md bg-black'}\r\n          data-testid=\"viewer-video\"\r\n          crossOrigin=\"anonymous\"\r\n          controls={!showPoster}\r\n          autoPlay\r\n          preload=\"metadata\"\r\n          playsInline\r\n          muted={mutedAuto}\r\n          poster={posterSrc}\r\n          aria-label={name ?? 'NFT video'}\r\n          src={videoSrc}\r\n          onLoadedMetadata={() => {\r\n            const el = vidRef.current;\r\n            if (!el) return;\r\n            const vw = el.videoWidth;\r\n            const vh = el.videoHeight;\r\n            if (vw > 0 && vh > 0) setRatio(vw / vh);\r\n          }}\r\n        onClick={restoreAndPlay}\r\n        onPlay={() => {\r\n          const el = vidRef.current;\r\n          if (!el) return;\r\n          if (!el.getAttribute('src') && videoSrc) {\r\n            try { el.setAttribute('src', videoSrc); } catch {}\r\n            try { el.load(); } catch {}\r\n            const p = el.play();\r\n            if (p && typeof p.catch === 'function') p.catch(() => undefined);\r\n          }\r\n          setShowPoster(false);\r\n          setSnapshotUrl(null);\r\n        }}\r\n        onLoadedData={() => {\r\n          const el = vidRef.current;\r\n          if (!el) return;\r\n          const p = el.play();\r\n          if (p && typeof p.catch === 'function') {\r\n            p.catch(() => {\r\n              try {\r\n                el.muted = true;\r\n                setMutedAuto(true);\r\n                el.play().catch(() => undefined);\r\n              } catch (e) { void e; }\r\n            });\r\n          }\r\n        }}\r\n        onEnded={() => {\r\n          const el = vidRef.current;\r\n          if (!el) return;\r\n          // Try to capture last frame as data URL to show as overlay\r\n          try {\r\n            const vw = el.videoWidth;\r\n            const vh = el.videoHeight;\r\n            if (vw > 0 && vh > 0) {\r\n              const canvas = document.createElement('canvas');\r\n              canvas.width = vw; canvas.height = vh;\r\n              const ctx = canvas.getContext('2d');\r\n              if (ctx) {\r\n                ctx.drawImage(el, 0, 0, vw, vh);\r\n                try {\r\n                  const url = canvas.toDataURL('image/webp', 0.85);\r\n                  if (url && url.startsWith('data:image')) setSnapshotUrl(url);\r\n                } catch { /* canvas may be tainted by CORS; ignore */ }\r\n              }\r\n            }\r\n          } catch { /* ignore snapshot errors */ }\r\n          try { el.pause(); } catch {}\r\n          try { el.autoplay = false; } catch {}\r\n          try { el.loop = false; } catch {}\r\n          try { (el as any).preload = 'none'; } catch {}\r\n          try { el.currentTime = 0; } catch {}\r\n          try { el.removeAttribute('src'); } catch {}\r\n          try { el.load(); } catch {}\r\n          setShowPoster(true);\r\n        }}\r\n        onError={() => {\r\n          setVidIdx((i) => {\r\n            const next = i + 1;\r\n            if (next < srcCandidates.length) return next;\r\n            setVideoFailed(true);\r\n            return i;\r\n          });\r\n        }}\r\n        >\r\n          Your browser does not support the video tag.\r\n        </video>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (kindHint === 'audio') {\r\n    return (\r\n      <div className={className ?? 'w-full max-w-2xl'}>\r\n        {posterSrc ? (\r\n          <img src={posterSrc} alt={name ?? 'NFT poster'} className=\"w-full max-h-[50vh] object-contain rounded-md mb-2\" />\r\n        ) : null}\r\n        <audio\r\n          className=\"w-full\"\r\n          controls\r\n          preload=\"metadata\"\r\n          aria-label={name ?? 'NFT audio'}\r\n          src={audioSrc}\r\n          onError={() => setAudIdx((i) => (i + 1 < srcCandidates.length ? i + 1 : i))}\r\n        >\r\n          Your browser does not support the audio element.\r\n        </audio>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <img\r\n      src={imgSrc}\r\n      alt={name ?? 'NFT image'}\r\n      className={className ?? 'max-w-full max-h-[80vh] object-contain rounded-md'}\r\n      loading=\"lazy\"\r\n      onError={() => setImgIdx((i) => (i + 1 < imgCandidates.length ? i + 1 : i))}\r\n    />\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\media\\nft-video-thumb.tsx","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":79,"column":33,"nodeType":"BlockStatement","messageId":"unexpected","endLine":79,"endColumn":35,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3328,3328],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":80,"column":48,"nodeType":"BlockStatement","messageId":"unexpected","endLine":80,"endColumn":50,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3379,3379],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3401,3404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3401,3404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":81,"column":51,"nodeType":"BlockStatement","messageId":"unexpected","endLine":81,"endColumn":53,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3433,3433],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":82,"column":32,"nodeType":"BlockStatement","messageId":"unexpected","endLine":82,"endColumn":34,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3468,3468],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { buildCandidates } from '../../utils/ipfs';\r\nimport { useInView } from '../../hooks/use-in-view';\r\nimport { usePreviewPlayback } from '../../hooks/use-preview-playback';\r\n\r\ninterface NftVideoThumbProps {\r\n  src: string;\r\n  poster?: string;\r\n  name?: string;\r\n  className?: string;\r\n  onClick?: () => void;\r\n  priority?: boolean;\r\n  onReady?: () => void;\r\n  suspended?: boolean;\r\n}\r\n\r\nexport function NftVideoThumb({ src, poster, name, className, onClick, priority, onReady, suspended }: NftVideoThumbProps) {\r\n  const srcCandidates = buildCandidates(src);\r\n  const posterCandidates = buildCandidates(poster);\r\n  const [idx, setIdx] = React.useState(0);\r\n  const videoSrc = srcCandidates[idx] ?? src;\r\n  const cn = `${className ?? 'w-full h-48'} bg-black${onClick ? ' cursor-pointer' : ''}`;\r\n  const vidRef = React.useRef<HTMLVideoElement | null>(null);\r\n  const { ref: containerRef, inView } = useInView<HTMLDivElement>({ rootMargin: '2200px', threshold: 0.1, once: true });\r\n  const { ref: visibleRef, inView: isVisible } = useInView<HTMLDivElement>({ rootMargin: '0px', threshold: 0.5, once: false });\r\n  const [isHovering, setIsHovering] = React.useState(false);\r\n  const lastTapRef = React.useRef<number>(0);\r\n  const { register, unregister, ensureExclusive } = usePreviewPlayback();\r\n  const seekRef = React.useRef<number>(0.25);\r\n  const [videoFailed, setVideoFailed] = React.useState(false);\r\n  const readySentRef = React.useRef(false);\r\n  const fireReady = React.useCallback(() => {\r\n    if (readySentRef.current) return;\r\n    readySentRef.current = true;\r\n    if (onReady) onReady();\r\n  }, [onReady]);\r\n  const poster0 = posterCandidates[0] ?? '';\r\n  const posterLooksVideo = /(.mp4|.webm|.mov|.m4v)(\\?|#|$)/i.test(poster0);\r\n  const hasValidPoster = !!poster0 && !posterLooksVideo;\r\n  const posterUrl = hasValidPoster ? poster0 : undefined;\r\n  const [forceLoad, setForceLoad] = React.useState(false);\r\n  const shouldLoad = !suspended && (!!priority || inView || forceLoad);\r\n  const [posterFailed, setPosterFailed] = React.useState(false);\r\n  const [showPoster, setShowPoster] = React.useState<boolean>(!!posterUrl);\r\n\r\n  const startHover = React.useCallback(() => {\r\n    if (suspended) return;\r\n    setForceLoad(true);\r\n    setIsHovering(true);\r\n    setShowPoster(false);\r\n    const el = vidRef.current;\r\n    if (!el) return;\r\n    el.muted = true;\r\n    ensureExclusive(el);\r\n    const p = el.play();\r\n    if (p && typeof p.catch === 'function') p.catch(() => undefined);\r\n  }, [ensureExclusive, suspended]);\r\n\r\n  const endHover = React.useCallback(() => {\r\n    setIsHovering(false);\r\n    setShowPoster(!!posterUrl && !posterFailed);\r\n    const el = vidRef.current;\r\n    if (!el) return;\r\n    try { el.pause(); } catch { /* ignore: pausing preview video not critical */ }\r\n    try { el.currentTime = seekRef.current; } catch { /* ignore: seeking can fail on some browsers */ }\r\n  }, [posterUrl, posterFailed]);\r\n\r\n  React.useEffect(() => {\r\n    const el = vidRef.current;\r\n    if (el) register(el);\r\n    return () => { if (el) unregister(el); };\r\n  }, [register, unregister]);\r\n\r\n  // When suspended, cancel any network and keep poster visible\r\n  React.useEffect(() => {\r\n    const el = vidRef.current;\r\n    if (!el) return;\r\n    if (suspended) {\r\n      try { el.pause(); } catch {}\r\n      try { el.removeAttribute('src'); } catch {}\r\n      try { (el as any).preload = 'none'; } catch {}\r\n      try { el.load(); } catch {}\r\n      setShowPoster(!!posterUrl && !posterFailed);\r\n      setIsHovering(false);\r\n      setForceLoad(false);\r\n    }\r\n  }, [suspended, posterUrl, posterFailed]);\r\n\r\n  // Do not autoplay based on visibility; only play on hover/tap. Always pause when not hovering.\r\n  React.useEffect(() => {\r\n    const el = vidRef.current;\r\n    if (!el) return;\r\n    if (!isHovering) {\r\n      try { el.pause(); } catch { /* ignore */ }\r\n      try { el.currentTime = seekRef.current; } catch { /* ignore */ }\r\n    }\r\n  }, [isVisible, isHovering]);\r\n\r\n  if (videoFailed) {\r\n    if (posterUrl && !posterFailed) {\r\n      return (\r\n        <div ref={(el) => { containerRef(el); visibleRef(el); }} className=\"relative\">\r\n          <img\r\n            src={posterUrl}\r\n            alt={name ?? 'NFT preview'}\r\n            className={cn + ' object-cover rounded-none'}\r\n            onClick={onClick}\r\n            onMouseEnter={startHover}\r\n            onMouseLeave={endHover}\r\n            loading={priority ? 'eager' : 'lazy'}\r\n            decoding=\"async\"\r\n            draggable={false}\r\n            referrerPolicy=\"no-referrer\"\r\n            onLoad={fireReady}\r\n            onError={() => { setPosterFailed(true); fireReady(); }}\r\n          />\r\n        </div>\r\n      );\r\n    }\r\n    // Fallback placeholder when both video and poster failed\r\n    return (\r\n      <div ref={(el) => { containerRef(el); visibleRef(el); if (el) fireReady(); }} className=\"relative\">\r\n        <div className={cn + ' rounded-none flex items-center justify-center text-[11px] text-white/70 bg-black select-none'}>\r\n          Video unavailable\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div\r\n      ref={(el) => { containerRef(el); visibleRef(el); }}\r\n      className=\"relative\"\r\n      onMouseEnter={startHover}\r\n      onMouseLeave={endHover}\r\n    >\r\n      {posterUrl ? (\r\n        <img\r\n          src={posterUrl}\r\n          alt={name ?? 'NFT preview'}\r\n          className={cn + ' object-cover rounded-none absolute inset-0 z-10'}\r\n          data-testid=\"nft-thumb-poster\"\r\n          onClick={onClick}\r\n          loading={priority ? 'eager' : 'lazy'}\r\n          decoding=\"async\"\r\n          draggable={false}\r\n          referrerPolicy=\"no-referrer\"\r\n          style={{ opacity: showPoster ? 1 : 0, transition: 'opacity 150ms ease', pointerEvents: showPoster ? 'auto' : 'none' }}\r\n          onLoad={fireReady}\r\n          onError={() => { setPosterFailed(true); setShowPoster(false); }}\r\n          onMouseEnter={startHover}\r\n          onMouseLeave={endHover}\r\n        />\r\n      ) : null}\r\n      <video\r\n        ref={vidRef}\r\n        className={cn + ' object-cover rounded-none relative z-0'}\r\n        data-testid=\"nft-thumb-video\"\r\n        preload={shouldLoad ? 'auto' : (hasValidPoster ? 'metadata' : 'none')}\r\n        crossOrigin=\"anonymous\"\r\n        muted\r\n        playsInline\r\n        loop={isHovering && !suspended}\r\n        controls={false}\r\n        disablePictureInPicture\r\n        aria-label={name ?? 'NFT video preview'}\r\n        poster={posterFailed ? undefined : posterUrl}\r\n        src={shouldLoad ? videoSrc : undefined}\r\n        onClick={onClick}\r\n        onPlay={() => { setShowPoster(false); }}\r\n        onPause={() => { setShowPoster(!!posterUrl && !posterFailed); }}\r\n        onLoadedMetadata={() => {\r\n          const el = vidRef.current;\r\n          if (!el) return;\r\n          const d = Number.isFinite(el.duration) ? el.duration : undefined;\r\n          const t = d ? Math.min(1, Math.max(0.2, d * 0.1)) : 0.5;\r\n          seekRef.current = t;\r\n          try { el.currentTime = t; } catch { /* ignore: some platforms block programmatic seek pre-play */ }\r\n        }}\r\n        onLoadedData={() => {\r\n          const el = vidRef.current;\r\n          if (!el) return;\r\n          try {\r\n            if (el.currentTime < seekRef.current - 0.01) el.currentTime = seekRef.current;\r\n          } catch { /* ignore: best-effort to pre-seek */ }\r\n          if (!isHovering) {\r\n            try { el.pause(); } catch { /* ignore */ }\r\n            try { el.currentTime = seekRef.current; } catch { /* ignore */ }\r\n          } else {\r\n            // If we initiated hover before src was set, ensure playback starts now.\r\n            el.muted = true;\r\n            ensureExclusive(el);\r\n            const p = el.play();\r\n            if (p && typeof p.catch === 'function') p.catch(() => undefined);\r\n          }\r\n          if (!hasValidPoster || posterFailed) {\r\n            try { el.removeAttribute('poster'); } catch { /* ignore */ }\r\n          }\r\n          fireReady();\r\n        }}\r\n        \r\n        onTouchEnd={(e) => {\r\n          if (suspended) { e.preventDefault(); e.stopPropagation(); return; }\r\n          const el = vidRef.current;\r\n          const now = Date.now();\r\n          const dblTap = now - (lastTapRef.current || 0) < 300;\r\n          lastTapRef.current = now;\r\n          if (dblTap) {\r\n            if (onClick) onClick();\r\n          } else {\r\n            if (el) {\r\n              if (el.paused) {\r\n                setForceLoad(true);\r\n                setIsHovering(true);\r\n                setShowPoster(false);\r\n                el.muted = true;\r\n                ensureExclusive(el);\r\n                const p = el.play();\r\n                if (p && typeof p.catch === 'function') p.catch(() => undefined);\r\n              } else {\r\n                setIsHovering(false);\r\n                setShowPoster(!!posterUrl);\r\n                try { el.pause(); } catch { /* ignore */ }\r\n                try { el.currentTime = seekRef.current; } catch { /* ignore */ }\r\n              }\r\n            }\r\n          }\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n        }}\r\n        onError={() => {\r\n          setIdx((i) => {\r\n            const next = i + 1;\r\n            if (next < srcCandidates.length) return next;\r\n            setVideoFailed(true);\r\n            fireReady();\r\n            return i;\r\n          });\r\n        }}\r\n      >\r\n        Your browser does not support the video tag.\r\n      </video>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\preview-playback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\transaction-cells.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_ctx' is defined but never used.","line":46,"column":68,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":72},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_ctx' is defined but never used.","line":50,"column":62,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":66},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2699,2702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2699,2702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":230,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9915,9918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9915,9918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":271,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":271,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12105,12108],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12105,12108],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":306,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13799,13802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13799,13802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":314,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":314,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14097,14100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14097,14100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":315,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14153,14156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14153,14156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":316,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":316,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14212,14215],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14212,14215],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":318,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14276,14279],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14276,14279],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":319,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":319,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14339,14342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14339,14342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":320,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14401,14404],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14401,14404],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":336,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":336,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15055,15058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15055,15058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport type { CellContext, HeaderContext } from '@tanstack/react-table';\r\nimport type { UiTransfer } from '../data/transfer-mapper';\r\nimport { formatTokenAmount, formatTimestampFull, parseTimestampToDate, formatTimeOfDay } from '../utils/formatters';\r\nimport { ExternalLink } from './ui/external-link';\r\nimport { Clock, ArrowDownLeft, ArrowUpRight, ArrowLeftRight, CheckCircle2, Clock as ClockIcon } from 'lucide-react';\r\nimport { AddressDisplay } from './AddressDisplay';\r\nimport { Tooltip, TooltipTrigger, TooltipProvider, TooltipContent } from './ui/tooltip';\r\nimport { REEFSCAN_ORIGIN } from '@/constants/reefscan';\r\n\r\nexport const TypeCell = React.memo(function TypeCell(ctx: CellContext<UiTransfer, unknown>) {\r\n  const { row } = ctx;\r\n  const type = row.getValue('type') as string;\r\n  const t = row.original;\r\n  \r\n  if (t.method === 'swap' || type === 'SWAP') {\r\n    return (\r\n      <span className=\"inline-flex items-center gap-1.5 px-3 py-1 text-xs font-medium rounded-full border border-blue-400 text-blue-600 bg-white\">\r\n        <ArrowLeftRight className=\"w-3 h-3\" />\r\n        Swap\r\n      </span>\r\n    );\r\n  }\r\n  \r\n  const isIncoming = type === 'INCOMING';\r\n  const isErcToken = !t.isNft && (t.token?.name !== 'REEF') && ((t.token?.decimals ?? 18) > 0);\r\n  const label = isErcToken ? (isIncoming ? 'Buy' : 'Sell') : (isIncoming ? 'Incoming' : 'Outgoing');\r\n  \r\n  if (isIncoming) {\r\n    return (\r\n      <span className=\"inline-flex items-center gap-1.5 px-3 py-1 text-xs font-medium rounded-full border border-green-400 text-green-600 bg-white\">\r\n        <ArrowDownLeft className=\"w-3 h-3\" />\r\n        {label}\r\n      </span>\r\n    );\r\n  }\r\n  \r\n  return (\r\n    <span className=\"inline-flex items-center gap-1.5 px-3 py-1 text-xs font-medium rounded-full border border-orange-400 text-orange-600 bg-white\">\r\n      <ArrowUpRight className=\"w-3 h-3\" />\r\n      {label}\r\n    </span>\r\n  );\r\n});\r\n\r\nexport const TimestampHeader = React.memo(function TimestampHeader(_ctx: HeaderContext<UiTransfer, unknown>) {\r\n  return <span>Time</span>;\r\n});\r\n\r\nexport const AmountHeader = React.memo(function AmountHeader(_ctx: HeaderContext<UiTransfer, unknown>) {\r\n  return <span>Amount</span>;\r\n});\r\n\r\nexport const TimestampCell = React.memo(function TimestampCell(ctx: CellContext<UiTransfer, unknown>) {\r\n  const t = ctx.row.original as UiTransfer;\r\n  const ts = ctx.row.getValue('timestamp') as string;\r\n  const d = parseTimestampToDate(ts);\r\n  const invalid = !d || isNaN(d.getTime()) || d.getFullYear() < 2015;\r\n  // Fallback for reef-swap rows without real timestamp: show block height\r\n  if ((t.method === 'swap' || t.type === 'SWAP') && invalid) {\r\n    const block = (t as any)?.blockHeight;\r\n    const label = typeof block === 'number' ? `Block #${block}` : '—';\r\n    return <span className=\"whitespace-nowrap\">{label}</span>;\r\n  }\r\n  const full = formatTimestampFull(ts, 'en-US');\r\n  const timePart = formatTimeOfDay(ts, 'en-US', false);\r\n  const now = Date.now();\r\n  const diffDays = d ? Math.floor(Math.max(0, now - d.getTime()) / (24 * 60 * 60 * 1000)) : 0;\r\n  let topBase = '';\r\n  let bottomBase = '';\r\n  if (!d) {\r\n    topBase = timePart;\r\n    bottomBase = '';\r\n  } else if (diffDays < 7) {\r\n    // < 7 days: show weekday + time on top, and month + day below\r\n    topBase = `${d.toLocaleDateString('en-US', { weekday: 'short' })} ${timePart}`;\r\n    bottomBase = d.toLocaleDateString('en-US', { month: 'short', day: '2-digit' });\r\n  } else {\r\n    // >= 7 days: show compact '<N>d ago' on top and month + day below\r\n    const n = diffDays;\r\n    topBase = `${n}d ago`;\r\n    bottomBase = d.toLocaleDateString('en-US', { month: 'short', day: '2-digit' });\r\n  }\r\n  const top = (topBase || '').toLowerCase();\r\n  const bottom = (bottomBase || '').toLowerCase();\r\n  return (\r\n    <TooltipProvider>\r\n      <Tooltip>\r\n        <TooltipTrigger asChild>\r\n          <div className=\"cursor-help inline-flex items-start gap-2\">\r\n            <Clock className=\"h-3.5 w-3.5 text-gray-400 mt-[2px]\" />\r\n            <div className=\"leading-tight\">\r\n              <div className=\"font-semibold text-gray-800\">{top}</div>\r\n              <div className=\"text-[11px] text-gray-500\">{bottom}</div>\r\n            </div>\r\n          </div>\r\n        </TooltipTrigger>\r\n        <TooltipContent>\r\n          <span>{full}</span>\r\n        </TooltipContent>\r\n      </Tooltip>\r\n    </TooltipProvider>\r\n  );\r\n});\r\n\r\nexport const FromCell = React.memo(function FromCell(ctx: CellContext<UiTransfer, unknown>) {\r\n  return (\r\n    <AddressDisplay\r\n      address={ctx.row.getValue('from') as string}\r\n      className=\"inline-block text-sm font-mono text-slate-700 bg-slate-100/50 px-2 py-1 rounded\"\r\n    />\r\n  );\r\n});\r\n\r\nexport const ToCell = React.memo(function ToCell(ctx: CellContext<UiTransfer, unknown>) {\r\n  return (\r\n    <AddressDisplay\r\n      address={ctx.row.getValue('to') as string}\r\n      className=\"inline-block text-sm font-mono text-slate-700 bg-slate-100/50 px-2 py-1 rounded\"\r\n    />\r\n  );\r\n});\r\n\r\nexport interface AmountCellProps { ctx: CellContext<UiTransfer, unknown> }\r\n\r\nexport const AmountCellComponent = React.memo(function AmountCellComponent({ ctx }: AmountCellProps) {\r\n  const transfer = ctx.row.original;\r\n  if (transfer.method === 'swap' && transfer.swapInfo) {\r\n    const sold = transfer.swapInfo.sold;\r\n    const bought = transfer.swapInfo.bought;\r\n    const soldRaw = String(sold.amount || '0');\r\n    const boughtRaw = String(bought.amount || '0');\r\n    const soldAbs = soldRaw.startsWith('-') ? soldRaw.slice(1) : soldRaw;\r\n    const boughtAbs = boughtRaw.startsWith('-') ? boughtRaw.slice(1) : boughtRaw;\r\n    const boughtFmt = formatTokenAmount(boughtAbs, bought.token.decimals, bought.token.name);\r\n\r\n    function toNumeric(amount: string, decimals: number): number | null {\r\n      if (!/^\\d+$/.test(amount || '')) return null;\r\n      try {\r\n        const bi = BigInt(amount);\r\n        const d = Math.max(0, decimals || 0);\r\n        const div = 10n ** BigInt(d);\r\n        const ip = div === 0n ? 0n : bi / (div || 1n);\r\n        const fp = div === 0n ? '0' : (bi % div).toString().padStart(d, '0');\r\n        const n = d === 0 ? Number(ip) : parseFloat(`${ip}.${fp}`);\r\n        return Number.isFinite(n) ? n : null;\r\n      } catch {\r\n        return null;\r\n      }\r\n    }\r\n    function rateStr(): string {\r\n      const soldNum = toNumeric(sold.amount, sold.token.decimals);\r\n      const boughtNum = toNumeric(bought.amount, bought.token.decimals);\r\n      if (soldNum == null || soldNum <= 0 || boughtNum == null) return '—';\r\n      const r = boughtNum / soldNum;\r\n      if (!Number.isFinite(r)) return '—';\r\n      return r.toLocaleString('en-US', { maximumFractionDigits: 6 });\r\n    }\r\n    // For the 'for …' line: if value is extremely small (< 1e-6), increase precision and prefix with ≈\r\n    function formatForLabel(rawAmount: string, token: { decimals: number; name: string }): string {\r\n      const raw = String(rawAmount || '0');\r\n      const abs = raw.startsWith('-') ? raw.slice(1) : raw;\r\n      const n = toNumeric(abs, token.decimals);\r\n      if (n != null && n > 0 && n < 1e-6) {\r\n        const precise = formatTokenAmount(abs, token.decimals, token.name, { maximumFractionDigits: Math.min(18, token.decimals) });\r\n        return `≈ ${precise}`;\r\n      }\r\n      return formatTokenAmount(abs, token.decimals, token.name);\r\n    }\r\n\r\n    // Single-line BUY/SELL presentation for swaps (ERC-focused):\r\n    // - If bought leg is ERC (non-REEF, decimals>0) → show \"+<bought> TOKEN\" in green\r\n    // - Else if sold leg is ERC → show \"−<sold> TOKEN\" in yellow\r\n    // - Else fallback to showing +bought\r\n    const isErc = (tok?: { name?: string; decimals: number }) => !!tok && tok.decimals > 0 && (tok.name || '').toUpperCase() !== 'REEF';\r\n    const boughtIsErc = isErc(bought.token);\r\n    const soldIsErc = isErc(sold.token);\r\n    let primaryEl: JSX.Element | null = null;\r\n    if (boughtIsErc || !soldIsErc) {\r\n      // Prefer bought side when ERC (or when neither is ERC)\r\n      const cls = 'text-green-600';\r\n      primaryEl = <span className={cls}>+{boughtFmt}</span>;\r\n    } else {\r\n      const soldLabel = formatForLabel(soldAbs, sold.token);\r\n      const cls = 'text-yellow-700';\r\n      primaryEl = <span className={cls}>−{soldLabel}</span>;\r\n    }\r\n    const content = (\r\n      <div className=\"flex flex-col\">\r\n        {primaryEl ?? <span className=\"text-gray-500\">—</span>}\r\n      </div>\r\n    );\r\n\r\n    return (\r\n      <TooltipProvider>\r\n        <Tooltip>\r\n          <TooltipTrigger asChild>{content}</TooltipTrigger>\r\n          <TooltipContent>\r\n            <div className=\"space-y-1\">\r\n              <div className=\"text-xs text-gray-700\">Bought: {boughtFmt}</div>\r\n              <div className=\"text-xs text-gray-700\">Sold: {formatForLabel(soldAbs, sold.token)}</div>\r\n              <div className=\"text-xs text-gray-700\">Rate: 1 {sold.token.name} = {rateStr()} {bought.token.name}</div>\r\n            </div>\r\n          </TooltipContent>\r\n        </Tooltip>\r\n      </TooltipProvider>\r\n    );\r\n  }\r\n  const formattedAmount = formatTokenAmount(\r\n    transfer.amount,\r\n    transfer.token.decimals,\r\n    transfer.token.name\r\n  );\r\n  const isIncoming = transfer.type === 'INCOMING';\r\n  const isErcToken = !transfer.isNft && (transfer.token?.name !== 'REEF') && ((transfer.token?.decimals ?? 18) > 0);\r\n  const prefix = isErcToken ? (isIncoming ? '+' : '−') : '';\r\n  const cls = isErcToken\r\n    ? (isIncoming ? 'text-green-600' : 'text-yellow-700')\r\n    : '';\r\n  return <span className={cls}>{prefix}{formattedAmount}</span>;\r\n});\r\n\r\nexport const AmountCell = React.memo(function AmountCell(ctx: CellContext<UiTransfer, unknown>) {\r\n  return <AmountCellComponent ctx={ctx} />;\r\n});\r\n\r\n// Standalone USD value column\r\nexport const ValueCell = React.memo(function ValueCell(ctx: CellContext<UiTransfer, unknown>) {\r\n  const t = ctx.row.original;\r\n  const meta = (ctx.table.options as any)?.meta as { pricesById?: Record<string, number | null>; reefUsd?: number | null } | undefined;\r\n\r\n  function toNumeric(amount: string, decimals: number): number | null {\r\n    if (!/^\\d+$/.test(amount || '')) return null;\r\n    try {\r\n      const bi = BigInt(amount);\r\n      const d = Math.max(0, decimals || 0);\r\n      const div = 10n ** BigInt(d);\r\n      const ip = div === 0n ? 0n : bi / (div || 1n);\r\n      const fp = div === 0n ? '0' : (bi % div).toString().padStart(d, '0');\r\n      const n = d === 0 ? Number(ip) : parseFloat(`${ip}.${fp}`);\r\n      return Number.isFinite(n) ? n : null;\r\n    } catch { return null; }\r\n  }\r\n\r\n  function usdFor(token: { id?: string; name?: string; decimals: number }, amount: string): string | null {\r\n    const n = toNumeric(amount, token.decimals);\r\n    if (n == null || n <= 0) return null;\r\n    let usdPerUnit: number | undefined;\r\n    if ((token.name || '').toUpperCase() === 'REEF' && typeof meta?.reefUsd === 'number') usdPerUnit = meta.reefUsd as number;\r\n    else if (token.decimals > 0 && token.id && meta?.pricesById) usdPerUnit = meta.pricesById[(token.id || '').toLowerCase()] ?? undefined;\r\n    if (typeof usdPerUnit !== 'number' || !Number.isFinite(usdPerUnit)) return null;\r\n    const usd = n * usdPerUnit;\r\n    return usd.toLocaleString('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 });\r\n  }\r\n\r\n  if (t.method === 'swap' && t.swapInfo) {\r\n    const soldUsd = usdFor(t.swapInfo.sold.token, t.swapInfo.sold.amount);\r\n    const boughtUsd = usdFor(t.swapInfo.bought.token, t.swapInfo.bought.amount);\r\n    if (!soldUsd && !boughtUsd) return <span className=\"block w-full text-right truncate\">—</span>;\r\n    if (soldUsd && boughtUsd) {\r\n      const label = `≈ ${soldUsd} → ${boughtUsd}`;\r\n      return (\r\n        <span className=\"block w-full text-right truncate text-gray-700\" title={label}>{label}</span>\r\n      );\r\n    }\r\n    // Fallbacks when price known only for one side: show single approx line\r\n    const approx = soldUsd ?? boughtUsd;\r\n    return <span className=\"block w-full text-right truncate text-gray-700\" title={approx ?? undefined}>{approx ?? '—'}</span>;\r\n  }\r\n\r\n  const usd = usdFor(t.token as any, t.amount);\r\n  return <span className=\"block w-full text-right truncate\" title={usd ?? undefined}>{usd ?? '—'}</span>;\r\n});\r\n\r\nexport const ActionsCell = React.memo(function ActionsCell(ctx: CellContext<UiTransfer, unknown>) {\r\n  const t = ctx.row.original;\r\n  // Prefer direct transfer URL if we can parse block/extrinsic/event from id\r\n  let href = '';\r\n  let source = '';\r\n  // Подготовим кандидата (id/ preferredTransferId) и анкорное совпадение\r\n  const candidate = (t.method === 'swap' && t.swapInfo?.preferredTransferId)\r\n    ? t.swapInfo.preferredTransferId!\r\n    : (t.id || '');\r\n  // Анкорный паттерн: строго три числовых сегмента через дефис (обрезаем лидирующие нули)\r\n  const mAnchored = /^0*(\\d+)-0*(\\d+)-0*(\\d+)(?:-|$)/.exec(candidate);\r\n  // Извлечь event из 3-го сегмента candidate (если он есть), даже если сегмент содержит буквы (например, af032)\r\n  let eventFromCandidate: string | undefined;\r\n  {\r\n    const parts = candidate.split('-');\r\n    if (parts.length >= 3) {\r\n      const evDigits = parts[2]?.match(/\\d+/g)?.pop();\r\n      if (evDigits) eventFromCandidate = String(Number(evDigits));\r\n    }\r\n  }\r\n\r\n  // 1) extrinsicId (block-extrinsic) + eventIndex (или event из candidate)\r\n  if (t.extrinsicId) {\r\n    const mEx = /^0*(\\d+)-0*(\\d+)$/.exec(t.extrinsicId);\r\n    if (mEx) {\r\n      const [, block, extrinsic] = mEx;\r\n      const evCandidate = (t.eventIndex ?? eventFromCandidate);\r\n      if (evCandidate !== undefined && Number.isFinite(Number(evCandidate))) {\r\n        const event = String(Number(evCandidate));\r\n        href = `${REEFSCAN_ORIGIN}/transfer/${block}/${extrinsic}/${event}`;\r\n        source = 'extrinsicId';\r\n        const title = (import.meta as any)?.env?.DEV ? `${href} (${source}) [exId=${t.extrinsicId}; ev=${String(evCandidate)}]` : href;\r\n        return <ExternalLink href={href} title={title} />;\r\n      }\r\n    }\r\n  }\r\n\r\n  // 2) Числовые индексы из полей (blockHeight/extrinsicIndex/eventIndex)\r\n  if (\r\n    Number.isFinite(Number((t as any).blockHeight)) &&\r\n    Number.isFinite(Number((t as any).extrinsicIndex)) &&\r\n    Number.isFinite(Number((t as any).eventIndex))\r\n  ) {\r\n    const block = String(Number((t as any).blockHeight));\r\n    const extrinsic = String(Number((t as any).extrinsicIndex));\r\n    const event = String(Number((t as any).eventIndex));\r\n    href = `${REEFSCAN_ORIGIN}/transfer/${block}/${extrinsic}/${event}`;\r\n    source = 'indices';\r\n  } else if (mAnchored) {\r\n    // 3) Если id/preferredTransferId содержит ТРИ ЧИСЛОВЫХ сегмента — используем их\r\n    const [, block, extrinsic, event] = mAnchored;\r\n    href = `${REEFSCAN_ORIGIN}/transfer/${block}/${extrinsic}/${event}`;\r\n    source = 'anchored-id';\r\n  } else if (t.extrinsicHash) {\r\n    // 4) Фоллбэк — по хэшу экстраинзикса\r\n    href = `${REEFSCAN_ORIGIN}/extrinsic/${t.extrinsicHash}`;\r\n    source = 'hash';\r\n  } else {\r\n    href = `${REEFSCAN_ORIGIN}/`;\r\n    source = 'home';\r\n  }\r\n  const title = (import.meta as any)?.env?.DEV ? `${href} (${source}) [cand=${candidate}; exId=${t.extrinsicId}; ev=${String(t.eventIndex)}]` : href;\r\n  return <ExternalLink href={href} title={title} />;\r\n});\r\n\r\nexport const StatusCell = React.memo(function StatusCell(ctx: CellContext<UiTransfer, unknown>) {\r\n  const success = ctx.row.getValue('success') as boolean;\r\n  \r\n  if (success) {\r\n    return (\r\n      <span className=\"inline-flex items-center gap-1.5 text-sm text-green-600\">\r\n        <CheckCircle2 className=\"w-4 h-4\" />\r\n        Confirmed\r\n      </span>\r\n    );\r\n  }\r\n  \r\n  return (\r\n    <span className=\"inline-flex items-center gap-1.5 text-sm text-orange-500\">\r\n      <ClockIcon className=\"w-4 h-4\" />\r\n        Pending\r\n    </span>\r\n  );\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\transaction-columns.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ui\\badge-variants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ui\\badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ui\\button-variants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ui\\button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ui\\external-link.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ui\\input.tsx","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":5,"column":18,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":5,"endColumn":28,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[76,154],"text":"type InputProps = React.InputHTMLAttributes<HTMLInputElement>"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\r\n\r\nimport { cn } from \"@/utils/ui\"\r\n\r\nexport interface InputProps\r\n  extends React.InputHTMLAttributes<HTMLInputElement> {}\r\n\r\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\r\n  ({ className, type, ...props }, ref) => {\r\n    return (\r\n      <input\r\n        type={type}\r\n        className={cn(\r\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\r\n          className\r\n        )}\r\n        ref={ref}\r\n        {...props}\r\n      />\r\n    )\r\n  }\r\n)\r\nInput.displayName = \"Input\"\r\n\r\nexport { Input }\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ui\\scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ui\\skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\components\\ui\\tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\constants\\pagination.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\constants\\reefscan.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\addresses.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\aggregator-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\aggregator-mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\balances.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[849,852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[849,852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { parseTokenMetadata } from '@/utils/token-helpers';\r\nimport { graphql } from '@/gql';\r\n\r\nexport interface UiTokenBalance {\r\n  token: { id: string; name: string; decimals: number; image?: string };\r\n  balance: string; // raw on-chain balance as decimal string\r\n}\r\n\r\nexport const TOKEN_HOLDERS_PAGED_QUERY = graphql(`\r\n  query TokenHoldersByAccount($accountId: String!, $first: Int!) {\r\n    tokenHolders: tokenHoldersConnection(\r\n      orderBy: balance_DESC\r\n      where: {\r\n        signer: { id_eq: $accountId }\r\n        AND: { token: { type_eq: ERC20 } }\r\n      }\r\n      first: $first\r\n    ) {\r\n      edges {\r\n        node {\r\n          signer { id evmAddress }\r\n          balance\r\n          token { id contractData }\r\n        }\r\n      }\r\n      totalCount\r\n    }\r\n  }\r\n`);\r\n\r\nexport function mapTokenHoldersToUiBalances(edges: Array<{ node?: any } | null> | null | undefined): UiTokenBalance[] {\r\n  if (!edges) return [];\r\n  const res: UiTokenBalance[] = [];\r\n  for (const e of edges) {\r\n    const n = e?.node;\r\n    if (!n?.token?.id) continue;\r\n    const tokenId = String(n.token.id);\r\n    const meta = parseTokenMetadata(n.token.contractData, 'TOKEN');\r\n    const bal = String(n.balance ?? '0');\r\n    res.push({ token: { id: tokenId, name: meta.name, decimals: meta.decimals, image: meta.image }, balance: bal });\r\n  }\r\n  return res;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\cache-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[382,385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[382,385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[437,440],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[437,440],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Cache manager for transaction pagination\r\n * Handles FIFO cache with access tracking and size management\r\n */\r\n\r\nimport type { Transfer, PageInfo } from '@/gql/graphql';\r\nimport { PAGINATION_CONFIG, CACHE_CONFIG } from '../constants/pagination';\r\n\r\n// Debug flag for cache logs (disabled by default). Enable with VITE_CACHE_DEBUG=1|true\r\nconst DEBUG_CACHE = (import.meta as any)?.env?.VITE_CACHE_DEBUG === '1' || (import.meta as any)?.env?.VITE_CACHE_DEBUG === 'true';\r\nfunction cacheLog(...args: unknown[]) { if (DEBUG_CACHE) console.log(...args); }\r\nfunction cacheWarn(...args: unknown[]) { if (DEBUG_CACHE) console.warn(...args); }\r\n\r\nexport interface CachedPageData {\r\n  transactions: Transfer[];\r\n  pageInfo: PageInfo;\r\n  nativeAddress: string;\r\n  totalCount: number;\r\n}\r\n\r\nexport class PaginationCacheManager {\r\n  private cache = new Map<string, CachedPageData>();\r\n  private accessOrder: string[] = [];\r\n\r\n  /**\r\n   * Generate cache key for a page\r\n   */\r\n  private generateCacheKey(\r\n    nativeAddress: string, \r\n    pageNumber: number, \r\n    isUiCache = false\r\n  ): string {\r\n    const prefix = isUiCache ? CACHE_CONFIG.UI_CACHE_PREFIX : CACHE_CONFIG.PAGE_CACHE_PREFIX;\r\n    return `${nativeAddress}${CACHE_CONFIG.CACHE_KEY_SEPARATOR}${prefix}${pageNumber}`;\r\n  }\r\n\r\n  /**\r\n   * Get cached page data\r\n   */\r\n  get(nativeAddress: string, pageNumber: number, isUiCache = false): CachedPageData | null {\r\n    const key = this.generateCacheKey(nativeAddress, pageNumber, isUiCache);\r\n    const data = this.cache.get(key);\r\n    \r\n    if (data) {\r\n      this.markAsAccessed(key);\r\n      return data;\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Set cached page data\r\n   */\r\n  set(\r\n    nativeAddress: string, \r\n    pageNumber: number, \r\n    data: CachedPageData, \r\n    isUiCache = false\r\n  ): void {\r\n    if (!this.isValidCacheData(data)) {\r\n      cacheWarn('[CACHE] Invalid data provided, skipping cache set');\r\n      return;\r\n    }\r\n\r\n    const key = this.generateCacheKey(nativeAddress, pageNumber, isUiCache);\r\n    this.cache.set(key, data);\r\n    this.markAsAccessed(key);\r\n    this.manageCacheSize();\r\n  }\r\n\r\n  /**\r\n   * Check if page exists in cache\r\n   */\r\n  has(nativeAddress: string, pageNumber: number, isUiCache = false): boolean {\r\n    const key = this.generateCacheKey(nativeAddress, pageNumber, isUiCache);\r\n    return this.cache.has(key);\r\n  }\r\n\r\n  /**\r\n   * Mark a cache entry as accessed (for FIFO management)\r\n   */\r\n  private markAsAccessed(key: string): void {\r\n    // Remove from current position if exists\r\n    const existingIndex = this.accessOrder.indexOf(key);\r\n    if (existingIndex !== -1) {\r\n      this.accessOrder.splice(existingIndex, 1);\r\n    }\r\n    \r\n    // Add to end (most recently accessed)\r\n    this.accessOrder.push(key);\r\n  }\r\n\r\n  /**\r\n   * Manage cache size using FIFO eviction\r\n   */\r\n  private manageCacheSize(): void {\r\n    while (this.cache.size > PAGINATION_CONFIG.MAX_CACHE_SIZE && this.accessOrder.length > 0) {\r\n      const oldestKey = this.accessOrder.shift();\r\n      if (oldestKey && this.cache.has(oldestKey)) {\r\n        this.cache.delete(oldestKey);\r\n        cacheLog(`[CACHE] Evicted oldest entry: ${oldestKey}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate cache data before storing\r\n   */\r\n  private isValidCacheData(data: CachedPageData): boolean {\r\n    return !!(\r\n      data &&\r\n      Array.isArray(data.transactions) &&\r\n      data.pageInfo &&\r\n      typeof data.nativeAddress === 'string' &&\r\n      data.nativeAddress.length > 0 &&\r\n      typeof data.totalCount === 'number' &&\r\n      data.totalCount >= 0\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Clear all cache entries for a specific address\r\n   */\r\n  clearForAddress(nativeAddress: string): void {\r\n    const keysToDelete: string[] = [];\r\n    \r\n    for (const key of this.cache.keys()) {\r\n      if (key.startsWith(nativeAddress + CACHE_CONFIG.CACHE_KEY_SEPARATOR)) {\r\n        keysToDelete.push(key);\r\n      }\r\n    }\r\n    \r\n    keysToDelete.forEach(key => {\r\n      this.cache.delete(key);\r\n      const accessIndex = this.accessOrder.indexOf(key);\r\n      if (accessIndex !== -1) {\r\n        this.accessOrder.splice(accessIndex, 1);\r\n      }\r\n    });\r\n    \r\n    cacheLog(`[CACHE] Cleared ${keysToDelete.length} entries for address: ${nativeAddress}`);\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getStats(): {\r\n    size: number;\r\n    maxSize: number;\r\n    accessOrderLength: number;\r\n  } {\r\n    return {\r\n      size: this.cache.size,\r\n      maxSize: PAGINATION_CONFIG.MAX_CACHE_SIZE,\r\n      accessOrderLength: this.accessOrder.length,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all cache entries\r\n   */\r\n  clear(): void {\r\n    this.cache.clear();\r\n    this.accessOrder = [];\r\n    cacheLog('[CACHE] All cache entries cleared');\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\explorer-blocks.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[409,412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[409,412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[414,417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[414,417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[711,714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[711,714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[716,719],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[716,719],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { gql } from '@apollo/client';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\n\r\n// Last block at or before timestamp\r\nexport const BLOCK_BY_TIME_BEFORE_DOCUMENT = gql`\r\n  query BlockByTimeBefore($ts: DateTime!) {\r\n    blocks(orderBy: timestamp_DESC, limit: 1, where: { timestamp_lte: $ts }) {\r\n      height\r\n      timestamp\r\n    }\r\n  }\r\n` as unknown as TypedDocumentNode<any, any>;\r\n\r\n// First block at or after timestamp\r\nexport const BLOCK_BY_TIME_AFTER_DOCUMENT = gql`\r\n  query BlockByTimeAfter($ts: DateTime!) {\r\n    blocks(orderBy: timestamp_ASC, limit: 1, where: { timestamp_gte: $ts }) {\r\n      height\r\n      timestamp\r\n    }\r\n  }\r\n` as unknown as TypedDocumentNode<any, any>;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\nfts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\reef-swap.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1210,1213],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1210,1213],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1215,1218],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1215,1218],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2265,2268],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2265,2268],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2270,2273],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2270,2273],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3314,3317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3314,3317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3319,3322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3319,3322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4513,4516],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4513,4516],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4518,4521],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4518,4521],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5553,5556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5553,5556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5558,5561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5558,5561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":235,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6585,6588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6585,6588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":235,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6590,6593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6590,6593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":277,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7763,7766],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7763,7766],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":277,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7768,7771],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7768,7771],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { gql } from '@apollo/client';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\n\r\n// Minimal reef-swap documents: only the connection query is kept.\r\nexport const POOL_EVENTS_CONNECTION_DOCUMENT = gql`\r\n  query PoolEventsConnection($first: Int!, $after: String, $addr: String!) {\r\n    poolEventsConnection(\r\n      first: $first\r\n      after: $after\r\n      where: {\r\n        AND: [\r\n          { type_eq: Swap }\r\n          { OR: [\r\n              { senderAddress_containsInsensitive: $addr }\r\n              { toAddress_containsInsensitive: $addr }\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n      orderBy: [blockHeight_DESC, indexInBlock_DESC, id_DESC]\r\n    ) {\r\n      edges {\r\n        node {\r\n          id\r\n          blockHeight\r\n          indexInBlock\r\n          timestamp\r\n          type\r\n          pool {\r\n            id\r\n            token1 { id name decimals }\r\n            token2 { id name decimals }\r\n          }\r\n          senderAddress\r\n          toAddress\r\n          amount1\r\n          amount2\r\n          amountIn1\r\n          amountIn2\r\n        }\r\n        cursor\r\n      }\r\n      pageInfo { hasNextPage endCursor }\r\n    }\r\n  }\r\n` as unknown as TypedDocumentNode<any, any>;\r\n\r\n// Nearest swap within window BEFORE ts (tsFrom..tsTo] ordered descending\r\nexport const NEAREST_SWAP_FOR_TOKEN_WINDOW_BEFORE_DOCUMENT = gql`\r\n  query NearestSwapForTokenWindowBefore($reef: String!, $token: String!, $from: DateTime!, $to: DateTime!) {\r\n    poolEventsConnection(\r\n      first: 1\r\n      orderBy: [timestamp_DESC, id_DESC]\r\n      where: {\r\n        AND: [\r\n          { type_eq: Swap }\r\n          { OR: [\r\n              { pool: { token1: { id_eq: $reef }, token2: { id_eq: $token } } }\r\n              { pool: { token1: { id_eq: $token }, token2: { id_eq: $reef } } }\r\n            ]\r\n          }\r\n          { timestamp_gte: $from }\r\n          { timestamp_lte: $to }\r\n        ]\r\n      }\r\n    ) {\r\n      edges {\r\n        node {\r\n          id\r\n          blockHeight\r\n          indexInBlock\r\n          timestamp\r\n          amount1\r\n          amount2\r\n          amountIn1\r\n          amountIn2\r\n          pool { token1 { id name decimals } token2 { id name decimals } }\r\n        }\r\n      }\r\n    }\r\n  }\r\n` as unknown as TypedDocumentNode<any, any>;\r\n\r\n// Nearest swap within window AFTER ts [tsFrom..tsTo) ordered ascending\r\nexport const NEAREST_SWAP_FOR_TOKEN_WINDOW_AFTER_DOCUMENT = gql`\r\n  query NearestSwapForTokenWindowAfter($reef: String!, $token: String!, $from: DateTime!, $to: DateTime!) {\r\n    poolEventsConnection(\r\n      first: 1\r\n      orderBy: [timestamp_ASC, id_ASC]\r\n      where: {\r\n        AND: [\r\n          { type_eq: Swap }\r\n          { OR: [\r\n              { pool: { token1: { id_eq: $reef }, token2: { id_eq: $token } } }\r\n              { pool: { token1: { id_eq: $token }, token2: { id_eq: $reef } } }\r\n            ]\r\n          }\r\n          { timestamp_gte: $from }\r\n          { timestamp_lte: $to }\r\n        ]\r\n      }\r\n    ) {\r\n      edges {\r\n        node {\r\n          id\r\n          blockHeight\r\n          indexInBlock\r\n          timestamp\r\n          amount1\r\n          amount2\r\n          amountIn1\r\n          amountIn2\r\n          pool { token1 { id name decimals } token2 { id name decimals } }\r\n        }\r\n      }\r\n    }\r\n  }\r\n` as unknown as TypedDocumentNode<any, any>;\r\n// Nearest swap for a token against REEF at or after (blockHeight, indexInBlock)\r\nexport const NEAREST_SWAP_FOR_TOKEN_BY_BLOCK_AFTER_DOCUMENT = gql`\r\n  query NearestSwapForTokenByBlockAfter($reef: String!, $token: String!, $bh: Int!, $ex: Int!) {\r\n    poolEventsConnection(\r\n      first: 1\r\n      orderBy: [blockHeight_ASC, indexInBlock_ASC, id_ASC]\r\n      where: {\r\n        AND: [\r\n          { type_eq: Swap }\r\n          { OR: [\r\n              { pool: { token1: { id_eq: $reef }, token2: { id_eq: $token } } }\r\n              { pool: { token1: { id_eq: $token }, token2: { id_eq: $reef } } }\r\n            ]\r\n          }\r\n          { OR: [\r\n              { blockHeight_gt: $bh }\r\n              { AND: [ { blockHeight_eq: $bh }, { indexInBlock_gte: $ex } ] }\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    ) {\r\n      edges {\r\n        node {\r\n          id\r\n          blockHeight\r\n          indexInBlock\r\n          timestamp\r\n          amount1\r\n          amount2\r\n          amountIn1\r\n          amountIn2\r\n          pool {\r\n            token1 { id name decimals }\r\n            token2 { id name decimals }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n` as unknown as TypedDocumentNode<any, any>;\r\n\r\n// Nearest swap for a token against REEF at or after the given timestamp (UTC)\r\nexport const NEAREST_SWAP_FOR_TOKEN_BY_TIME_AFTER_DOCUMENT = gql`\r\n  query NearestSwapForTokenByTimeAfter($reef: String!, $token: String!, $ts: DateTime!) {\r\n    poolEventsConnection(\r\n      first: 1\r\n      orderBy: [timestamp_ASC, id_ASC]\r\n      where: {\r\n        AND: [\r\n          { type_eq: Swap }\r\n          { OR: [\r\n              { pool: { token1: { id_eq: $reef }, token2: { id_eq: $token } } }\r\n              { pool: { token1: { id_eq: $token }, token2: { id_eq: $reef } } }\r\n            ]\r\n          }\r\n          { timestamp_gte: $ts }\r\n        ]\r\n      }\r\n    ) {\r\n      edges {\r\n        node {\r\n          id\r\n          blockHeight\r\n          indexInBlock\r\n          timestamp\r\n          amount1\r\n          amount2\r\n          amountIn1\r\n          amountIn2\r\n          pool {\r\n            token1 { id name decimals }\r\n            token2 { id name decimals }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n` as unknown as TypedDocumentNode<any, any>;\r\n\r\n// Nearest swap for a token against REEF at or before the given timestamp (UTC)\r\nexport const NEAREST_SWAP_FOR_TOKEN_BY_TIME_DOCUMENT = gql`\r\n  query NearestSwapForTokenByTime($reef: String!, $token: String!, $ts: DateTime!) {\r\n    poolEventsConnection(\r\n      first: 1\r\n      orderBy: [timestamp_DESC, id_DESC]\r\n      where: {\r\n        AND: [\r\n          { type_eq: Swap }\r\n          { OR: [\r\n              { pool: { token1: { id_eq: $reef }, token2: { id_eq: $token } } }\r\n              { pool: { token1: { id_eq: $token }, token2: { id_eq: $reef } } }\r\n            ]\r\n          }\r\n          { timestamp_lte: $ts }\r\n        ]\r\n      }\r\n    ) {\r\n      edges {\r\n        node {\r\n          id\r\n          blockHeight\r\n          indexInBlock\r\n          timestamp\r\n          amount1\r\n          amount2\r\n          amountIn1\r\n          amountIn2\r\n          pool {\r\n            token1 { id name decimals }\r\n            token2 { id name decimals }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n` as unknown as TypedDocumentNode<any, any>;\r\n\r\n// Nearest swap for a token against REEF at or before (blockHeight, indexInBlock)\r\nexport const NEAREST_SWAP_FOR_TOKEN_DOCUMENT = gql`\r\n  query NearestSwapForToken($reef: String!, $token: String!, $bh: Int!, $ex: Int!) {\r\n    poolEventsConnection(\r\n      first: 1\r\n      orderBy: [blockHeight_DESC, indexInBlock_DESC, id_DESC]\r\n      where: {\r\n        AND: [\r\n          { type_eq: Swap }\r\n          { OR: [\r\n              { pool: { token1: { id_eq: $reef }, token2: { id_eq: $token } } }\r\n              { pool: { token1: { id_eq: $token }, token2: { id_eq: $reef } } }\r\n            ]\r\n          }\r\n          { OR: [\r\n              { blockHeight_lt: $bh }\r\n              { AND: [ { blockHeight_eq: $bh }, { indexInBlock_lte: $ex } ] }\r\n            ]\r\n          }\r\n        ]\r\n      }\r\n    ) {\r\n      edges {\r\n        node {\r\n          id\r\n          blockHeight\r\n          indexInBlock\r\n          timestamp\r\n          amount1\r\n          amount2\r\n          amountIn1\r\n          amountIn2\r\n          pool {\r\n            token1 { id name decimals }\r\n            token2 { id name decimals }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n` as unknown as TypedDocumentNode<any, any>;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\staking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\token-icons.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\transfer-mapper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":171,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5647,5650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5647,5650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6452,6455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6452,6455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6535,6538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6535,6538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":194,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6617,6620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6617,6620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6696,6699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6696,6699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isValidEvmAddressFormat } from '@/utils/address-helpers';\r\nimport { getNumber, getString } from '@/utils/object';\r\nimport { parseTokenMetadata, safeBigInt } from '@/utils/token-helpers';\r\n// Use minimal shapes instead of tight GraphQL-generated types so both\r\n// paginated and polling queries can reuse the mapper without type friction.\r\n\r\nexport interface UiSwapLeg {\r\n  amount: string;\r\n  /** Cached bigint for faster compares (optional) */\r\n  amountBI?: bigint;\r\n  token: { id: string; name: string; decimals: number };\r\n}\r\n\r\nexport interface UiSwapInfo {\r\n  sold: UiSwapLeg;\r\n  bought: UiSwapLeg;\r\n  /** Optional: underlying transfer id (block-extrinsic-event) to build a direct Reefscan transfer link */\r\n  preferredTransferId?: string;\r\n}\r\n\r\nexport interface UiTransfer {\r\n  id: string;\r\n  from: string;\r\n  to: string;\r\n  type: 'INCOMING' | 'OUTGOING' | 'SWAP';\r\n  amount: string;\r\n  /** Cached bigint representation of amount for fast numeric compares */\r\n  amountBI?: bigint;\r\n  isNft: boolean;\r\n  tokenId: string | null;\r\n  token: {\r\n    id: string; \r\n    name: string;\r\n    decimals: number;\r\n  };\r\n  timestamp: string;\r\n  success: boolean;\r\n\r\n  extrinsicHash: string;\r\n  /** Present on subsquid for swap-related legs */\r\n  reefswapAction?: string | null;\r\n\r\n  // Optional precise indices for Reefscan transfer link\r\n  blockHeight?: number;\r\n  extrinsicIndex?: number;\r\n  eventIndex?: number;\r\n  /** Optional extrinsic id in the form Block-Extrinsic (no event) */\r\n  extrinsicId?: string;\r\n\r\n  /** Synthetic method when we aggregate legs into a single logical action */\r\n  method?: 'swap' | 'transfer';\r\n  /** Detailed amounts for swap rows */\r\n  swapInfo?: UiSwapInfo;\r\n}\r\n\r\ninterface TransferLikeToken {\r\n  id: string;\r\n  name: string;\r\n  contractData?: unknown;\r\n}\r\n\r\ninterface TransferLike {\r\n  id: string;\r\n  amount: string;\r\n  timestamp: string;\r\n  success: boolean;\r\n  type: string;\r\n  signedData?: unknown;\r\n  extrinsicHash?: string | null;\r\n  fromEvmAddress?: string | null;\r\n  toEvmAddress?: string | null;\r\n  from: { id: string };\r\n  to: { id: string };\r\n  token: TransferLikeToken;\r\n}\r\n\r\ntype TransferEdge = { node: TransferLike };\r\ntype Transfer = TransferLike;\r\n\r\n\r\n// Cache token metadata derived from contractData to avoid repeated JSON.parse\r\nconst tokenMetaCache = new Map<string, { name: string; decimals: number }>();\r\n\r\n/** Check if token metadata is already cached for a given token id (as-is, checksum preserved). */\r\nexport function hasTokenMetaCached(id?: string | null): boolean {\r\n  if (!id) return false;\r\n  return tokenMetaCache.has(id);\r\n}\r\n\r\n/** Prime token metadata cache from a list of contracts (id + contractData JSON). Returns number of items added. */\r\nexport function primeTokenMetaCacheFromContracts(items: Array<{ id?: string | null; contractData?: unknown; name?: string | null }>): number {\r\n  let added = 0;\r\n  for (const it of items) {\r\n    const id = (it?.id ?? '').toString();\r\n    if (!id || tokenMetaCache.has(id)) continue;\r\n    const meta = parseTokenMetadata(it?.contractData, it?.name ?? 'TOKEN');\r\n    tokenMetaCache.set(id, { name: meta.name, decimals: meta.decimals });\r\n    added += 1;\r\n  }\r\n  return added;\r\n}\r\n\r\nconst resolveTransferDirection = (\r\n  transfer: Transfer,\r\n  userAddress: string,\r\n): 'INCOMING' | 'OUTGOING' => {\r\n  const ua = userAddress.toLowerCase();\r\n  if (isValidEvmAddressFormat(userAddress)) {\r\n    const fromEvm = (transfer.fromEvmAddress || '').toString().toLowerCase();\r\n    const toEvm = (transfer.toEvmAddress || '').toString().toLowerCase();\r\n    if (fromEvm && fromEvm === ua) return 'OUTGOING';\r\n    if (toEvm && toEvm === ua) return 'INCOMING';\r\n  }\r\n  return (transfer.from.id.toLowerCase() === ua ? 'OUTGOING' : 'INCOMING');\r\n};\r\n\r\nfunction parseTokenData(transfer: Transfer): { name: string; decimals: number } {\r\n  if (transfer.type === 'ERC721' || transfer.type === 'ERC1155') {\r\n    return { name: 'NFT', decimals: 0 };\r\n  }\r\n\r\n  // If token is REEF, short-circuit\r\n  if (transfer.token.name === 'REEF') return { name: 'REEF', decimals: 18 };\r\n\r\n  // Try cache first\r\n  const cached = tokenMetaCache.get(transfer.token.id);\r\n  if (cached) return cached;\r\n\r\n  // contractData may be omitted from some queries to reduce payload size\r\n  const contractDataRaw = transfer.token.contractData;\r\n  if (!contractDataRaw) {\r\n    // Fallbacks for well-known tokens when metadata is omitted\r\n    const nm = (transfer.token.name || '').toString();\r\n    const lower = nm.toLowerCase();\r\n    if (lower === 'usdc' || lower === 'usdc.e' || lower === 'usd coin') {\r\n      return { name: nm, decimals: 6 };\r\n    }\r\n    if (lower === 'mrd') {\r\n      return { name: nm, decimals: 18 };\r\n    }\r\n    // Generic default\r\n    return { name: nm, decimals: 18 };\r\n  }\r\n\r\n  const meta = parseTokenMetadata(contractDataRaw, transfer.token.name);\r\n  const result = { name: meta.name, decimals: meta.decimals };\r\n  \r\n  // Cache only when we had contractData to avoid caching placeholders\r\n  tokenMetaCache.set(transfer.token.id, result);\r\n  return result;\r\n}\r\n\r\n\r\n\r\nexport function mapTransfersToUiTransfers(\r\n  transferEdges: (TransferEdge | null)[] | null | undefined,\r\n  userAddress: string | null | undefined\r\n): UiTransfer[] {\r\n  if (!transferEdges || !userAddress) {\r\n    return [];\r\n  }\r\n\r\n  return transferEdges\r\n    .map((edge): UiTransfer | null => {\r\n      if (!edge?.node) {\r\n        return null;\r\n      }\r\n      const transfer = edge.node;\r\n      const { name: tokenName, decimals: tokenDecimals } = parseTokenData(transfer);\r\n      const isNft = transfer.type === 'ERC721' || transfer.type === 'ERC1155';\r\n      const swapFlag = getString(transfer as any, ['reefswapAction']) ?? null;\r\n      return {\r\n        id: transfer.id,\r\n        from: transfer.from.id,\r\n        to: transfer.to.id,\r\n        type: resolveTransferDirection(transfer, userAddress),\r\n        amount: transfer.amount,\r\n        amountBI: safeBigInt(transfer.amount),\r\n        isNft,\r\n        tokenId: isNft ? transfer.amount : null, // Simplification, might need adjustment based on actual NFT logic\r\n        token: {\r\n          id: transfer.token.id,\r\n          name: tokenName,\r\n          decimals: tokenDecimals,\r\n        },\r\n        timestamp: transfer.timestamp,\r\n        success: transfer.success,\r\n\r\n        extrinsicHash: transfer.extrinsicHash || '',\r\n        reefswapAction: swapFlag,\r\n        method: swapFlag ? 'swap' : 'transfer',\r\n        blockHeight: getNumber(transfer as any, ['blockHeight']) ?? undefined,\r\n        extrinsicIndex: getNumber(transfer as any, ['extrinsicIndex']) ?? undefined,\r\n        eventIndex: getNumber(transfer as any, ['eventIndex']) ?? undefined,\r\n        extrinsicId: getString(transfer as any, ['extrinsicId']) ?? undefined,\r\n      };\r\n    })\r\n    .filter((transfer): transfer is UiTransfer => transfer !== null);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\transfers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1595,1598],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1595,1598],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1600,1603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1600,1603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1822,1825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1822,1825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1865,1868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1865,1868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1906,1909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1906,1909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":161,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":161,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5472,5475],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5472,5475],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":163,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5575,5578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5575,5578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":164,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5615,5618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5615,5618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5678,5681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5678,5681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":169,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5779,5782],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5779,5782],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":170,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5832,5835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5832,5835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6076,6079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6076,6079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6081,6084],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6081,6084],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":181,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6199,6202],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6199,6202],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":181,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6231,6234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6231,6234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { graphql } from '@/gql';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport type { ApolloClient, NormalizedCacheObject } from '@apollo/client';\r\n\r\n// Identity resolution: get extrinsic id/hash by any of the identifiers (hash, id, or height+index)\r\nexport const EXTRINSIC_IDENTITY_UNIFIED_QUERY = graphql(`\r\n  query ExtrinsicIdentityUnified(\r\n    $hash: String, $id: String, $height: Int, $index: Int,\r\n    $useHash: Boolean!, $useId: Boolean!, $useHeightIndex: Boolean!\r\n  ) {\r\n    byHash: extrinsics(where: { hash_eq: $hash }, limit: 1) @include(if: $useHash) { id hash }\r\n    byId: extrinsics(where: { id_eq: $id }, limit: 1) @include(if: $useId) { id hash }\r\n    byHeightIndex: extrinsics(where: { index_eq: $index, block: { height_eq: $height } }, limit: 1) @include(if: $useHeightIndex) { id hash }\r\n  }\r\n`);\r\n\r\nexport async function fetchExtrinsicIdentityOnce(\r\n  client: ApolloClient<NormalizedCacheObject>,\r\n  params: { hash?: string | null; extrinsicId?: string | null; height?: number | null; index?: number | null },\r\n): Promise<{ id?: string; hash?: string } | null> {\r\n  const hash = (params.hash || '').trim();\r\n  const id = (params.extrinsicId || '').trim();\r\n  const h = Number(params.height);\r\n  const i = Number(params.index);\r\n  const useHash = !!hash;\r\n  const useId = !!id;\r\n  const useHeightIndex = Number.isFinite(h) && Number.isFinite(i);\r\n  if (!useHash && !useId && !useHeightIndex) return null;\r\n  try {\r\n    const { data } = await client.query({\r\n      query: EXTRINSIC_IDENTITY_UNIFIED_QUERY as unknown as TypedDocumentNode<any, any>,\r\n      variables: { hash, id, height: useHeightIndex ? h : undefined, index: useHeightIndex ? i : undefined, useHash, useId, useHeightIndex },\r\n      fetchPolicy: 'network-only',\r\n    });\r\n    const node = ((data as any)?.byHash ?? [])[0]\r\n      || ((data as any)?.byId ?? [])[0]\r\n      || ((data as any)?.byHeightIndex ?? [])[0];\r\n    if (!node) return null;\r\n    return { id: node?.id, hash: node?.hash };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n// --- Reusable fragments for transfers ---\r\nexport const TRANSFER_COMMON_FIELDS = graphql(`\r\n  fragment TransferCommonFields on Transfer {\r\n    id\r\n    amount\r\n    timestamp\r\n    success\r\n    type\r\n    reefswapAction\r\n    extrinsicHash\r\n    extrinsicId\r\n    blockHeight\r\n    extrinsicIndex\r\n    eventIndex\r\n    fromEvmAddress\r\n    toEvmAddress\r\n    from { id }\r\n    to { id }\r\n    token { id name }\r\n  }\r\n`);\r\n\r\nexport const PAGINATED_TRANSFERS_QUERY = graphql(`\r\n  query PaginatedTransfers($first: Int!, $after: String, $where: TransferWhereInput, $orderBy: [TransferOrderByInput!]!) {\r\n    transfersConnection(orderBy: $orderBy, first: $first, after: $after, where: $where) {\r\n      edges {\r\n        node {\r\n          ...TransferCommonFields\r\n          token {\r\n            contractData\r\n          }\r\n        }\r\n      }\r\n      pageInfo {\r\n        hasNextPage\r\n        endCursor\r\n      }\r\n      totalCount\r\n    }\r\n  }\r\n`);\r\n\r\n// Minimal variant without token.contractData for lighter payload when token filter is fixed\r\nexport const PAGINATED_TRANSFERS_MIN_QUERY = graphql(`\r\n  query TransfersMinQuery($first: Int!, $after: String, $where: TransferWhereInput, $orderBy: [TransferOrderByInput!]!) {\r\n    transfersConnection(orderBy: $orderBy, first: $first, after: $after, where: $where) {\r\n      edges {\r\n        node {\r\n          ...TransferCommonFields\r\n        }\r\n      }\r\n      pageInfo {\r\n        hasNextPage\r\n        endCursor\r\n      }\r\n      totalCount\r\n    }\r\n  }\r\n`);\r\n\r\nexport const TRANSFERS_COUNT_QUERY = graphql(`\r\n  query TransfersCount($where: TransferWhereInput, $orderBy: [TransferOrderByInput!]!) {\r\n    transfersConnection(where: $where, orderBy: $orderBy, first: 1) {\r\n      totalCount\r\n    }\r\n  }\r\n`);\r\n\r\nexport const TRANSFERS_BULK_COUNTS_QUERY = graphql(`\r\n  query TransfersBulkCounts(\r\n    $whereAny: TransferWhereInput\r\n    $whereIncoming: TransferWhereInput\r\n    $whereOutgoing: TransferWhereInput\r\n    $orderBy: [TransferOrderByInput!]!\r\n  ) {\r\n    all: transfersConnection(where: $whereAny, orderBy: $orderBy, first: 1) {\r\n      totalCount\r\n    }\r\n    incoming: transfersConnection(where: $whereIncoming, orderBy: $orderBy, first: 1) {\r\n      totalCount\r\n    }\r\n    outgoing: transfersConnection(where: $whereOutgoing, orderBy: $orderBy, first: 1) {\r\n      totalCount\r\n    }\r\n  }\r\n`);\r\n\r\n// (removed) NFT_TOKEN_ID_QUERY — unused\r\n\r\n\r\n// Polling query for new transfers (used by subscription hook)\r\nexport const TRANSFERS_POLLING_QUERY = graphql(`\r\n  query TransfersPollingQuery($where: TransferWhereInput, $orderBy: [TransferOrderByInput!], $offset: Int, $limit: Int) {\r\n    transfers(where: $where, orderBy: $orderBy, offset: $offset, limit: $limit) {\r\n      ...TransferCommonFields\r\n    }\r\n  }\r\n`);\r\n\r\n/** Resolve transfer indices and extrinsic id/hash by any identifier. */\r\nexport async function fetchAnyTransferIndicesOnce(\r\n  client: ApolloClient<NormalizedCacheObject>,\r\n  params: { hash?: string | null; extrinsicId?: string | null; height?: number | null; index?: number | null },\r\n): Promise<{\r\n  blockHeight?: number;\r\n  extrinsicIndex?: number;\r\n  eventIndex?: number;\r\n  extrinsicId?: string;\r\n  extrinsicHash?: string;\r\n} | null> {\r\n  const hash = (params.hash || '').trim();\r\n  const id = (params.extrinsicId || '').trim();\r\n  const h = Number(params.height);\r\n  const i = Number(params.index);\r\n  const where: Record<string, unknown> = {};\r\n  if (hash) {\r\n    (where as any).extrinsicHash_eq = hash;\r\n  } else if (Number.isFinite(h) && Number.isFinite(i)) {\r\n    (where as any).blockHeight_eq = h;\r\n    (where as any).extrinsicIndex_eq = i;\r\n  } else if (id) {\r\n    (where as any).extrinsicId_eq = id;\r\n    const m = /^0*(\\d+)-0*(\\d+)/.exec(id);\r\n    if (m) {\r\n      (where as any).blockHeight_eq = Number(m[1]);\r\n      (where as any).extrinsicIndex_eq = Number(m[2]);\r\n    }\r\n  } else {\r\n    return null;\r\n  }\r\n  try {\r\n    const { data } = await (client as ApolloClient<NormalizedCacheObject>).query({\r\n      query: TRANSFERS_POLLING_QUERY as unknown as TypedDocumentNode<any, any>,\r\n      variables: { where, limit: 50 },\r\n      fetchPolicy: 'network-only',\r\n    });\r\n    const arr = ((data as any)?.transfers ?? []) as Array<any>;\r\n    if (!Array.isArray(arr) || arr.length === 0) return null;\r\n    const first = arr[0];\r\n    const minEvent = arr\r\n      .map((x) => Number((x?.eventIndex)))\r\n      .filter((n) => Number.isFinite(n))\r\n      .reduce<number | undefined>((min, n) => (min == null ? n : Math.min(min, n)), undefined);\r\n    return {\r\n      blockHeight: Number.isFinite(Number(first?.blockHeight)) ? Number(first.blockHeight) : undefined,\r\n      extrinsicIndex: Number.isFinite(Number(first?.extrinsicIndex)) ? Number(first.extrinsicIndex) : undefined,\r\n      eventIndex: minEvent,\r\n      extrinsicId: typeof first?.extrinsicId === 'string' ? first.extrinsicId : undefined,\r\n      extrinsicHash: typeof first?.extrinsicHash === 'string' ? first.extrinsicHash : undefined,\r\n    };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\ttl-cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\data\\verified-contracts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\__tests__\\use-sqwid-nfts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\__tests__\\use-token-bootstrap.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-active-wallets-24h.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-address-resolver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-anchor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[421,424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[421,424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'dbg'. Either include it or remove the dependency array. If 'dbg' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":22,"column":6,"nodeType":"ArrayExpression","endLine":22,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [address, dbg]","fix":{"range":[837,846],"text":"[address, dbg]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'dbg'. Either include it or remove the dependency array. If 'dbg' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":28,"column":6,"nodeType":"ArrayExpression","endLine":28,"endColumn":54,"suggestions":[{"desc":"Update the dependencies array to be: [direction, minReefRaw, maxReefRaw, tokenFilter, dbg]","fix":{"range":[1070,1118],"text":"[direction, minReefRaw, maxReefRaw, tokenFilter, dbg]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'dbg'. Either include it or remove the dependency array. If 'dbg' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":37,"column":6,"nodeType":"ArrayExpression","endLine":37,"endColumn":42,"suggestions":[{"desc":"Update the dependencies array to be: [anchorFirstId, dbg, initialTransactions]","fix":{"range":[1441,1477],"text":"[anchorFirstId, dbg, initialTransactions]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'dbg'. Either include it or remove the dependency array. If 'dbg' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":52,"column":6,"nodeType":"ArrayExpression","endLine":52,"endColumn":53,"suggestions":[{"desc":"Update the dependencies array to be: [initialTransactions, anchorFirstId, pageIndex, dbg]","fix":{"range":[2139,2186],"text":"[initialTransactions, anchorFirstId, pageIndex, dbg]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'dbg'. Either include it or remove the dependency array. If 'dbg' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":79,"column":6,"nodeType":"ArrayExpression","endLine":79,"endColumn":57,"suggestions":[{"desc":"Update the dependencies array to be: [newItemsCount, anchorFirstId, initialTransactions, dbg]","fix":{"range":[3285,3336],"text":"[newItemsCount, anchorFirstId, initialTransactions, dbg]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'dbg'. Either include it or remove the dependency array. If 'dbg' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":98,"column":6,"nodeType":"ArrayExpression","endLine":98,"endColumn":53,"suggestions":[{"desc":"Update the dependencies array to be: [pageIndex, newItemsCount, initialTransactions, dbg]","fix":{"range":[4084,4131],"text":"[pageIndex, newItemsCount, initialTransactions, dbg]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useMemo, useRef, useState } from 'react';\r\nimport type { UiTransfer } from '@/data/transfer-mapper';\r\n\r\ninterface UseAnchorArgs {\r\n  address: string;\r\n  direction: 'any' | 'incoming' | 'outgoing';\r\n  minReefRaw?: string | bigint | null;\r\n  maxReefRaw?: string | bigint | null;\r\n  tokenFilter: string;\r\n  initialTransactions?: UiTransfer[] | null;\r\n  pageIndex: number;\r\n  dbg?: (...args: any[]) => void;\r\n}\r\n\r\nexport function useAnchor({ address, direction, minReefRaw, maxReefRaw, tokenFilter, initialTransactions, pageIndex, dbg }: UseAnchorArgs) {\r\n  const [anchorFirstId, setAnchorFirstId] = useState<string | undefined>(undefined);\r\n\r\n  // Reset anchor when address changes\r\n  useEffect(() => {\r\n    dbg?.('anchor: reset due to address change', { address });\r\n    setAnchorFirstId(undefined);\r\n  }, [address]);\r\n\r\n  // Reset anchor when filters change\r\n  useEffect(() => {\r\n    dbg?.('anchor: reset due to direction/min/max/token change', { direction, minReefRaw, maxReefRaw, tokenFilter });\r\n    setAnchorFirstId(undefined);\r\n  }, [direction, minReefRaw, maxReefRaw, tokenFilter]);\r\n\r\n  // Initialize anchor to current first id once data is available\r\n  useEffect(() => {\r\n    if (!anchorFirstId && initialTransactions && initialTransactions.length > 0) {\r\n      const id = initialTransactions[0]!.id;\r\n      dbg?.('anchor: init to current first id', { id });\r\n      setAnchorFirstId(id);\r\n    }\r\n  }, [anchorFirstId, initialTransactions]);\r\n\r\n  // If anchor is no longer found (e.g., cache reset), re-anchor to current first on page 1\r\n  useEffect(() => {\r\n    if (!initialTransactions || initialTransactions.length === 0) return;\r\n    if (!anchorFirstId) return;\r\n    const missing = initialTransactions.findIndex(t => t.id === anchorFirstId) === -1;\r\n    if (!missing) return;\r\n    if (pageIndex === 0) {\r\n      const id = initialTransactions[0]!.id;\r\n      dbg?.('anchor: not found on page 1, re-anchor to current first', { prev: anchorFirstId, next: id });\r\n      setAnchorFirstId(id);\r\n    } else {\r\n      dbg?.('anchor: not found on deep page, keep previous anchor (stability)');\r\n    }\r\n  }, [initialTransactions, anchorFirstId, pageIndex]);\r\n\r\n  // Track index of anchor and freeze newItemsCount on deep pages if anchor disappears\r\n  const anchorIndex = useMemo(() => {\r\n    if (!initialTransactions || initialTransactions.length === 0) return -1;\r\n    if (!anchorFirstId) return -1;\r\n    return initialTransactions.findIndex(t => t.id === anchorFirstId);\r\n  }, [initialTransactions, anchorFirstId]);\r\n\r\n  const lastKnownNewItemsCountRef = useRef(0);\r\n  useEffect(() => {\r\n    if (anchorIndex >= 0) {\r\n      lastKnownNewItemsCountRef.current = anchorIndex;\r\n    }\r\n  }, [anchorIndex]);\r\n\r\n  // Number of new items prepended since anchor was set\r\n  const newItemsCount = useMemo(() => {\r\n    if (!anchorFirstId) return 0;\r\n    if (anchorIndex >= 0) return anchorIndex;\r\n    return pageIndex > 0 ? lastKnownNewItemsCountRef.current : 0;\r\n  }, [anchorFirstId, anchorIndex, pageIndex]);\r\n\r\n  // Log when newItemsCount changes\r\n  useEffect(() => {\r\n    const firstId = initialTransactions && initialTransactions[0] ? initialTransactions[0].id : undefined;\r\n    dbg?.('newItemsCount updated', { newItemsCount, anchorFirstId, firstId });\r\n  }, [newItemsCount, anchorFirstId, initialTransactions]);\r\n\r\n  const showNewItems = useCallback((anchorId?: string) => {\r\n    if (anchorId) { setAnchorFirstId(anchorId); return; }\r\n    if (initialTransactions && initialTransactions.length > 0) {\r\n      setAnchorFirstId(initialTransactions[0]!.id);\r\n    } else {\r\n      setAnchorFirstId(undefined);\r\n    }\r\n  }, [initialTransactions]);\r\n\r\n  // If user is on page 1, always reveal newly prepended items by re-anchoring\r\n  useEffect(() => {\r\n    if (pageIndex !== 0) return;\r\n    if (newItemsCount <= 0) return;\r\n    if (!initialTransactions || initialTransactions.length === 0) return;\r\n    const id = initialTransactions[0]!.id;\r\n    dbg?.('anchor: auto re-anchor on page 1 to reveal new items', { id, newItemsCount });\r\n    setAnchorFirstId(id);\r\n  }, [pageIndex, newItemsCount, initialTransactions]);\r\n\r\n  return { newItemsCount, showNewItems } as const;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-ensure-loaded.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[579,582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[579,582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'dbg', 'ensureMaxedRef', 'ensureSeqRef', 'inFlightEnsureRef', and 'pagination'. Either include them or remove the dependency array. If 'dbg' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":105,"column":6,"nodeType":"ArrayExpression","endLine":105,"endColumn":170,"suggestions":[{"desc":"Update the dependencies array to be: [fastModeActive, swapOnly, pagination.pageIndex, pagination.pageSize, initialTransactions, filteredTransactions, tokenFilter, hasNextPage, fetchMore, newItemsCount, ensureSeqRef, ensureMaxedRef, pagination, inFlightEnsureRef, dbg]","fix":{"range":[3799,3963],"text":"[fastModeActive, swapOnly, pagination.pageIndex, pagination.pageSize, initialTransactions, filteredTransactions, tokenFilter, hasNextPage, fetchMore, newItemsCount, ensureSeqRef, ensureMaxedRef, pagination, inFlightEnsureRef, dbg]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, type MutableRefObject } from 'react';\r\nimport type { PaginationState } from '@tanstack/react-table';\r\nimport { PAGINATION_CONFIG } from '../constants/pagination';\r\nimport type { UiTransfer } from '../data/transfer-mapper';\r\n\r\ninterface EnsureLoadedArgs {\r\n  fastModeActive: boolean;\r\n  swapOnly: boolean;\r\n  pagination: PaginationState;\r\n  initialTransactions?: UiTransfer[] | null;\r\n  filteredTransactions?: UiTransfer[] | null;\r\n  tokenFilter: string;\r\n  hasNextPage: boolean;\r\n  fetchMore: () => Promise<void>;\r\n  newItemsCount: number;\r\n  dbg?: (...args: any[]) => void;\r\n}\r\n\r\ninterface EnsureLoadedRefs {\r\n  inFlightEnsureRef: MutableRefObject<boolean>;\r\n  ensureSeqRef: MutableRefObject<number>;\r\n  ensureMaxedRef: MutableRefObject<boolean>;\r\n}\r\n\r\nexport function useEnsureLoaded(\r\n  {\r\n    fastModeActive,\r\n    swapOnly,\r\n    pagination,\r\n    initialTransactions,\r\n    filteredTransactions,\r\n    tokenFilter,\r\n    hasNextPage,\r\n    fetchMore,\r\n    newItemsCount,\r\n    dbg,\r\n  }: EnsureLoadedArgs,\r\n  { inFlightEnsureRef, ensureSeqRef, ensureMaxedRef }: EnsureLoadedRefs,\r\n) {\r\n  useEffect(() => {\r\n    if (fastModeActive) return; // skip sequential ensure loop in fast mode\r\n    // Optimization: for Swap + token-filtered views that clearly fit into a single page, skip ensure loop\r\n    if (swapOnly && tokenFilter !== 'all') {\r\n      const items = (filteredTransactions || []).length;\r\n      const singlePage = !hasNextPage && items <= pagination.pageSize;\r\n      if (singlePage && pagination.pageIndex === 0) return;\r\n    }\r\n    let cancelled = false;\r\n    const seq = (ensureSeqRef.current = (ensureSeqRef.current ?? 0) + 1);\r\n    ensureMaxedRef.current = false;\r\n\r\n    async function run() {\r\n      if (inFlightEnsureRef.current) return; // Avoid overlapping runs\r\n\r\n      const { pageIndex, pageSize } = pagination;\r\n      const ladderPages = swapOnly ? 1 : Math.max(1, PAGINATION_CONFIG.NON_FAST_LADDER_UI_PAGES || 1);\r\n      const isFilteredMode = (tokenFilter !== 'all') || swapOnly;\r\n      const requiredCount = isFilteredMode\r\n        ? (pageIndex + ladderPages) * pageSize\r\n        : (newItemsCount + (pageIndex + ladderPages) * pageSize);\r\n\r\n      let attempts = 0;\r\n      const maxAttempts = (PAGINATION_CONFIG.MAX_SEQUENTIAL_FETCH_PAGES || 20);\r\n      dbg?.('ensureLoaded: start', {\r\n        pageIndex,\r\n        pageSize,\r\n        requiredCount,\r\n        newItemsCount,\r\n        itemsLoaded: isFilteredMode ? (filteredTransactions || []).length : (initialTransactions || []).length,\r\n        hasNextPage,\r\n      });\r\n\r\n      while (!cancelled) {\r\n        const itemsLoaded = isFilteredMode ? (filteredTransactions || []).length : (initialTransactions || []).length;\r\n        if (!isFilteredMode) {\r\n          if (!initialTransactions || initialTransactions.length === 0) { dbg?.('ensureLoaded: base query not ready'); break; }\r\n        }\r\n        if (itemsLoaded >= requiredCount) break;\r\n        if (!hasNextPage) break;\r\n        if (attempts >= maxAttempts) break;\r\n\r\n        inFlightEnsureRef.current = true;\r\n        try {\r\n          dbg?.('ensureLoaded: fetchMore', { attempt: attempts + 1, itemsLoaded, requiredCount });\r\n          await fetchMore();\r\n        } catch {\r\n          break; // surface errors via error state; stop loop\r\n        } finally {\r\n          inFlightEnsureRef.current = false;\r\n        }\r\n        attempts++;\r\n        if (seq !== ensureSeqRef.current) break; // deps changed, abandon\r\n      }\r\n\r\n      ensureMaxedRef.current = (attempts >= maxAttempts) || !hasNextPage;\r\n      dbg?.('ensureLoaded: end', { attempts, maxed: ensureMaxedRef.current });\r\n    }\r\n\r\n    run();\r\n\r\n    return () => {\r\n      cancelled = true;\r\n      ensureSeqRef.current = (ensureSeqRef.current ?? 0) + 1; // bump seq to signal abandonment\r\n    };\r\n  }, [fastModeActive, swapOnly, pagination.pageIndex, pagination.pageSize, initialTransactions, filteredTransactions, tokenFilter, hasNextPage, fetchMore, newItemsCount]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-fast-window.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'pagination'. Either include it or remove the dependency array.","line":61,"column":6,"nodeType":"ArrayExpression","endLine":61,"endColumn":102,"suggestions":[{"desc":"Update the dependencies array to be: [fastModeActive, pagination.pageIndex, pagination.pageSize, newItemsCount, fetchWindow, address, pagination]","fix":{"range":[2204,2300],"text":"[fastModeActive, pagination.pageIndex, pagination.pageSize, newItemsCount, fetchWindow, address, pagination]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useRef, useState } from 'react';\r\nimport type { PaginationState } from '@tanstack/react-table';\r\nimport { PAGINATION_CONFIG } from '@/constants/pagination';\r\nimport type { UiTransfer } from '@/data/transfer-mapper';\r\n\r\ninterface UseFastWindowArgs {\r\n  tokenFilter: string;\r\n  swapOnly: boolean;\r\n  pagination: PaginationState;\r\n  fetchWindow: (offset: number, limit: number) => Promise<UiTransfer[]>;\r\n  newItemsCount: number;\r\n  address: string;\r\n}\r\n\r\nexport function useFastWindow({ tokenFilter, swapOnly, pagination, fetchWindow, newItemsCount, address }: UseFastWindowArgs) {\r\n  const fastModeActive = useMemo(() => {\r\n    return (tokenFilter === 'all' && !swapOnly) && !!PAGINATION_CONFIG.ENABLE_FAST_OFFSET_MODE && (pagination.pageIndex >= PAGINATION_CONFIG.FAST_OFFSET_MODE_THRESHOLD_PAGES);\r\n  }, [pagination.pageIndex, tokenFilter, swapOnly]);\r\n\r\n  const [fastPageData, setFastPageData] = useState<UiTransfer[] | null>(null);\r\n  const [isFastLoading, setIsFastLoading] = useState<boolean>(false);\r\n  const fastSeqRef = useRef(0);\r\n  const prevAddressRef = useRef(address);\r\n\r\n  useEffect(() => {\r\n    // Clear fast data when leaving fast mode or when address changes\r\n    if (!fastModeActive) {\r\n      setFastPageData(null);\r\n      setIsFastLoading(false);\r\n      return;\r\n    }\r\n\r\n    if (prevAddressRef.current !== address) {\r\n      setFastPageData(null);\r\n      setIsFastLoading(false);\r\n      prevAddressRef.current = address;\r\n      return;\r\n    }\r\n\r\n    let cancelled = false;\r\n    const seq = ++fastSeqRef.current;\r\n    const { pageIndex, pageSize } = pagination;\r\n    const offset = Math.max(0, (newItemsCount || 0) + pageIndex * pageSize);\r\n    setIsFastLoading(true);\r\n    fetchWindow(offset, pageSize)\r\n      .then((data) => {\r\n        if (cancelled) return;\r\n        if (seq !== fastSeqRef.current) return;\r\n        setFastPageData(data);\r\n      })\r\n      .catch(() => {\r\n        // keep previous data if any; UI will show whatever is available\r\n      })\r\n      .finally(() => {\r\n        if (cancelled) return;\r\n        if (seq !== fastSeqRef.current) return;\r\n        setIsFastLoading(false);\r\n      });\r\n\r\n    return () => { cancelled = true; };\r\n  }, [fastModeActive, pagination.pageIndex, pagination.pageSize, newItemsCount, fetchWindow, address]);\r\n\r\n  return { fastModeActive, fastPageData, isFastLoading } as const;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-in-view.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-network-growth-24h.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-network-growth-aggregator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-nft-count-by-owner.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1359,1362],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1359,1362],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1364,1367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1364,1367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useState } from 'react';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { useQuery } from '@apollo/client';\r\nimport { NFTS_BY_OWNER_COUNT_QUERY } from '../data/nfts';\r\nimport { useAddressResolver } from './use-address-resolver';\r\n\r\nexport interface UseNftCountByOwnerReturn {\r\n  totalCount?: number;\r\n  isLoading: boolean;\r\n  error?: Error;\r\n}\r\n\r\nexport function useNftCountByOwner(owner: string | null | undefined): UseNftCountByOwnerReturn {\r\n  const { resolveEvmAddress } = useAddressResolver();\r\n  const [evmAddress, setEvmAddress] = useState<string | null>(null);\r\n  const [isResolving, setIsResolving] = useState(false);\r\n\r\n  useEffect(() => {\r\n    let active = true;\r\n    (async () => {\r\n      if (!owner) {\r\n        setEvmAddress(null);\r\n        return;\r\n      }\r\n      setIsResolving(true);\r\n      try {\r\n        const resolved = await resolveEvmAddress(owner);\r\n        if (!active) return;\r\n        setEvmAddress(resolved);\r\n      } catch {\r\n        if (!active) return;\r\n        setEvmAddress(null);\r\n      } finally {\r\n        if (active) setIsResolving(false);\r\n      }\r\n    })();\r\n    return () => {\r\n      active = false;\r\n    };\r\n  }, [owner, resolveEvmAddress]);\r\n\r\n  const { data, loading, error } = useQuery(\r\n    NFTS_BY_OWNER_COUNT_QUERY as unknown as TypedDocumentNode<any, any>,\r\n    {\r\n      variables: { owner: evmAddress },\r\n      skip: !evmAddress || isResolving,\r\n      fetchPolicy: 'cache-first',\r\n    }\r\n  );\r\n\r\n  const totalCount = useMemo(() => {\r\n    const v = data?.tokenHolders?.totalCount;\r\n    return typeof v === 'number' ? v : undefined;\r\n  }, [data]);\r\n\r\n  return {\r\n    totalCount,\r\n    isLoading: loading || isResolving,\r\n    error: error as Error | undefined,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-page-count.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-preview-playback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-reef-price-history.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_signal' is defined but never used.","line":34,"column":66,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":73},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3066,3069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3066,3069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useQuery } from '@tanstack/react-query';\r\nimport { TtlCache } from '@/data/ttl-cache';\r\n\r\nexport interface ReefPriceHistory {\r\n  // yyyy-mm-dd (UTC) -> usd price\r\n  byDate: Record<string, number>;\r\n  // available date range\r\n  startDate: string; // yyyy-mm-dd\r\n  endDate: string;   // yyyy-mm-dd\r\n}\r\n\r\nconst ENV = ((import.meta as unknown as { env?: Record<string, string | undefined> }).env) ?? {};\r\nconst DEFAULT_DAYS = 365;\r\n// CoinGecko market chart daily: returns prices as [ms, price]\r\n// We keep the URL configurable for self-hosted proxies\r\nconst HISTORY_URL_BASE: string = ENV.VITE_REEF_PRICE_HISTORY_URL_BASE || 'https://api.coingecko.com/api/v3/coins/reef/market_chart';\r\nconst CG_API_KEY: string | undefined = ENV.VITE_COINGECKO_API_KEY;\r\nconst CG_DEMO_KEY: string | undefined = ENV.VITE_COINGECKO_DEMO_KEY;\r\n\r\n// TTL cache to avoid repeated downloads\r\nconst HISTORY_TTL_MS = 6 * 60 * 60 * 1000; // 6 hours\r\nconst histCache = new TtlCache<ReefPriceHistory>({ namespace: 'reef:price:history', defaultTtlMs: HISTORY_TTL_MS, persist: true, maxSize: 4 });\r\nlet inflight: Promise<ReefPriceHistory | null> | null = null;\r\n\r\nfunction toDayUTC(ms: number): string {\r\n  return new Date(ms).toISOString().slice(0, 10);\r\n}\r\n\r\nfunction isJsonResponse(res: Response): boolean {\r\n  const ct = res.headers.get('content-type') || '';\r\n  return ct.includes('application/json');\r\n}\r\n\r\nasync function fetchHistory(days: number | 'max' = DEFAULT_DAYS, _signal?: AbortSignal): Promise<ReefPriceHistory | null> {\r\n  try {\r\n    const key = String(days);\r\n    const cached = histCache.get(key);\r\n    if (cached) return cached;\r\n    if (inflight) return await inflight;\r\n\r\n    inflight = (async () => {\r\n      const daysParamInitial = days === 'max' && !CG_API_KEY ? 365 : days; // Public API: max not allowed\r\n      let url = `${HISTORY_URL_BASE}?vs_currency=usd&days=${daysParamInitial}&interval=daily`;\r\n      const headers: Record<string, string> = { accept: 'application/json' };\r\n      if (CG_API_KEY) headers['x-cg-pro-api-key'] = CG_API_KEY;\r\n      if (CG_DEMO_KEY) headers['x-cg-demo-api-key'] = CG_DEMO_KEY;\r\n      // If no keys at all, CoinGecko may still work, otherwise we retry by adding query param for demo\r\n      let res = await fetch(url, { headers });\r\n      if (!res.ok && CG_DEMO_KEY) {\r\n        // Some environments require the demo key as query param\r\n        const demoDays = daysParamInitial;\r\n        url = `${HISTORY_URL_BASE}?vs_currency=usd&days=${demoDays}&interval=daily&x_cg_demo_api_key=${encodeURIComponent(CG_DEMO_KEY)}`;\r\n        res = await fetch(url, { headers });\r\n      }\r\n      // If still not ok and we tried 'max', fallback to 365\r\n      if (!res.ok && days === 'max') {\r\n        const fallbackUrl = `${HISTORY_URL_BASE}?vs_currency=usd&days=365&interval=daily`;\r\n        res = await fetch(fallbackUrl, { headers });\r\n      }\r\n      if (!res.ok) {\r\n        throw new Error(`CoinGecko history HTTP ${res.status}`);\r\n      }\r\n      if (!isJsonResponse(res)) return null;\r\n      const json = await res.json().catch(() => null) as any;\r\n      const prices: Array<[number, number]> = Array.isArray(json?.prices) ? json.prices : [];\r\n      const byDate: Record<string, number> = {};\r\n      for (const row of prices) {\r\n        const ts = Number(row?.[0]);\r\n        const price = Number(row?.[1]);\r\n        if (!Number.isFinite(ts) || !Number.isFinite(price)) continue;\r\n        const day = toDayUTC(ts);\r\n        byDate[day] = price;\r\n      }\r\n      const daysSorted = Object.keys(byDate).sort();\r\n      if (daysSorted.length === 0) return null;\r\n      const value: ReefPriceHistory = {\r\n        byDate,\r\n        startDate: daysSorted[0],\r\n        endDate: daysSorted[daysSorted.length - 1],\r\n      };\r\n      histCache.set(key, value);\r\n      return value;\r\n    })();\r\n\r\n    try {\r\n      return await inflight;\r\n    } finally {\r\n      inflight = null;\r\n    }\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function useReefPriceHistory(days: number | 'max' = DEFAULT_DAYS) {\r\n  const { data, isPending, isError } = useQuery<ReefPriceHistory | null>({\r\n    queryKey: ['reefPriceHistory', String(days), HISTORY_URL_BASE],\r\n    queryFn: ({ signal }) => fetchHistory(days, signal),\r\n    staleTime: HISTORY_TTL_MS,\r\n    gcTime: HISTORY_TTL_MS,\r\n    retry: 1,\r\n  });\r\n  return {\r\n    history: data?.byDate ?? null,\r\n    startDate: data?.startDate ?? null,\r\n    endDate: data?.endDate ?? null,\r\n    loading: isPending,\r\n    error: isError ? new Error('Failed to load REEF price history') : undefined,\r\n  } as const;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-reef-price.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_signal' is defined but never used.","line":39,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":38}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useQuery } from '@tanstack/react-query';\r\nimport { TtlCache } from '../data/ttl-cache';\r\n\r\ninterface ReefPrice {\r\n  usd: number;\r\n  usd_24h_change?: number;\r\n  timestamp?: number;\r\n}\r\n\r\nconst ENV = ((import.meta as unknown as { env?: Record<string, string | undefined> }).env) ?? {};\r\n// Default to CoinGecko simple price endpoint; allow override via env\r\nconst PRICE_URL: string = (ENV.VITE_REEF_PRICE_URL || 'https://api.coingecko.com/api/v3/simple/price?ids=reef&vs_currencies=usd&include_24hr_change=true');\r\nconst USD_MULTIPLIER: number = (() => {\r\n  try {\r\n    const raw = ENV.VITE_REEF_USD_MULTIPLIER;\r\n    const n = Number(raw);\r\n    return Number.isFinite(n) && n > 0 ? n : 1;\r\n  } catch {\r\n    return 1;\r\n  }\r\n})();\r\n\r\n// Module-level TTL cache and in-flight dedupe to avoid duplicate fetches in React 18 StrictMode\r\nconst PRICE_TTL_MS = 60_000; // 1 min\r\nconst priceTtl = new TtlCache<ReefPrice>({\r\n  namespace: 'reef:price',\r\n  defaultTtlMs: PRICE_TTL_MS,\r\n  persist: true,\r\n  maxSize: 8,\r\n});\r\nlet inflight: Promise<ReefPrice | null> | null = null;\r\nconst TTL_KEY = `usd:${USD_MULTIPLIER}`;\r\n\r\nfunction isJsonResponse(res: Response): boolean {\r\n  const ct = res.headers.get('content-type') || '';\r\n  return ct.includes('application/json');\r\n}\r\n\r\nasync function fetchReefPrice(_signal?: AbortSignal): Promise<ReefPrice | null> {\r\n  try {\r\n    // 1) Serve from TTL cache if available\r\n    const cached = priceTtl.get(TTL_KEY);\r\n    if (cached) return cached;\r\n\r\n    // 2) Coalesce concurrent calls\r\n    if (inflight) return await inflight;\r\n\r\n    inflight = (async () => {\r\n      // Intentionally do NOT attach AbortSignal to keep request alive across StrictMode remounts\r\n      const res = await fetch(PRICE_URL, { headers: { accept: 'application/json' } });\r\n    if (!res.ok || !isJsonResponse(res)) return null;\r\n    const json = (await res.json().catch(() => null)) as unknown;\r\n    if (!json || typeof json !== 'object') return null;\r\n\r\n    // Case 1: CoinGecko format: { reef: { usd: number, usd_24h_change?: number } }\r\n    {\r\n      const root = json as Record<string, unknown>;\r\n      const reef = root['reef'];\r\n      if (reef && typeof reef === 'object') {\r\n        const obj = reef as Record<string, unknown>;\r\n        const usd = Number(obj['usd']);\r\n        const change = Number(obj['usd_24h_change']);\r\n        if (Number.isFinite(usd)) {\r\n          const value: ReefPrice = { usd: usd * USD_MULTIPLIER, usd_24h_change: Number.isFinite(change) ? change : undefined, timestamp: Date.now() };\r\n          priceTtl.set(TTL_KEY, value);\r\n          return value;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Case 2: Reefscan flat format: { usd: number, usd_24h_change?: number, timestamp?: number }\r\n    {\r\n      const j = json as Record<string, unknown>;\r\n      const usd = Number(j['usd']);\r\n      if (Number.isFinite(usd)) {\r\n        const change = Number(j['usd_24h_change']);\r\n        const ts = Number(j['timestamp']);\r\n        const value: ReefPrice = { usd: usd * USD_MULTIPLIER, usd_24h_change: Number.isFinite(change) ? change : undefined, timestamp: Number.isFinite(ts) ? ts : Date.now() };\r\n        priceTtl.set('usd', value);\r\n        return value;\r\n      }\r\n    }\r\n    return null;\r\n    })();\r\n    try {\r\n      return await inflight;\r\n    } finally {\r\n      inflight = null;\r\n    }\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function useReefPrice() {\r\n  const { data, isPending, isError } = useQuery<ReefPrice | null>({\r\n    queryKey: ['reefPrice', PRICE_URL, USD_MULTIPLIER],\r\n    queryFn: ({ signal }) => fetchReefPrice(signal),\r\n    staleTime: 60_000, // 1 minute\r\n    gcTime: 5 * 60_000, // 5 minutes\r\n    retry: 1,\r\n  });\r\n  return { price: data ?? null, loading: isPending, error: isError ? new Error('Failed to load REEF price') : undefined } as const;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-squid-health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-sqwid-collection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-sqwid-collections-by-owner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-sqwid-nfts-infinite.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-sqwid-nfts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-staking-rewards-series.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2334,2337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2334,2337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3020,3023],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3020,3023],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3222,3225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3222,3225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":110,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4041,4044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4041,4044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useState } from 'react';\r\nimport { useQuery } from '@tanstack/react-query';\r\nimport { apolloClient } from '@/apollo-client';\r\nimport { STAKINGS_CONNECTION_QUERY, STAKINGS_LIST_MIN_QUERY } from '@/data/staking';\r\nimport { useAddressResolver } from './use-address-resolver';\r\n\r\ninterface RawReward {\r\n  id: string;\r\n  amount: string; // base units (18)\r\n  timestamp: string;\r\n}\r\n\r\nexport interface DailyPoint {\r\n  date: string; // YYYY-MM-DD (UTC)\r\n  ts: number;   // UTC midnight timestamp (ms)\r\n  sumReef: number;\r\n}\r\n\r\nexport interface RewardsSeriesResult {\r\n  daily: DailyPoint[];\r\n  cumulative: DailyPoint[]; // cumulativeReef per date\r\n  loading: boolean;\r\n  error?: Error;\r\n  totalCount: number;\r\n}\r\n\r\nfunction toUtcDay(ts: string): string {\r\n  const d = new Date(ts);\r\n  if (Number.isNaN(d.getTime())) return '1970-01-01';\r\n  return d.toISOString().slice(0, 10);\r\n}\r\n\r\nfunction amountToReef(amount: string): number {\r\n  try {\r\n    const bi = BigInt(amount);\r\n    // 18 decimals -> keep ~4 decimals safely: divide by 1e14 (BigInt) then by 1e4 as float (total 1e18)\r\n    return Number(bi / 100000000000000n) / 1e4;\r\n  } catch {\r\n    return 0;\r\n  }\r\n}\r\n\r\ntype RangeKey = '30d' | '90d' | '180d' | '365d' | 'all';\r\n\r\nfunction getDays(key: RangeKey): number | null {\r\n  switch (key) {\r\n    case '30d': return 30;\r\n    case '90d': return 90;\r\n    case '180d': return 180;\r\n    case '365d': return 365;\r\n    default: return null; // all\r\n  }\r\n}\r\n\r\nasync function fetchRewards(nativeAddress: string, range: RangeKey): Promise<{ items: RawReward[]; totalCount: number }> {\r\n  // 1) get totalCount\r\n  // If range != all, compute [from, to] anchored at today (UTC midnight) — removes extra RTT\r\n  let from: string | undefined;\r\n  let to: string | undefined;\r\n  const days = getDays(range);\r\n  if (days) {\r\n    const todayUtcMid = new Date(new Date().toISOString().slice(0, 10) + 'T00:00:00.000Z');\r\n    const lastMs = todayUtcMid.getTime();\r\n    const fromMs = lastMs - (days - 1) * 24 * 60 * 60 * 1000;\r\n    const toMs = lastMs + 24 * 60 * 60 * 1000 - 1; // end of today\r\n    from = new Date(fromMs).toISOString();\r\n    to = new Date(toMs).toISOString();\r\n  }\r\n\r\n  let totalCount: number | undefined = undefined;\r\n  if (!days) {\r\n    const conn = await apolloClient.query({ query: STAKINGS_CONNECTION_QUERY as any, variables: { accountId: nativeAddress, from, to }, fetchPolicy: 'network-only' });\r\n    totalCount = (conn?.data?.stakingsConnection?.totalCount ?? 0) as number;\r\n    if (!totalCount) return { items: [], totalCount: 0 };\r\n  }\r\n\r\n  // Adaptive paging to respect Subsquid response size limits\r\n  // For filtered windows pick conservative page size to avoid squid size-limit retries\r\n  // Start small (40) and, если страница пришла полной, удваиваем до 80/160/240\r\n  let pageSize = days ? 40 : 200;\r\n  const minPage = 20;\r\n  const items: RawReward[] = [];\r\n  for (let offset = 0; ; ) {\r\n    try {\r\n      const q = await apolloClient.query({\r\n        query: STAKINGS_LIST_MIN_QUERY as any,\r\n        variables: { accountId: nativeAddress, first: pageSize, after: offset, from, to },\r\n        fetchPolicy: 'network-only',\r\n      });\r\n      const chunk = (q?.data?.stakings ?? []) as Array<any>;\r\n      if (!Array.isArray(chunk) || chunk.length === 0) {\r\n        // Avoid infinite loop on unexpected empty page\r\n        break;\r\n      }\r\n      for (const s of chunk) {\r\n        items.push({ id: String(s.id), amount: String(s.amount), timestamp: String(s.timestamp) });\r\n      }\r\n      const currentPageSize = pageSize;\r\n      offset += chunk.length;\r\n      // Break conditions / growth for filtered window\r\n      if (days) {\r\n        if (chunk.length < currentPageSize) {\r\n          break; // last page retrieved\r\n        }\r\n        // full page -> try to grow for the next request\r\n        pageSize = Math.min(currentPageSize * 2, 240);\r\n      }\r\n      // For ALL: stop when we know we've reached totalCount\r\n      if (!days && typeof totalCount === 'number' && offset >= totalCount) break;\r\n    } catch (e: any) {\r\n      const msg = (e?.message || '').toString();\r\n      const isSize = msg.includes('size limit') || msg.includes('exceed');\r\n      if (isSize && pageSize > minPage) {\r\n        pageSize = Math.max(minPage, Math.floor(pageSize / 2));\r\n        // retry same offset with smaller pageSize on next loop iteration\r\n        continue;\r\n      }\r\n      throw e;\r\n    }\r\n  }\r\n  // Data comes newest first; optional normalize order later per day\r\n  return { items, totalCount: typeof totalCount === 'number' ? totalCount : items.length };\r\n}\r\n\r\nexport function useStakingRewardsSeries(accountAddress: string | null | undefined, rangeKey: RangeKey = 'all'): RewardsSeriesResult {\r\n  const { resolveAddress } = useAddressResolver();\r\n  const [native, setNative] = useState<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    let cancelled = false;\r\n    (async () => {\r\n      try {\r\n        if (!accountAddress) { setNative(null); return; }\r\n        const addr = await resolveAddress(accountAddress);\r\n        if (!cancelled) setNative(addr);\r\n      } catch {\r\n        if (!cancelled) setNative(null);\r\n      }\r\n    })();\r\n    return () => { cancelled = true; };\r\n  }, [accountAddress, resolveAddress]);\r\n\r\n  const { data, isPending, isError, error } = useQuery<{ items: RawReward[]; totalCount: number}>({\r\n    queryKey: ['stakingSeries', native, rangeKey],\r\n    enabled: !!native,\r\n    queryFn: async () => {\r\n      if (!native) return { items: [], totalCount: 0 };\r\n      return await fetchRewards(native, rangeKey);\r\n    },\r\n    staleTime: 5 * 60_000,\r\n    gcTime: 15 * 60_000,\r\n    retry: 1,\r\n  });\r\n\r\n  const daily = useMemo<DailyPoint[]>(() => {\r\n    const map = new Map<string, number>();\r\n    const arr = data?.items ?? [];\r\n    for (const r of arr) {\r\n      const day = toUtcDay(r.timestamp);\r\n      const reef = amountToReef(r.amount);\r\n      map.set(day, (map.get(day) ?? 0) + reef);\r\n    }\r\n    const out: DailyPoint[] = Array.from(map.entries()).map(([date, sumReef]) => ({ date, ts: new Date(`${date}T00:00:00Z`).getTime(), sumReef }));\r\n    out.sort((a, b) => a.ts - b.ts);\r\n    return out;\r\n  }, [data]);\r\n\r\n  const cumulative = useMemo<DailyPoint[]>(() => {\r\n    let acc = 0;\r\n    return daily.map((p) => { acc += p.sumReef; return { date: p.date, ts: p.ts, sumReef: acc }; });\r\n  }, [daily]);\r\n\r\n  // Note: background prefetch of 'all' disabled to avoid лишняя нагрузка сети и задержки\r\n\r\n  return {\r\n    daily,\r\n    cumulative,\r\n    loading: isPending,\r\n    error: isError ? (error as Error) : undefined,\r\n    totalCount: data?.totalCount ?? 0,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-swap-events.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3440,3443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3440,3443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5348,5351],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5348,5351],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":137,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":137,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6011,6011],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6214,6217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6214,6217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6251,6254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6251,6254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":172,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":172,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[7775,7775],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":179,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":179,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[8064,8064],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":203,"column":19,"nodeType":"BlockStatement","messageId":"unexpected","endLine":203,"endColumn":21,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[9249,9249],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":206,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":206,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[9304,9304],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":236,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10819,10822],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10819,10822],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'enabled' and 'historyClient'. Either include them or remove the dependency array.","line":255,"column":6,"nodeType":"ArrayExpression","endLine":255,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [client, enabled, historyClient, pageSize, resolvedUser]","fix":{"range":[11849,11881],"text":"[client, enabled, historyClient, pageSize, resolvedUser]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":312,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14333,14336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14333,14336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'enabled'. Either include it or remove the dependency array.","line":319,"column":6,"nodeType":"ArrayExpression","endLine":319,"endColumn":41,"suggestions":[{"desc":"Update the dependencies array to be: [resolvedUser, pageSize, fetchPage, enabled]","fix":{"range":[14554,14589],"text":"[resolvedUser, pageSize, fetchPage, enabled]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":355,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16127,16130],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16127,16130],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'enabled'. Either include it or remove the dependency array.","line":361,"column":6,"nodeType":"ArrayExpression","endLine":361,"endColumn":47,"suggestions":[{"desc":"Update the dependencies array to be: [enabled, hasMore, fetchPage, after]","fix":{"range":[16264,16305],"text":"[enabled, hasMore, fetchPage, after]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":370,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16597,16600],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16597,16600],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'enabled'. Either include it or remove the dependency array.","line":391,"column":6,"nodeType":"ArrayExpression","endLine":391,"endColumn":51,"suggestions":[{"desc":"Update the dependencies array to be: [items?.length, pageSize, hasMore, fetchMore, enabled]","fix":{"range":[17398,17443],"text":"[items?.length, pageSize, hasMore, fetchMore, enabled]"}}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { safeBigInt } from '@/utils/token-helpers';\r\nimport { useEffect, useState, useCallback, useRef } from 'react';\r\nimport type { UiTransfer } from '@/data/transfer-mapper';\r\nimport { reefSwapClient } from '@/reef-swap-client';\r\nimport { fetchAnyTransferIndicesOnce } from '@/data/transfers';\r\nimport { POOL_EVENTS_CONNECTION_DOCUMENT } from '@/data/reef-swap';\r\nimport type { ApolloClient, NormalizedCacheObject } from '@apollo/client';\r\nimport { useApolloClient } from '@apollo/client';\r\nimport { useAddressResolver } from './use-address-resolver';\r\nimport { isValidEvmAddressFormat } from '@/utils/address-helpers';\r\n\r\nexport interface UseSwapEventsReturn {\r\n  items: UiTransfer[];\r\n  loading: boolean;\r\n  error?: Error;\r\n  hasMore: boolean;\r\n  fetchMore: () => Promise<void>;\r\n}\r\n\r\n// Env knobs to control network load\r\nconst ENV = ((import.meta as unknown as { env?: Record<string, string | undefined> }).env) ?? {};\r\n// Prefetch eventIndex via transfers endpoint for better Reefscan links.\r\n// Disabled by default to minimize network requests.\r\nconst PREFETCH_EVENT_INDEX = ENV.VITE_PREFETCH_EVENT_INDEX === 'true';\r\n// Safety cap per page when prefetch enabled\r\nconst PREFETCH_EVENT_CAP = Math.max(0, Math.min(50, Number(ENV.VITE_PREFETCH_EVENT_CAP ?? '0')));\r\n\r\n\r\nexport function useSwapEvents(address: string | null, pageSize: number, enabled: boolean = true): UseSwapEventsReturn {\r\n  const client = reefSwapClient as ApolloClient<NormalizedCacheObject>;\r\n  const historyClient = useApolloClient() as ApolloClient<NormalizedCacheObject>;\r\n  const { resolveEvmAddress } = useAddressResolver();\r\n  const [items, setItems] = useState<UiTransfer[]>([]);\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<Error | undefined>(undefined);\r\n  const [after, setAfter] = useState<string | null>(null);\r\n  const [hasMore, setHasMore] = useState<boolean>(false);\r\n  const [resolvedUser, setResolvedUser] = useState<string>(address || '');\r\n  const initInFlightRef = useRef(false);\r\n  const fetchMoreInFlightRef = useRef(false);\r\n  const initKeyRef = useRef<string | null>(null);\r\n\r\n  // Resolve substrate to EVM address (reef-swap uses EVM addresses)\r\n  useEffect(() => {\r\n    let cancelled = false;\r\n    (async () => {\r\n      try {\r\n        if (!address) { if (!cancelled) setResolvedUser(''); return; }\r\n        const evm = await resolveEvmAddress(address);\r\n        if (!cancelled) setResolvedUser(evm || address);\r\n      } catch {\r\n        if (!cancelled) setResolvedUser(address || '');\r\n      }\r\n    })();\r\n    return () => { cancelled = true; };\r\n  }, [address, resolveEvmAddress]);\r\n\r\n  const fetchPage = useCallback(async (afterCursor: string | null) => {\r\n    if (!enabled) {\r\n      return { page: [] as UiTransfer[], pageInfo: { hasNextPage: false, endCursor: null as string | null } };\r\n    }\r\n    // Use the adapter-provided pageSize directly (can be 20 in swap-only mode)\r\n    const first = Math.min(100, Math.max(pageSize, 15));\r\n    if (!isValidEvmAddressFormat(resolvedUser)) {\r\n      return { page: [] as UiTransfer[], pageInfo: { hasNextPage: false, endCursor: null as string | null } };\r\n    }\r\n    const { data } = await client.query({\r\n      query: POOL_EVENTS_CONNECTION_DOCUMENT,\r\n      variables: { first, after: afterCursor, addr: resolvedUser },\r\n      fetchPolicy: 'no-cache',\r\n    });\r\n    const edges = (data?.poolEventsConnection?.edges ?? []) as Array<{ node: any; cursor: string }>;\r\n    // Aggregate two legs of the same swap into a single UI row by base id or (blockHeight,indexInBlock)\r\n    const groups = new Map<string, {\r\n      key: string;\r\n      from: string;\r\n      to: string;\r\n      token1: { id: string; name: string; decimals: number };\r\n      token2: { id: string; name: string; decimals: number };\r\n      blockHeight: number;\r\n      indexInBlock: number;\r\n      timestamp?: string | number | null;\r\n      eventIndex?: number;\r\n      seen: number;\r\n      hasInputs: boolean;\r\n      // Explicit sold/bought tracking inferred from inputs/outputs\r\n      soldIndex?: 1 | 2; // 1 -> token1, 2 -> token2\r\n      boughtIndex?: 1 | 2;\r\n      soldBI: bigint;\r\n      boughtBI: bigint;\r\n      // Legacy accumulators (kept for fallback when inputs are missing)\r\n      a1BI: bigint; // corresponds to token2\r\n      a2BI: bigint; // corresponds to token1\r\n    }>();\r\n    for (const e of edges) {\r\n      const n = e?.node;\r\n      if (!n || String(n?.type) !== 'Swap') continue;\r\n      const from = String(n?.senderAddress || '');\r\n      const to = String(n?.toAddress || '');\r\n      // Prefer grouping by id base: strip the last numeric segment (…-00001, …-00002) -> same swap\r\n      const rawId = String(n?.id || '');\r\n      const m = /^(.+)-(\\d+)$/.exec(rawId);\r\n      const key = m ? m[1] : `${n?.blockHeight}-${n?.indexInBlock}`;\r\n      const token1 = n?.pool?.token1;\r\n      const token2 = n?.pool?.token2;\r\n      if (!token1 || !token2) continue;\r\n      let g = groups.get(key);\r\n      if (!g) {\r\n        g = {\r\n          key,\r\n          from,\r\n          to,\r\n          token1: { id: token1.id, name: token1.name, decimals: token1.decimals },\r\n          token2: { id: token2.id, name: token2.name, decimals: token2.decimals },\r\n          blockHeight: Number(n?.blockHeight || 0),\r\n          indexInBlock: Number(n?.indexInBlock || 0),\r\n          timestamp: (n as any)?.timestamp ?? null,\r\n          eventIndex: undefined,\r\n          seen: 0,\r\n          hasInputs: false,\r\n          soldIndex: undefined,\r\n          boughtIndex: undefined,\r\n          soldBI: 0n,\r\n          boughtBI: 0n,\r\n          a1BI: 0n,\r\n          a2BI: 0n,\r\n        };\r\n        groups.set(key, g);\r\n      }\r\n      // derive event index from the last numeric segment of id if present\r\n      try {\r\n        const evStr = (m?.[2] ?? rawId.match(/-(\\d+)$/)?.[1]) as string | undefined;\r\n        const ev = evStr ? Number(evStr) : NaN;\r\n        if (Number.isFinite(ev)) {\r\n          g.eventIndex = Math.max(g.eventIndex ?? -1, ev);\r\n        }\r\n      } catch {}\r\n      // preserve first observed from/to, but if empty, try to fill from subsequent legs\r\n      if (!g.from && from) g.from = from;\r\n      if (!g.to && to) g.to = to;\r\n      if (!g.timestamp && (n as any)?.timestamp) g.timestamp = (n as any).timestamp;\r\n      g.seen += 1;\r\n      // Prefer explicit input fields when available.\r\n      // amountIn1 -> input of token1, amountIn2 -> input of token2\r\n      // amount1  -> output of token1, amount2  -> output of token2 (per reef-explorer schema)\r\n      const in1 = safeBigInt(n?.amountIn1, true);\r\n      const in2 = safeBigInt(n?.amountIn2, true);\r\n      const out1 = safeBigInt(n?.amount1, true);\r\n      const out2 = safeBigInt(n?.amount2, true);\r\n      if (in1 > 0n || in2 > 0n) {\r\n        g.hasInputs = true;\r\n        if (in1 > 0n) {\r\n          // Sold token1 for token2\r\n          g.soldIndex = 1; if (in1 > g.soldBI) g.soldBI = in1;\r\n          g.boughtIndex = 2; if (out2 > g.boughtBI) g.boughtBI = out2;\r\n        } else {\r\n          // Sold token2 for token1\r\n          g.soldIndex = 2; if (in2 > g.soldBI) g.soldBI = in2;\r\n          g.boughtIndex = 1; if (out1 > g.boughtBI) g.boughtBI = out1;\r\n        }\r\n        // Keep legacy accumulators for compatibility\r\n        if (out2 > g.a1BI) g.a1BI = out2; // token2 output when token1 input\r\n        if (out1 > g.a2BI) g.a2BI = out1; // token1 output when token2 input\r\n      } else {\r\n        // Fallback for older schemas without inputs: treat amount1/amount2 as outputs\r\n        try {\r\n          if (n?.amount1 !== undefined && n?.amount1 !== null) {\r\n            const a = safeBigInt(n.amount1, true);\r\n            if (a > g.boughtBI) { g.boughtIndex = 1; g.boughtBI = a; }\r\n            if (a > g.a1BI) g.a1BI = a; // legacy\r\n          }\r\n        } catch {}\r\n        try {\r\n          if (n?.amount2 !== undefined && n?.amount2 !== null) {\r\n            const a = safeBigInt(n.amount2, true);\r\n            if (a > g.boughtBI) { g.boughtIndex = 2; g.boughtBI = a; }\r\n            if (a > g.a2BI) g.a2BI = a; // legacy\r\n          }\r\n        } catch {}\r\n      }\r\n    }\r\n    // No legacy hydration: rely on amountIn*/amount* present in reef-swap schema\r\n\r\n    // Optional: resolve accurate transfer eventIndex via transfers endpoint (batched would be better).\r\n    // Kept behind env flag to avoid extra network load by default.\r\n    if (PREFETCH_EVENT_INDEX && PREFETCH_EVENT_CAP > 0) {\r\n      try {\r\n        let resolved = 0;\r\n        for (const g of groups.values()) {\r\n          if (resolved >= PREFETCH_EVENT_CAP) break;\r\n          const hasBI = Number.isFinite(g.blockHeight) && Number.isFinite(g.indexInBlock);\r\n          if (!hasBI) continue;\r\n          // Skip if we already have a plausible small eventIndex (< 10)\r\n          if (typeof g.eventIndex === 'number' && Number.isFinite(g.eventIndex) && g.eventIndex >= 0 && g.eventIndex < 10) continue;\r\n          try {\r\n            const res = await fetchAnyTransferIndicesOnce(historyClient, {\r\n              height: Number(g.blockHeight),\r\n              index: Number(g.indexInBlock),\r\n            });\r\n            if (res?.eventIndex != null && Number.isFinite(Number(res.eventIndex))) {\r\n              g.eventIndex = Number(res.eventIndex);\r\n            }\r\n          } catch {}\r\n          resolved += 1;\r\n        }\r\n      } catch {}\r\n    }\r\n\r\n    const page = Array.from(groups.values()).map(g => {\r\n      // Prefer explicit sold/bought when inputs were present; else fallback to legacy accumulators\r\n      const soldIdx: 1 | 2 = (g.soldIndex ?? (g.boughtIndex === 1 ? 2 : 1)) as 1 | 2;\r\n      const boughtIdx: 1 | 2 = (g.boughtIndex ?? (soldIdx === 1 ? 2 : 1)) as 1 | 2;\r\n      const soldAmt = (g.hasInputs ? g.soldBI : (soldIdx === 1 ? g.a2BI : g.a1BI)).toString();\r\n      const boughtAmt = (g.hasInputs ? g.boughtBI : (boughtIdx === 2 ? g.a1BI : g.a2BI)).toString();\r\n      const soldTok = soldIdx === 1 ? g.token1 : g.token2;\r\n      const boughtTok = boughtIdx === 2 ? g.token2 : g.token1;\r\n\r\n      const eventIndex = typeof g.eventIndex === 'number' && Number.isFinite(g.eventIndex) ? g.eventIndex : undefined;\r\n      const extrinsicId = Number.isFinite(g.blockHeight) && Number.isFinite(g.indexInBlock)\r\n        ? `${Number(g.blockHeight)}-${Number(g.indexInBlock)}`\r\n        : undefined;\r\n      const preferredTransferId = (extrinsicId && eventIndex != null)\r\n        ? `${Number(g.blockHeight)}-${Number(g.indexInBlock)}-${eventIndex}`\r\n        : undefined;\r\n\r\n      const t: UiTransfer = {\r\n        id: `${g.key}:swap`,\r\n        from: g.from,\r\n        to: g.to,\r\n        type: 'SWAP',\r\n        method: 'swap',\r\n        amount: boughtAmt,\r\n        isNft: false,\r\n        tokenId: null,\r\n        token: { id: boughtTok.id, name: boughtTok.name, decimals: boughtTok.decimals },\r\n        timestamp: (g.timestamp ?? String(g.blockHeight)) as any,\r\n        success: true,\r\n        extrinsicHash: '',\r\n        // Provide minimal positioning + identity for Reefscan link\r\n        blockHeight: Number.isFinite(g.blockHeight) ? Number(g.blockHeight) : undefined,\r\n        extrinsicIndex: Number.isFinite(g.indexInBlock) ? Number(g.indexInBlock) : undefined,\r\n        eventIndex,\r\n        extrinsicId,\r\n        swapInfo: {\r\n          sold:   { amount: soldAmt,   token: { id: soldTok.id,   name: soldTok.name,   decimals: soldTok.decimals } },\r\n          bought: { amount: boughtAmt, token: { id: boughtTok.id, name: boughtTok.name, decimals: boughtTok.decimals } },\r\n          preferredTransferId: preferredTransferId,\r\n        },\r\n      };\r\n      return t;\r\n    });\r\n    const pageInfoRaw = (data?.poolEventsConnection?.pageInfo ?? {}) as { hasNextPage?: boolean; endCursor?: string | null };\r\n    const nextHas = !!pageInfoRaw?.hasNextPage && (edges.length >= first);\r\n    return { page, pageInfo: { hasNextPage: nextHas, endCursor: pageInfoRaw?.endCursor ?? null } };\r\n  }, [client, pageSize, resolvedUser]);\r\n\r\n  // initial load: run once per (resolvedUser,pageSize); scan up to 5 pages to fill one UI page\r\n  useEffect(() => {\r\n    if (!enabled) return;\r\n    if (!resolvedUser) return;\r\n    const key = `${String(resolvedUser).toLowerCase()}|${pageSize}`;\r\n    if (initKeyRef.current === key || initInFlightRef.current) return;\r\n    initInFlightRef.current = true;\r\n    initKeyRef.current = key;\r\n    let cancelled = false;\r\n    setItems([]);\r\n    setAfter(null);\r\n    setHasMore(false);\r\n    setError(undefined);\r\n    setLoading(true);\r\n    if (!isValidEvmAddressFormat(resolvedUser)) {\r\n      setLoading(false);\r\n      // Important: reset init flags so effect can rerun after resolver maps Substrate->EVM\r\n      initInFlightRef.current = false;\r\n      initKeyRef.current = null;\r\n      return;\r\n    }\r\n    (async () => {\r\n      const MAX_PAGES = 3; // fewer pages for faster initial load\r\n      let curAfter: string | null = null;\r\n      const map = new Map<string, UiTransfer>();\r\n      let lastInfo: { hasNextPage?: boolean; endCursor?: string | null } = {};\r\n      try {\r\n        for (let i = 0; i < MAX_PAGES; i++) {\r\n          const { page, pageInfo } = await fetchPage(curAfter);\r\n          for (const x of page) {\r\n            const prev = map.get(x.id);\r\n            if (!prev) { map.set(x.id, x); continue; }\r\n            try {\r\n              const s = (prev.swapInfo?.sold?.amount ?? '0');\r\n              const b = (prev.swapInfo?.bought?.amount ?? '0');\r\n              const s2 = (x.swapInfo?.sold?.amount ?? '0');\r\n              const b2 = (x.swapInfo?.bought?.amount ?? '0');\r\n              const sAbs = safeBigInt(s, true);\r\n              const s2Abs = safeBigInt(s2, true);\r\n              const bAbs = safeBigInt(b, true);\r\n              const b2Abs = safeBigInt(b2, true);\r\n              const sold = (s2Abs > sAbs ? s2Abs : sAbs).toString();\r\n              const bought = (b2Abs > bAbs ? b2Abs : bAbs).toString();\r\n              prev.swapInfo!.sold.amount = sold;\r\n              prev.swapInfo!.bought.amount = bought;\r\n              prev.amount = bought;\r\n            } catch { /* ignore merge errors */ }\r\n          }\r\n          lastInfo = pageInfo;\r\n          curAfter = pageInfo.endCursor ?? null;\r\n          if (map.size >= pageSize || !pageInfo.hasNextPage) break;\r\n        }\r\n        setItems(Array.from(map.values()));\r\n        setAfter(lastInfo.endCursor ?? null);\r\n        setHasMore(!!lastInfo.hasNextPage);\r\n      } catch (e: any) {\r\n        if (!cancelled) setError(e as Error);\r\n      } finally {\r\n        if (!cancelled) { setLoading(false); initInFlightRef.current = false; }\r\n      }\r\n    })();\r\n    return () => { cancelled = true; };\r\n  }, [resolvedUser, pageSize, fetchPage]);\r\n\r\n  const fetchMore = useCallback(async () => {\r\n    if (!enabled) return;\r\n    if (!hasMore) return;\r\n    if (fetchMoreInFlightRef.current) return;\r\n    fetchMoreInFlightRef.current = true;\r\n    setLoading(true);\r\n    try {\r\n      const { page, pageInfo } = await fetchPage(after);\r\n      setItems(prev => {\r\n        const map = new Map<string, UiTransfer>();\r\n        for (const p of (Array.isArray(prev) ? prev : [])) map.set(p.id, { ...p });\r\n        for (const x of page) {\r\n          const prevItem = map.get(x.id);\r\n          if (!prevItem) { map.set(x.id, x); continue; }\r\n          try {\r\n            const s = (prevItem.swapInfo?.sold?.amount ?? '0');\r\n            const b = (prevItem.swapInfo?.bought?.amount ?? '0');\r\n            const s2 = (x.swapInfo?.sold?.amount ?? '0');\r\n            const b2 = (x.swapInfo?.bought?.amount ?? '0');\r\n            const sAbs = safeBigInt(s, true);\r\n            const s2Abs = safeBigInt(s2, true);\r\n            const bAbs = safeBigInt(b, true);\r\n            const b2Abs = safeBigInt(b2, true);\r\n            const sold = (s2Abs > sAbs ? s2Abs : sAbs).toString();\r\n            const bought = (b2Abs > bAbs ? b2Abs : bAbs).toString();\r\n            prevItem.swapInfo!.sold.amount = sold;\r\n            prevItem.swapInfo!.bought.amount = bought;\r\n            prevItem.amount = bought;\r\n          } catch { /* ignore merge errors */ }\r\n        }\r\n        return Array.from(map.values());\r\n      });\r\n      setAfter(pageInfo.endCursor);\r\n      setHasMore(pageInfo.hasNextPage);\r\n    } catch (e: any) {\r\n      setError(e as Error);\r\n    } finally {\r\n      setLoading(false);\r\n      fetchMoreInFlightRef.current = false;\r\n    }\r\n  }, [after, hasMore, fetchPage, resolvedUser]);\r\n\r\n  // Background idle scan: top-up until we have one UI page or run out of data (hard cap)\r\n  useEffect(() => {\r\n    if (!enabled) return;\r\n    if (!hasMore) return;\r\n    if ((items?.length || 0) >= pageSize) return;\r\n    let cancelled = false;\r\n    let attempts = 0;\r\n    const winAny: any = typeof window !== 'undefined' ? window : {};\r\n    const schedule = () => {\r\n      if (cancelled) return;\r\n      if (fetchMoreInFlightRef.current) return;\r\n      if (!hasMore) return;\r\n      if (attempts >= 10) return; // cap background scans\r\n      attempts += 1;\r\n      fetchMore().catch(() => {});\r\n    };\r\n    let idleId: number | undefined;\r\n    let timerId: number | undefined;\r\n    if (typeof winAny.requestIdleCallback === 'function') {\r\n      idleId = winAny.requestIdleCallback(schedule, { timeout: 300 });\r\n    } else {\r\n      timerId = window.setTimeout(schedule, 100);\r\n    }\r\n    return () => {\r\n      cancelled = true;\r\n      if (idleId && typeof winAny.cancelIdleCallback === 'function') winAny.cancelIdleCallback(idleId);\r\n      if (timerId) clearTimeout(timerId);\r\n    };\r\n  }, [items?.length, pageSize, hasMore, fetchMore]);\r\n\r\n  return { items, loading, error, hasMore, fetchMore };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-swap-partner-legs.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[363,366],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[363,366],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[598,601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[598,601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[911,914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[911,914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[953,956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[953,956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1300,1303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1300,1303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1523,1526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1523,1526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1528,1531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1528,1531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1782,1785],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1782,1785],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1862,1865],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1862,1865],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2235,2238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2235,2238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { ApolloClient, NormalizedCacheObject, TypedDocumentNode, useApolloClient } from '@apollo/client';\r\nimport { getString } from '@/utils/object';\r\nimport { TRANSFERS_POLLING_QUERY } from '../data/transfers';\r\nimport { identifyMissingPartnerHashes } from '@/utils/transfer-helpers';\r\n\r\ninterface Props {\r\n  data: any;\r\n  swapOnly: boolean;\r\n  enabled: boolean;\r\n}\r\n\r\nexport function useSwapPartnerLegs({ data, swapOnly, enabled }: Props) {\r\n  const client = useApolloClient();\r\n  const [partnersByHash, setPartnersByHash] = useState<Record<string, any[]>>({});\r\n\r\n  useEffect(() => {\r\n    if (!enabled) {\r\n      setPartnersByHash({});\r\n    }\r\n  }, [enabled]);\r\n\r\n  useEffect(() => {\r\n    const wantPartners = !!swapOnly && enabled;\r\n    if (!wantPartners) return;\r\n    \r\n    const edges = data?.transfersConnection.edges || [];\r\n    const nodes = edges.map((e: any) => e?.node).filter(Boolean) as Array<any>;\r\n    if (nodes.length === 0) return;\r\n\r\n    const alreadyLoadedHashes = new Set(Object.keys(partnersByHash));\r\n    const missing = identifyMissingPartnerHashes(nodes, alreadyLoadedHashes);\r\n    \r\n    if (missing.length === 0) return;\r\n    const missingLimited = missing.slice(0, 20);\r\n\r\n    (async () => {\r\n      try {\r\n        const where: any = { extrinsicHash_in: missingLimited };\r\n        const { data: q } = await (client as ApolloClient<NormalizedCacheObject>).query(\r\n          {\r\n            query: TRANSFERS_POLLING_QUERY as unknown as TypedDocumentNode<any, any>,\r\n            variables: {\r\n              where,\r\n              limit: Math.min(missingLimited.length * 10, 400),\r\n            },\r\n            fetchPolicy: 'network-only',\r\n          }\r\n        );\r\n        const list = (q?.transfers || []) as Array<any>;\r\n        if (!list.length) return;\r\n        const grouped: Record<string, any[]> = {};\r\n        for (const t of list) {\r\n          const h = getString(t, ['extrinsicHash']);\r\n          if (!h) continue;\r\n          (grouped[h] = grouped[h] || []).push(t);\r\n        }\r\n        setPartnersByHash((prev) => {\r\n          const next = { ...prev };\r\n          for (const [h, arr] of Object.entries(grouped)) {\r\n            if (!next[h]) next[h] = arr as any[];\r\n          }\r\n          return next;\r\n        });\r\n      } catch (e) {\r\n        console.warn('[tx][partners] fetch failed', e);\r\n      }\r\n    })();\r\n  }, [client, data, swapOnly, enabled, partnersByHash]);\r\n\r\n  return { partnersByHash, setPartnersByHash };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-token-balances.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1395,1398],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1395,1398],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1400,1403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1400,1403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1704,1707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1704,1707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useState } from 'react';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { useQuery } from '@apollo/client';\r\nimport { TOKEN_HOLDERS_PAGED_QUERY, mapTokenHoldersToUiBalances, type UiTokenBalance } from '@/data/balances';\r\nimport { useAddressResolver } from './use-address-resolver';\r\n\r\nexport interface UseTokenBalancesReturn {\r\n  balances: UiTokenBalance[];\r\n  loading: boolean;\r\n  error?: Error;\r\n  totalCount?: number;\r\n}\r\n\r\nexport function useTokenBalances(address: string | null | undefined, first = 50): UseTokenBalancesReturn {\r\n  const { resolveAddress } = useAddressResolver();\r\n  const [resolved, setResolved] = useState<string | null>(null);\r\n  const [isResolving, setIsResolving] = useState(false);\r\n\r\n  useEffect(() => {\r\n    let active = true;\r\n    (async () => {\r\n      if (!address) { setResolved(null); return; }\r\n      setIsResolving(true);\r\n      try {\r\n        const native = await resolveAddress(address);\r\n        if (!active) return;\r\n        setResolved(native);\r\n      } catch {\r\n        if (!active) return;\r\n        setResolved(null);\r\n      } finally {\r\n        if (active) setIsResolving(false);\r\n      }\r\n    })();\r\n    return () => { active = false; };\r\n  }, [address, resolveAddress]);\r\n\r\n  const { data, loading, error } = useQuery(\r\n    TOKEN_HOLDERS_PAGED_QUERY as unknown as TypedDocumentNode<any, any>,\r\n    {\r\n      variables: { accountId: resolved, first },\r\n      skip: !resolved || isResolving,\r\n      fetchPolicy: 'cache-first',\r\n    }\r\n  );\r\n\r\n  const balances = useMemo(() => {\r\n    const edges = data?.tokenHolders?.edges ?? [];\r\n    return mapTokenHoldersToUiBalances(edges as Array<{ node?: any } | null>);\r\n  }, [data]);\r\n\r\n  return { balances, loading, error: error as Error | undefined, totalCount: data?.tokenHolders?.totalCount };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-token-bootstrap.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1160,1163],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1160,1163],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1227,1230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1227,1230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":210,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8338,8341],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8338,8341],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":210,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8343,8346],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8343,8346],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_e' is defined but never used.","line":228,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":228,"endColumn":18},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":255,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10313,10316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10313,10316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":256,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":256,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10350,10353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10350,10353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef } from 'react';\r\nimport type { ApolloClient, NormalizedCacheObject } from '@apollo/client';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport type { UiTransfer } from '@/data/transfer-mapper';\r\nimport { VERIFIED_CONTRACTS_BY_NAME_QUERY } from '@/data/verified-contracts';\r\nimport {\r\n  USDC_ID_SET,\r\n  USDC_SESSION_SET,\r\n  MRD_ID_SET,\r\n  MRD_SESSION_SET,\r\n  loadIds,\r\n  saveIds,\r\n  USDC_STORAGE_KEY,\r\n  MRD_STORAGE_KEY,\r\n} from '@/tokens/token-ids';\r\n\r\ninterface Args {\r\n  effectiveStrict: boolean;\r\n  tokenFilter: string;\r\n  enforceStrict: boolean;\r\n  isLoading: boolean;\r\n  initialTransactions?: UiTransfer[] | null;\r\n  serverTokenIds: string[] | null;\r\n  setServerTokenIds: (val: string[] | null) => void;\r\n  softFallbackActive: boolean;\r\n  setSoftFallbackActive: (val: boolean) => void;\r\n  softFallbackAttempted: boolean;\r\n  setSoftFallbackAttempted: (val: boolean) => void;\r\n  apollo: ApolloClient<NormalizedCacheObject>;\r\n  usdcBootstrapDone: boolean;\r\n  setUsdcBootstrapDone: (val: boolean) => void;\r\n  dbg?: (...args: unknown[]) => void;\r\n}\r\n\r\nconst ENABLE_USDC_BOOTSTRAP = ((import.meta as any).env?.VITE_ENABLE_USDC_BOOTSTRAP === '1'\r\n  || (import.meta as any).env?.VITE_ENABLE_USDC_BOOTSTRAP === 'true');\r\n\r\nfunction arraysEqual(a: string[] | null, b: string[] | null): boolean {\r\n  if (a === b) return true;\r\n  if (!a || !b) return false;\r\n  if (a.length !== b.length) return false;\r\n  for (let i = 0; i < a.length; i += 1) if (a[i] !== b[i]) return false;\r\n  return true;\r\n}\r\n\r\nconst isHexAddress = (v: string) => /^0x[0-9a-fA-F]{40}$/.test(v);\r\n\r\nexport function useTokenBootstrap({\r\n  effectiveStrict,\r\n  tokenFilter,\r\n  enforceStrict,\r\n  isLoading,\r\n  initialTransactions,\r\n  serverTokenIds,\r\n  setServerTokenIds,\r\n  softFallbackActive,\r\n  setSoftFallbackActive,\r\n  softFallbackAttempted,\r\n  setSoftFallbackAttempted,\r\n  apollo,\r\n  usdcBootstrapDone,\r\n  setUsdcBootstrapDone,\r\n  dbg,\r\n}: Args) {\r\n  // Use refs to track current state values for comparison in effects without adding them to dependencies.\r\n  // This prevents infinite loops when state updates are based on current state.\r\n  const serverTokenIdsRef = useRef(serverTokenIds);\r\n  useEffect(() => {\r\n    serverTokenIdsRef.current = serverTokenIds;\r\n  }, [serverTokenIds]);\r\n\r\n  const usdcBootstrapDoneRef = useRef(usdcBootstrapDone);\r\n  useEffect(() => {\r\n    usdcBootstrapDoneRef.current = usdcBootstrapDone;\r\n  }, [usdcBootstrapDone]);\r\n\r\n  // Reset serverTokenIds when strict filter is off or token group is not supported\r\n  useEffect(() => {\r\n    if (!effectiveStrict || tokenFilter === 'all' || tokenFilter === 'reef') {\r\n      if (serverTokenIdsRef.current !== null) {\r\n        setServerTokenIds(null);\r\n      }\r\n    }\r\n  }, [effectiveStrict, tokenFilter, setServerTokenIds]);\r\n\r\n  // Hex address: update once on filter change, preserve checksum casing\r\n  useEffect(() => {\r\n    if (!effectiveStrict) return;\r\n    if (!isHexAddress(tokenFilter)) return;\r\n    const next = [tokenFilter];\r\n    const tid = (typeof window !== 'undefined') ? window.setTimeout(() => {\r\n      if (!arraysEqual(serverTokenIdsRef.current, next)) {\r\n        setServerTokenIds(next);\r\n      }\r\n    }, 150) : undefined;\r\n    return () => { if (typeof window !== 'undefined' && tid) window.clearTimeout(tid); };\r\n  }, [effectiveStrict, tokenFilter, setServerTokenIds]);\r\n\r\n  // Seed ids immediately when strict filter is enabled to avoid initial query without tokenIds\r\n  useEffect(() => {\r\n    if (!effectiveStrict) return;\r\n    if (serverTokenIdsRef.current && serverTokenIdsRef.current.length > 0) return;\r\n    if (tokenFilter === 'usdc') {\r\n      const next = Array.from(new Set<string>([...USDC_ID_SET, ...USDC_SESSION_SET]));\r\n      if (next.length > 0 && !arraysEqual(serverTokenIdsRef.current, next)) {\r\n        setServerTokenIds(next);\r\n        if (softFallbackActive) setSoftFallbackActive(false);\r\n      }\r\n    } else if (tokenFilter === 'mrd') {\r\n      const next = Array.from(new Set<string>([...MRD_ID_SET, ...MRD_SESSION_SET]));\r\n      if (next.length > 0 && !arraysEqual(serverTokenIdsRef.current, next)) {\r\n        setServerTokenIds(next);\r\n        if (softFallbackActive) setSoftFallbackActive(false);\r\n      }\r\n    } else if (isHexAddress(tokenFilter)) {\r\n      const next = [tokenFilter];\r\n      if (!arraysEqual(serverTokenIdsRef.current, next)) {\r\n        setServerTokenIds(next);\r\n        if (softFallbackActive) setSoftFallbackActive(false);\r\n      }\r\n    }\r\n  }, [effectiveStrict, tokenFilter, softFallbackActive, setServerTokenIds, setSoftFallbackActive]);\r\n\r\n  // On first mount, load persisted session ids\r\n  useEffect(() => {\r\n    const usdc = loadIds(USDC_STORAGE_KEY);\r\n    for (const id of usdc) USDC_SESSION_SET.add(id);\r\n    const mrd = loadIds(MRD_STORAGE_KEY);\r\n    for (const id of mrd) MRD_SESSION_SET.add(id);\r\n  }, []);\r\n\r\n  // USDC/MRD: update server ids if session set changes (observed via page rows)\r\n  useEffect(() => {\r\n    if (!effectiveStrict) return;\r\n    if (tokenFilter !== 'usdc' && tokenFilter !== 'mrd') return;\r\n    const next = tokenFilter === 'usdc' \r\n      ? Array.from(new Set<string>([...USDC_ID_SET, ...USDC_SESSION_SET]))\r\n      : Array.from(new Set<string>([...MRD_ID_SET, ...MRD_SESSION_SET]));\r\n    const tid = (typeof window !== 'undefined') ? window.setTimeout(() => {\r\n      if (!arraysEqual(serverTokenIdsRef.current, next)) {\r\n        setServerTokenIds(next);\r\n      }\r\n    }, 150) : undefined;\r\n    return () => { if (typeof window !== 'undefined' && tid) window.clearTimeout(tid); };\r\n  }, [effectiveStrict, tokenFilter, setServerTokenIds]);\r\n\r\n  // Activate soft fallback when strict USDC/MRD filter returns no items on first load\r\n  useEffect(() => {\r\n    if (enforceStrict) {\r\n      if (softFallbackActive) setSoftFallbackActive(false);\r\n      if (softFallbackAttempted) setSoftFallbackAttempted(false);\r\n      return;\r\n    }\r\n    const eligible = (tokenFilter === 'usdc' || tokenFilter === 'mrd');\r\n    if (!effectiveStrict || !eligible) {\r\n      if (softFallbackActive) setSoftFallbackActive(false);\r\n      if (softFallbackAttempted) setSoftFallbackAttempted(false);\r\n      return;\r\n    }\r\n    if (isLoading) return;\r\n    if (!serverTokenIdsRef.current || serverTokenIdsRef.current.length === 0) return;\r\n    const count = (initialTransactions || []).length;\r\n    if (count === 0 && !softFallbackActive && !softFallbackAttempted) {\r\n      setSoftFallbackActive(true);\r\n      setSoftFallbackAttempted(true);\r\n      if (dbg) dbg('[ERC20][fallback] activating soft fallback (no items under strict filter)', { tokenFilter });\r\n    }\r\n  }, [effectiveStrict, tokenFilter, isLoading, initialTransactions, softFallbackActive, softFallbackAttempted, enforceStrict, setSoftFallbackActive, setSoftFallbackAttempted, dbg]);\r\n\r\n  // Exit soft fallback once we have concrete server token ids\r\n  useEffect(() => {\r\n    if (enforceStrict) {\r\n      if (softFallbackActive) setSoftFallbackActive(false);\r\n      return;\r\n    }\r\n    if (!softFallbackActive) return;\r\n    const eligible = (tokenFilter === 'usdc' || tokenFilter === 'mrd');\r\n    if (!effectiveStrict || !eligible) {\r\n      setSoftFallbackActive(false);\r\n      return;\r\n    }\r\n    const discovered = tokenFilter === 'usdc' ? (USDC_SESSION_SET.size > 0) : (MRD_SESSION_SET.size > 0);\r\n    if (discovered) {\r\n      setSoftFallbackActive(false);\r\n      if (dbg) dbg('[ERC20][fallback] discovered ids via session, returning to strict mode');\r\n    }\r\n  }, [softFallbackActive, effectiveStrict, tokenFilter, enforceStrict, setSoftFallbackActive, dbg]);\r\n\r\n  // Bootstrap USDC ids\r\n  useEffect(() => {\r\n    if (!effectiveStrict || tokenFilter !== 'usdc') {\r\n      if (usdcBootstrapDoneRef.current) setUsdcBootstrapDone(false);\r\n      return;\r\n    }\r\n    if (usdcBootstrapDoneRef.current) return;\r\n    if (!ENABLE_USDC_BOOTSTRAP) {\r\n      setUsdcBootstrapDone(true);\r\n      return;\r\n    }\r\n    if (!softFallbackActive) return;\r\n    if (USDC_SESSION_SET.size > 0) {\r\n      setUsdcBootstrapDone(true);\r\n      return;\r\n    }\r\n    let cancelled = false;\r\n    (async () => {\r\n      try {\r\n        const names = ['USDC', 'USDC.e', 'USD Coin'];\r\n        const { data } = await (apollo as ApolloClient<NormalizedCacheObject>).query({\r\n          query: VERIFIED_CONTRACTS_BY_NAME_QUERY as unknown as TypedDocumentNode<any, any>,\r\n          variables: { names, needle: 'usdc' },\r\n          fetchPolicy: 'cache-first',\r\n          errorPolicy: 'ignore',\r\n        });\r\n        const list = (data?.verifiedContracts ?? []) as Array<{ id?: string; name?: string }>;\r\n        let added = 0;\r\n        for (const it of list) {\r\n          const id = String(it?.id || '').toLowerCase();\r\n          if (!id) continue;\r\n          if (!USDC_SESSION_SET.has(id)) { USDC_SESSION_SET.add(id); added += 1; }\r\n        }\r\n        if (added > 0 && !cancelled) {\r\n          const next = Array.from(new Set<string>([...USDC_ID_SET, ...USDC_SESSION_SET]));\r\n          if (!arraysEqual(serverTokenIdsRef.current, next)) {\r\n            setServerTokenIds(next);\r\n          }\r\n        }\r\n      } catch (_e) {\r\n        // ignore\r\n      } finally {\r\n        if (!cancelled) setUsdcBootstrapDone(true);\r\n      }\r\n    })();\r\n    return () => { cancelled = true; };\r\n  }, [effectiveStrict, tokenFilter, apollo, softFallbackActive, setUsdcBootstrapDone, setServerTokenIds]);\r\n\r\n  // Observe current page for tokens and extend session sets\r\n  useEffect(() => {\r\n    if (!effectiveStrict) return;\r\n    if (tokenFilter !== 'usdc' && tokenFilter !== 'mrd') return;\r\n    const list = initialTransactions || [];\r\n    let added = 0;\r\n    const isUsdc = tokenFilter === 'usdc';\r\n    const nameSynonyms = isUsdc ? new Set(['usdc', 'usdc.e', 'usd coin']) : new Set(['mrd']);\r\n    const sessionSet = isUsdc ? USDC_SESSION_SET : MRD_SESSION_SET;\r\n    const storageKey = isUsdc ? USDC_STORAGE_KEY : MRD_STORAGE_KEY;\r\n    const idSet = isUsdc ? USDC_ID_SET : MRD_ID_SET;\r\n    for (const t of list) {\r\n      const addIf = (maybe?: { id?: string; name?: string }) => {\r\n        const id = (maybe?.id || '').toLowerCase();\r\n        if (!id) return;\r\n        const nm = (maybe?.name || '').toString().toLowerCase();\r\n        if (nm && nameSynonyms.has(nm) && !sessionSet.has(id)) { sessionSet.add(id); added += 1; }\r\n      };\r\n      addIf((t as any)?.token);\r\n      const s = (t as any)?.swapInfo;\r\n      if (s) { addIf(s.sold?.token); addIf(s.bought?.token); }\r\n    }\r\n    if (added > 0) {\r\n      const next = Array.from(new Set<string>([...idSet, ...sessionSet]));\r\n      if (!arraysEqual(serverTokenIdsRef.current, next)) {\r\n        setServerTokenIds(next);\r\n      }\r\n      saveIds(storageKey, sessionSet);\r\n    }\r\n  }, [effectiveStrict, tokenFilter, initialTransactions, setServerTokenIds]);\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-token-icons.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[785,788],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[785,788],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[790,793],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[790,793],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from 'react';\r\nimport { useQuery } from '@apollo/client';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { VERIFIED_CONTRACTS_BY_IDS_QUERY, buildIconMap, type TokenIconMap } from '@/data/token-icons';\r\n\r\nexport interface UseTokenIconsResult {\r\n  icons: TokenIconMap;\r\n  loading: boolean;\r\n  error?: Error;\r\n}\r\n\r\nexport function useTokenIcons(ids: string[] | undefined, limit = 100): UseTokenIconsResult {\r\n  const uniqueIds = useMemo(() => {\r\n    const s = new Set<string>();\r\n    for (const id of ids ?? []) {\r\n      if (typeof id === 'string' && id) s.add(id);\r\n    }\r\n    return Array.from(s);\r\n  }, [ids]);\r\n\r\n  const { data, loading, error } = useQuery(\r\n    VERIFIED_CONTRACTS_BY_IDS_QUERY as unknown as TypedDocumentNode<any, any>,\r\n    {\r\n      variables: { ids: uniqueIds, first: Math.min(uniqueIds.length, limit) },\r\n      skip: uniqueIds.length === 0,\r\n      fetchPolicy: 'cache-first',\r\n    }\r\n  );\r\n\r\n  const icons = useMemo(() => {\r\n    const rows: Array<{ id?: unknown; contractData?: unknown }> = data?.verifiedContracts ?? [];\r\n    return buildIconMap(rows);\r\n  }, [data]);\r\n\r\n  return { icons, loading, error: error as Error | undefined };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-token-metadata-resolver.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[394,397],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[394,397],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[670,673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[670,673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[712,715],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[712,715],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1513,1516],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1513,1516],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1518,1521],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1518,1521],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1741,1744],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1741,1744],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":44,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":17}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { ApolloClient, NormalizedCacheObject, useApolloClient, type TypedDocumentNode } from '@apollo/client';\r\nimport { getString } from '@/utils/object';\r\nimport { VerifiedContractsByIdsDocument } from '@/gql/graphql';\r\nimport { hasTokenMetaCached, primeTokenMetaCacheFromContracts } from '../data/transfer-mapper';\r\n\r\ninterface Props {\r\n  data: any;\r\n}\r\n\r\nexport function useTokenMetadataResolver({ data }: Props) {\r\n  const client = useApolloClient();\r\n  const [metaVersion, setMetaVersion] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const edges = data?.transfersConnection.edges || [];\r\n    const nodes = edges.map((e: any) => e?.node).filter(Boolean) as Array<any>;\r\n    if (nodes.length === 0) return;\r\n\r\n    const ids: string[] = [];\r\n    for (const n of nodes) {\r\n      const id = getString(n, ['token', 'id']);\r\n      if (!id) continue;\r\n      const transferType = getString(n, ['type']) || '';\r\n      if (transferType === 'Native' || transferType === 'ERC721' || transferType === 'ERC1155') continue;\r\n      const tokenName = getString(n, ['token', 'name']) || '';\r\n      if (tokenName === 'REEF') continue;\r\n      if (!hasTokenMetaCached(id)) ids.push(id);\r\n    }\r\n    const unique = Array.from(new Set(ids));\r\n    if (unique.length === 0) return;\r\n\r\n    (async () => {\r\n      try {\r\n        const { data: q } = await (client as ApolloClient<NormalizedCacheObject>).query({\r\n          query: VerifiedContractsByIdsDocument as unknown as TypedDocumentNode<any, any>,\r\n          variables: { ids: unique, first: Math.min(unique.length, 100) },\r\n          fetchPolicy: 'cache-first',\r\n        });\r\n        const list = (q?.verifiedContracts || []) as Array<{ id: string; contractData?: any; name?: string }>;\r\n        if (list.length === 0) return;\r\n        const added = primeTokenMetaCacheFromContracts(list);\r\n        if (added > 0) setMetaVersion((v) => v + 1);\r\n      } catch (e) {\r\n        // ignore, soft optimization\r\n      }\r\n    })();\r\n  }, [client, data]);\r\n\r\n  return { metaVersion };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-token-usd-mid.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2441,2444],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2441,2444],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4909,4912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4909,4912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5803,5806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5803,5806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6107,6110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6107,6110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":164,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7245,7248],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7245,7248],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":170,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7596,7599],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7596,7599],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":193,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8820,8823],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8820,8823],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":199,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9155,9158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9155,9158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9988,9991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9988,9991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":219,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10297,10300],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10297,10300],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":222,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10461,10464],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10461,10464],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":227,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10767,10770],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10767,10770],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":273,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12852,12855],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12852,12855],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'rawToken'. Either include it or remove the dependency array.","line":283,"column":6,"nodeType":"ArrayExpression","endLine":283,"endColumn":57,"suggestions":[{"desc":"Update the dependencies array to be: [tokenKey, dec, midTimestampIso, history, cacheKey, rawToken]","fix":{"range":[13174,13225],"text":"[tokenKey, dec, midTimestampIso, history, cacheKey, rawToken]"}}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useState } from 'react';\r\nimport type { ApolloClient, NormalizedCacheObject } from '@apollo/client';\r\nimport { reefSwapClient } from '@/reef-swap-client';\r\nimport { reefExplorerClient } from '@/reef-explorer-client';\r\nimport { BLOCK_BY_TIME_BEFORE_DOCUMENT, BLOCK_BY_TIME_AFTER_DOCUMENT } from '@/data/explorer-blocks';\r\nimport {\r\n  NEAREST_SWAP_FOR_TOKEN_BY_TIME_DOCUMENT,\r\n  NEAREST_SWAP_FOR_TOKEN_BY_TIME_AFTER_DOCUMENT,\r\n  NEAREST_SWAP_FOR_TOKEN_DOCUMENT,\r\n  NEAREST_SWAP_FOR_TOKEN_BY_BLOCK_AFTER_DOCUMENT,\r\n  NEAREST_SWAP_FOR_TOKEN_WINDOW_BEFORE_DOCUMENT,\r\n  NEAREST_SWAP_FOR_TOKEN_WINDOW_AFTER_DOCUMENT,\r\n} from '@/data/reef-swap';\r\nimport { useReefPriceHistory } from '@/hooks/use-reef-price-history';\r\nimport { TtlCache } from '@/data/ttl-cache';\r\n\r\nexport interface UseTokenUsdMidInput {\r\n  tokenId?: string | null;\r\n  decimals?: number | null;\r\n  tradeTimestamp?: string | number | null; // original trade time\r\n  horizonDays?: number; // default 7\r\n}\r\n\r\nexport interface UseTokenUsdMidResult {\r\n  usdMidPerUnit: number | null;\r\n  loading: boolean;\r\n  error?: Error;\r\n}\r\n\r\nconst cache = new TtlCache<number>({\r\n  namespace: 'reef:token-usd-mid',\r\n  defaultTtlMs: 6 * 60 * 60 * 1000,\r\n  persist: true,\r\n  maxSize: 5000,\r\n});\r\n\r\nconst REEF_ID = '0x0000000000000000000000000000000001000000';\r\nconst DAY_MS = 24 * 60 * 60 * 1000;\r\nconst ENV = ((import.meta as unknown as { env?: Record<string, string | undefined> }).env) ?? {};\r\n// Default: Explorer fallback disabled. Set VITE_MID_DISABLE_EXPLORER=\"false\" to opt-in.\r\nconst DISABLE_EXPLORER = ENV.VITE_MID_DISABLE_EXPLORER !== 'false';\r\nconst EXPLORER_TIMEOUT_MS = Math.max(500, Math.min(10000, Number(ENV.VITE_EXPLORER_TIMEOUT_MS ?? '2500')));\r\ntype PickStrategy = 'before' | 'nearest' | 'after';\r\nconst PICK_STRATEGY: PickStrategy = ((ENV.VITE_MID_PICK_STRATEGY || 'before').toLowerCase() as PickStrategy);\r\n\r\nfunction toIsoDay(ms: number): string { return new Date(ms).toISOString().slice(0, 10); }\r\n\r\nfunction toFloat(amount: unknown, decimals: number): number {\r\n  try {\r\n    const s = String(amount ?? '0');\r\n    if (!/^-?\\d+$/.test(s)) return 0;\r\n    const bi = BigInt(s);\r\n    if (decimals <= 0) return Number(bi);\r\n    const div = 10n ** BigInt(decimals);\r\n    const ip = bi / div; const fp = (bi % div).toString().padStart(decimals, '0');\r\n    return parseFloat(`${ip}.${fp}`);\r\n  } catch { return 0; }\r\n}\r\n\r\nfunction reefPerTokenFromEvent(ev: any, reefIsToken1: boolean): number | null {\r\n  const a1 = toFloat(ev?.amount1, Number(ev?.pool?.token1?.decimals ?? 18));\r\n  const a2 = toFloat(ev?.amount2, Number(ev?.pool?.token2?.decimals ?? 18));\r\n  const in1 = toFloat(ev?.amountIn1, Number(ev?.pool?.token1?.decimals ?? 18));\r\n  const in2 = toFloat(ev?.amountIn2, Number(ev?.pool?.token2?.decimals ?? 18));\r\n  if (reefIsToken1) {\r\n    if (in2 > 0 && a1 > 0) return a1 / in2;\r\n    if (in1 > 0 && a2 > 0) return in1 / a2;\r\n  } else {\r\n    if (in1 > 0 && a2 > 0) return a2 / in1;\r\n    if (in2 > 0 && a1 > 0) return in2 / a1;\r\n  }\r\n  if (reefIsToken1 && a1 > 0 && a2 > 0) return a1 / a2;\r\n  if (!reefIsToken1 && a2 > 0 && a1 > 0) return a2 / a1;\r\n  return null;\r\n}\r\n\r\nexport function useTokenUsdMidFromSwapTime({ tokenId, decimals, tradeTimestamp, horizonDays = 7 }: UseTokenUsdMidInput): UseTokenUsdMidResult {\r\n  const rawToken = (tokenId || '').trim();\r\n  // reef-swap stores token ids in lowercase; normalize for id_eq matching\r\n  const tokenKey = rawToken.toLowerCase();\r\n  const dec = Math.max(0, Number(decimals ?? 18));\r\n  const [usdMid, setUsdMid] = useState<number | null>(null);\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<Error | undefined>(undefined);\r\n  const { history } = useReefPriceHistory('max');\r\n\r\n  const midTimestampIso = useMemo(() => {\r\n    if (tradeTimestamp == null) return null;\r\n    const t = (() => { try { const ms = Date.parse(String(tradeTimestamp)); return Number.isFinite(ms) ? ms : NaN; } catch { return NaN; } })();\r\n    if (!Number.isFinite(t)) return null;\r\n    const ms = t + Math.max(1, Math.trunc(horizonDays)) * 24 * 60 * 60 * 1000;\r\n    return new Date(ms).toISOString();\r\n  }, [tradeTimestamp, horizonDays]);\r\n\r\n  const dayKey = useMemo(() => {\r\n    if (!midTimestampIso) return null;\r\n    return toIsoDay(Date.parse(midTimestampIso));\r\n  }, [midTimestampIso]);\r\n\r\n  const cacheKey = useMemo(() => tokenKey && dayKey ? `${tokenKey}:${dayKey}` : null, [tokenKey, dayKey]);\r\n\r\n  useEffect(() => {\r\n    let cancelled = false;\r\n    const abort = new AbortController();\r\n    async function run() {\r\n      try {\r\n        setError(undefined);\r\n        if (!rawToken) { setUsdMid(null); return; }\r\n        if (!midTimestampIso) { setUsdMid(null); return; }\r\n        const targetMs = Date.parse(midTimestampIso);\r\n        const reefUsdMidMaybe = (() => {\r\n          try {\r\n            const v = history?.[toIsoDay(targetMs) as any];\r\n            return typeof v === 'number' ? v : null;\r\n          } catch { return null; }\r\n        })();\r\n        if (cacheKey) {\r\n          const c = cache.get(cacheKey);\r\n          if (typeof c === 'number') { setUsdMid(c); return; }\r\n        }\r\n        // REEF leg: no need to hit swap index; use historical REEF price directly\r\n        if (tokenKey === REEF_ID) {\r\n          if (!cancelled) {\r\n            if (reefUsdMidMaybe != null) {\r\n              setUsdMid(reefUsdMidMaybe);\r\n              if (cacheKey) cache.set(cacheKey, reefUsdMidMaybe);\r\n            } else {\r\n              setUsdMid(null);\r\n            }\r\n          }\r\n          return;\r\n        }\r\n\r\n        const client = reefSwapClient as ApolloClient<NormalizedCacheObject>;\r\n        const [beforeQ, afterQ] = await Promise.all([\r\n          client.query({\r\n            query: NEAREST_SWAP_FOR_TOKEN_BY_TIME_DOCUMENT as any,\r\n            variables: { reef: REEF_ID, token: tokenKey, ts: midTimestampIso },\r\n            fetchPolicy: 'network-only',\r\n            context: { fetchOptions: { signal: abort.signal } },\r\n          }),\r\n          client.query({\r\n            query: NEAREST_SWAP_FOR_TOKEN_BY_TIME_AFTER_DOCUMENT as any,\r\n            variables: { reef: REEF_ID, token: tokenKey, ts: midTimestampIso },\r\n            fetchPolicy: 'network-only',\r\n            context: { fetchOptions: { signal: abort.signal } },\r\n          }),\r\n        ]);\r\n        let evBefore = (beforeQ?.data?.poolEventsConnection?.edges ?? [])[0]?.node;\r\n        let evAfter = (afterQ?.data?.poolEventsConnection?.edges ?? [])[0]?.node;\r\n\r\n        // Fallback 1: widen time window around target on reef-swap (avoid explorer when possible)\r\n        if (!evBefore && !evAfter) {\r\n          const windows = [1, 3, 7, 14, 30, 60, 90, 180];\r\n          const client2 = reefSwapClient as ApolloClient<NormalizedCacheObject>;\r\n          for (const w of windows) {\r\n            const fromBefore = new Date(targetMs - w * DAY_MS).toISOString();\r\n            const toBefore = midTimestampIso;\r\n            const fromAfter = midTimestampIso;\r\n            const toAfter = new Date(targetMs + w * DAY_MS).toISOString();\r\n            try {\r\n              const [wb, wa] = await Promise.all([\r\n                client2.query({\r\n                  query: NEAREST_SWAP_FOR_TOKEN_WINDOW_BEFORE_DOCUMENT as any,\r\n                  variables: { reef: REEF_ID, token: tokenKey, from: fromBefore, to: toBefore },\r\n                  fetchPolicy: 'network-only',\r\n                  context: { fetchOptions: { signal: abort.signal } },\r\n                }),\r\n                client2.query({\r\n                  query: NEAREST_SWAP_FOR_TOKEN_WINDOW_AFTER_DOCUMENT as any,\r\n                  variables: { reef: REEF_ID, token: tokenKey, from: fromAfter, to: toAfter },\r\n                  fetchPolicy: 'network-only',\r\n                  context: { fetchOptions: { signal: abort.signal } },\r\n                }),\r\n              ]);\r\n              evBefore = (wb?.data?.poolEventsConnection?.edges ?? [])[0]?.node || evBefore;\r\n              evAfter = (wa?.data?.poolEventsConnection?.edges ?? [])[0]?.node || evAfter;\r\n              if (evBefore || evAfter) break;\r\n            } catch {\r\n              // ignore and try next window\r\n            }\r\n          }\r\n        }\r\n\r\n        // Fallback 2: if still empty, resolve nearest blocks via explorer and query reef-swap by block\r\n        if (!evBefore && !evAfter && !DISABLE_EXPLORER) {\r\n          try {\r\n            // Use a separate abort with a short timeout to prevent hanging explorer requests\r\n            const expAbort = new AbortController();\r\n            const expTimer = window.setTimeout(() => expAbort.abort(), EXPLORER_TIMEOUT_MS);\r\n            const [bBlock, aBlock] = await Promise.all([\r\n              (reefExplorerClient as ApolloClient<NormalizedCacheObject>).query({\r\n                query: BLOCK_BY_TIME_BEFORE_DOCUMENT as any,\r\n                variables: { ts: midTimestampIso },\r\n                fetchPolicy: 'network-only',\r\n                context: { fetchOptions: { signal: expAbort.signal } },\r\n              }),\r\n              (reefExplorerClient as ApolloClient<NormalizedCacheObject>).query({\r\n                query: BLOCK_BY_TIME_AFTER_DOCUMENT as any,\r\n                variables: { ts: midTimestampIso },\r\n                fetchPolicy: 'network-only',\r\n                context: { fetchOptions: { signal: expAbort.signal } },\r\n              }),\r\n            ]);\r\n            window.clearTimeout(expTimer);\r\n            const hb = Number(bBlock?.data?.blocks?.[0]?.height);\r\n            const ha = Number(aBlock?.data?.blocks?.[0]?.height);\r\n            const client2 = reefSwapClient as ApolloClient<NormalizedCacheObject>;\r\n            const byBlockAbort = new AbortController();\r\n            const byBlockTimer = window.setTimeout(() => byBlockAbort.abort(), EXPLORER_TIMEOUT_MS);\r\n            const [bSwap, aSwap] = await Promise.all([\r\n              Number.isFinite(hb) && hb > 0\r\n                ? client2.query({\r\n                    query: NEAREST_SWAP_FOR_TOKEN_DOCUMENT as any,\r\n                    variables: { reef: REEF_ID, token: tokenKey, bh: Math.trunc(hb), ex: 9999 },\r\n                    fetchPolicy: 'network-only',\r\n                    context: { fetchOptions: { signal: byBlockAbort.signal } },\r\n                  })\r\n                : Promise.resolve({ data: null } as any),\r\n              Number.isFinite(ha) && ha > 0\r\n                ? client2.query({\r\n                    query: NEAREST_SWAP_FOR_TOKEN_BY_BLOCK_AFTER_DOCUMENT as any,\r\n                    variables: { reef: REEF_ID, token: tokenKey, bh: Math.trunc(ha), ex: 0 },\r\n                    fetchPolicy: 'network-only',\r\n                    context: { fetchOptions: { signal: byBlockAbort.signal } },\r\n                  })\r\n                : Promise.resolve({ data: null } as any),\r\n            ]);\r\n            window.clearTimeout(byBlockTimer);\r\n            evBefore = (bSwap?.data?.poolEventsConnection?.edges ?? [])[0]?.node || null;\r\n            evAfter = (aSwap?.data?.poolEventsConnection?.edges ?? [])[0]?.node || null;\r\n          } catch {\r\n            // ignore fallback errors; proceed with blanks\r\n          }\r\n        }\r\n\r\n        const pick = (() => {\r\n          const tb = evBefore ? Date.parse(String(evBefore.timestamp)) : Number.NaN;\r\n          const ta = evAfter ? Date.parse(String(evAfter.timestamp)) : Number.NaN;\r\n          if (PICK_STRATEGY === 'before') {\r\n            if (Number.isFinite(tb)) return evBefore;\r\n            if (Number.isFinite(ta)) return evAfter;\r\n            return null;\r\n          }\r\n          if (PICK_STRATEGY === 'after') {\r\n            if (Number.isFinite(ta)) return evAfter;\r\n            if (Number.isFinite(tb)) return evBefore;\r\n            return null;\r\n          }\r\n          // nearest\r\n          if (Number.isFinite(tb) && Number.isFinite(ta)) {\r\n            const db = Math.abs(tb - targetMs);\r\n            const da = Math.abs(ta - targetMs);\r\n            // tie-breaker: prefer before\r\n            return db <= da ? evBefore : evAfter;\r\n          }\r\n          if (Number.isFinite(tb)) return evBefore;\r\n          if (Number.isFinite(ta)) return evAfter;\r\n          return null;\r\n        })();\r\n        if (!pick) { setUsdMid(null); return; }\r\n        const token1Id = (pick?.pool?.token1?.id || '').toLowerCase();\r\n        const reefIsToken1 = token1Id === '0x0000000000000000000000000000000001000000';\r\n        const rpt = reefPerTokenFromEvent(pick, reefIsToken1);\r\n        if (rpt == null || !(rpt > 0)) { setUsdMid(null); return; }\r\n        if (reefUsdMidMaybe == null) { setUsdMid(null); return; }\r\n        const usdPerToken = rpt * reefUsdMidMaybe;\r\n        if (!Number.isFinite(usdPerToken) || !(usdPerToken > 0)) { setUsdMid(null); return; }\r\n        if (!cancelled) {\r\n          setUsdMid(usdPerToken);\r\n          if (cacheKey) cache.set(cacheKey, usdPerToken);\r\n        }\r\n      } catch (e: any) {\r\n        if (!cancelled) { setUsdMid(null); setError(e instanceof Error ? e : new Error('usd mid lookup failed')); }\r\n      } finally {\r\n        if (!cancelled) setLoading(false);\r\n      }\r\n    }\r\n    setUsdMid(null);\r\n    setLoading(true);\r\n    run();\r\n    return () => { cancelled = true; abort.abort(); };\r\n  }, [tokenKey, dec, midTimestampIso, history, cacheKey]);\r\n\r\n  return { usdMidPerUnit: usdMid, loading, error } as const;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-token-usd-prices.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":62,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2018,2021],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2018,2021],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'row' is never reassigned. Use 'const' instead.","line":163,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":163,"endColumn":12,"fix":{"range":[5368,5418],"text":"const row = await fetchReservesViaGraph(id, signal);"}},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'unique'. Either include it or remove the dependency array.","line":325,"column":6,"nodeType":"ArrayExpression","endLine":325,"endColumn":31,"suggestions":[{"desc":"Update the dependencies array to be: [reefPrice.usd, uniqKey, unique]","fix":{"range":[11698,11723],"text":"[reefPrice.usd, uniqKey, unique]"}}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useRef, useState } from 'react';\r\nimport { useReefPrice } from './use-reef-price';\r\nimport { REEF_TOKEN_ADDRESS } from '@/utils/evm-call';\r\nimport { TtlCache } from '../data/ttl-cache';\r\nimport { safeBigInt } from '@/utils/token-helpers';\r\n\r\nexport interface TokenInput {\r\n  id: string;\r\n  decimals: number;\r\n}\r\n\r\nexport interface TokenPricesResult {\r\n  pricesById: Record<string, number | null>;\r\n  loading: boolean;\r\n}\r\n\r\n// Approximate float from bigint using scientific notation based on first 15 digits\r\nfunction toFloatApprox(x: bigint): number {\r\n  const s = x.toString();\r\n  if (s.length <= 15) return Number(x);\r\n  const head = Number(s.slice(0, 15));\r\n  const exp = s.length - 15;\r\n  return head * Math.pow(10, exp);\r\n}\r\n\r\nfunction pow10(n: number): bigint {\r\n  if (n <= 0) return 1n;\r\n  let b = 1n;\r\n  for (let i = 0; i < n; i += 1) b *= 10n;\r\n  return b;\r\n}\r\n\r\n// Subsquid GraphQL fallback (no EVM eth_call needed)\r\nconst ENV = ((import.meta as unknown as { env?: Record<string, string | undefined> }).env) ?? {};\r\nconst SQUID_URL: string = ENV.VITE_REEFSWAP_SQUID_URL ?? 'https://squid.subsquid.io/reef-swap/graphql';\r\nconst MIN_REEF_RESERVE: number = (() => {\r\n  try {\r\n    const raw = ENV.VITE_MIN_REEF_RESERVE_FOR_PRICE;\r\n    const n = Number(raw);\r\n    return Number.isFinite(n) && n > 0 ? n : 50000; // show price only if REEF reserve >= 50000\r\n  } catch {\r\n    return 50000;\r\n  }\r\n})();\r\n\r\ninterface GraphReservesRow {\r\n  token1: string;\r\n  token2: string;\r\n  reserved1?: string | number;\r\n  reserved2?: string | number;\r\n}\r\n\r\nasync function graphFetch<T>(query: string, variables: Record<string, unknown>, signal?: AbortSignal): Promise<T | null> {\r\n  try {\r\n    const res = await fetch(SQUID_URL, {\r\n      method: 'POST',\r\n      headers: { 'content-type': 'application/json', accept: 'application/json' },\r\n      body: JSON.stringify({ query, variables }),\r\n      signal,\r\n    });\r\n    if (!res.ok) return null;\r\n    const json = await res.json().catch(() => null) as any;\r\n    return json?.data ?? null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nasync function fetchReservesViaGraph(tok: string, signal?: AbortSignal): Promise<GraphReservesRow | null> {\r\n  const a = REEF_TOKEN_ADDRESS.toLowerCase();\r\n  const b = tok.toLowerCase();\r\n  const q = `query PR($tokens: [String!]!) {\r\n    poolsReserves(tokens: $tokens) {\r\n      token1\r\n      token2\r\n      reserved1\r\n      reserved2\r\n    }\r\n  }`;\r\n  const data = await graphFetch<{ poolsReserves: GraphReservesRow[] }>(q, { tokens: [a, b] }, signal);\r\n  const rows = data?.poolsReserves ?? [];\r\n  const row = rows.find(r => {\r\n    const t1 = (r.token1 || '').toLowerCase();\r\n    const t2 = (r.token2 || '').toLowerCase();\r\n    const s = new Set([t1, t2]);\r\n    return s.has(a) && s.has(b);\r\n  });\r\n  return row ?? null;\r\n}\r\n\r\ninterface AllPoolsRow {\r\n  token1: string;\r\n  token2: string;\r\n  reserved1?: string | number;\r\n  reserved2?: string | number;\r\n  decimals1?: number;\r\n  decimals2?: number;\r\n}\r\n\r\nasync function fetchReservesViaAllPoolsList(tok: string, signal?: AbortSignal): Promise<AllPoolsRow | null> {\r\n  const reef = REEF_TOKEN_ADDRESS.toLowerCase();\r\n  const b = tok.toLowerCase();\r\n  const q = `query AP($search: String!, $offset: Float!, $limit: Float!, $signer: String!) {\r\n    allPoolsList(search: $search, offset: $offset, limit: $limit, signerAddress: $signer) {\r\n      token1\r\n      token2\r\n      reserved1\r\n      reserved2\r\n      decimals1\r\n      decimals2\r\n      symbol1\r\n      symbol2\r\n    }\r\n  }`;\r\n  // сузим выдачу поиском по адресу токена\r\n  const data = await graphFetch<{ allPoolsList: AllPoolsRow[] }>(q, {\r\n    search: b,\r\n    offset: 0,\r\n    limit: 20,\r\n    signer: '0x0000000000000000000000000000000000000000',\r\n  }, signal);\r\n  const rows = data?.allPoolsList ?? [];\r\n  const row = rows.find(r => {\r\n    const t1 = (r.token1 || '').toLowerCase();\r\n    const t2 = (r.token2 || '').toLowerCase();\r\n    const s = new Set([t1, t2]);\r\n    return s.has(reef) && s.has(b);\r\n  });\r\n  return row ?? null;\r\n}\r\n\r\n// Batched poolsReserves for many tokens in a single round-trip\r\nasync function fetchBatchReservesViaGraph(tokens: string[], signal?: AbortSignal): Promise<Map<string, GraphReservesRow>> {\r\n  const reef = REEF_TOKEN_ADDRESS.toLowerCase();\r\n  const uniq = Array.from(new Set(tokens.map(t => t.toLowerCase()).filter(Boolean)));\r\n  if (uniq.length === 0) return new Map();\r\n  const q = `query PR($tokens: [String!]!) {\r\n    poolsReserves(tokens: $tokens) {\r\n      token1\r\n      token2\r\n      reserved1\r\n      reserved2\r\n    }\r\n  }`;\r\n  const data = await graphFetch<{ poolsReserves: GraphReservesRow[] }>(q, { tokens: [reef, ...uniq] }, signal);\r\n  const rows = data?.poolsReserves ?? [];\r\n  const out = new Map<string, GraphReservesRow>();\r\n  for (const r of rows) {\r\n    const t1 = (r.token1 || '').toLowerCase();\r\n    const t2 = (r.token2 || '').toLowerCase();\r\n    if (t1 === reef && uniq.includes(t2)) out.set(t2, r);\r\n    else if (t2 === reef && uniq.includes(t1)) out.set(t1, r);\r\n  }\r\n  return out;\r\n}\r\n\r\nasync function fetchTokenPriceUsd(token: TokenInput, reefUsd: number, signal?: AbortSignal): Promise<number | null> {\r\n  try {\r\n    if (!token?.id) return null;\r\n    const id = token.id.toLowerCase();\r\n    if (id === REEF_TOKEN_ADDRESS.toLowerCase()) return reefUsd;\r\n    // GraphQL only: poolsReserves -> allPoolsList\r\n    let row = await fetchReservesViaGraph(id, signal);\r\n    let r1 = row ? safeBigInt(row.reserved1) : 0n;\r\n    let r2 = row ? safeBigInt(row.reserved2) : 0n;\r\n    let reefIs1 = row ? ((row.token1 || '').toLowerCase() === REEF_TOKEN_ADDRESS.toLowerCase()) : false;\r\n\r\n    let tokDec = token.decimals ?? 18;\r\n    if (!row || r1 <= 0n || r2 <= 0n) {\r\n      const ap = await fetchReservesViaAllPoolsList(id, signal);\r\n      if (!ap) return null;\r\n      r1 = safeBigInt(ap.reserved1);\r\n      r2 = safeBigInt(ap.reserved2);\r\n      if (r1 <= 0n || r2 <= 0n) return null;\r\n      const reefLower = REEF_TOKEN_ADDRESS.toLowerCase();\r\n      const t1Lower = (ap.token1 || '').toLowerCase();\r\n      const t2Lower = (ap.token2 || '').toLowerCase();\r\n      reefIs1 = t1Lower === reefLower;\r\n      // prefer decimals from allPoolsList if present\r\n      if (t1Lower === id && typeof ap.decimals1 === 'number') {\r\n        tokDec = Math.max(0, Math.floor(ap.decimals1));\r\n      } else if (t2Lower === id && typeof ap.decimals2 === 'number') {\r\n        tokDec = Math.max(0, Math.floor(ap.decimals2));\r\n      }\r\n    }\r\n\r\n    const reefDec = 18; // REEF\r\n\r\n    const reserveReef = reefIs1 ? r1 : r2;\r\n    const reserveTok = reefIs1 ? r2 : r1;\r\n    // Low-liquidity guard: skip price if REEF side is too small\r\n    const reefReserveFloat = toFloatApprox(reserveReef) / Math.pow(10, reefDec);\r\n    if (!Number.isFinite(reefReserveFloat) || reefReserveFloat < MIN_REEF_RESERVE) return null;\r\n    const num = reserveReef * pow10(tokDec);\r\n    const den = reserveTok * pow10(reefDec);\r\n    if (den === 0n) return null;\r\n    const reefPerToken = toFloatApprox(num) / toFloatApprox(den);\r\n    if (!Number.isFinite(reefPerToken) || reefPerToken <= 0) return null;\r\n    return reefUsd * reefPerToken;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nconst PRICE_TTL_MS = 60_000; // 1 minute\r\nconst priceTtl = new TtlCache<number>({\r\n  namespace: 'reef:token-prices',\r\n  defaultTtlMs: PRICE_TTL_MS,\r\n  persist: true,\r\n  maxSize: 20000,\r\n});\r\n\r\nexport function useTokenUsdPrices(tokens: TokenInput[]): TokenPricesResult {\r\n  const unique = useMemo(() => {\r\n    const seen = new Set<string>();\r\n    const out: TokenInput[] = [];\r\n    for (const t of tokens || []) {\r\n      const id = (t?.id || '').toLowerCase();\r\n      if (!id || seen.has(id)) continue;\r\n      seen.add(id);\r\n      out.push({ id, decimals: t.decimals ?? 18 });\r\n    }\r\n    return out;\r\n  }, [tokens]);\r\n\r\n  // Stable signature to avoid effect reruns on equal content\r\n  const uniqKey = useMemo(() => unique.map(t => `${t.id}:${t.decimals}`).join('|'), [unique]);\r\n  const lastKeyRef = useRef<string | null>(null);\r\n\r\n  const { price: reefPrice, loading: reefLoading } = useReefPrice();\r\n  const [prices, setPrices] = useState<Record<string, number | null>>({});\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  useEffect(() => {\r\n    let aborted = false;\r\n    const ac = new AbortController();\r\n    const signal = ac.signal;\r\n    async function run() {\r\n      // Skip if content did not change\r\n      if (lastKeyRef.current === uniqKey) return;\r\n      lastKeyRef.current = uniqKey;\r\n      if (!reefPrice?.usd || unique.length === 0) {\r\n        setPrices({});\r\n        setLoading(false);\r\n        return;\r\n      }\r\n      // 1) Try TTL cache for all tokens\r\n      const next: Record<string, number | null> = {};\r\n      const missing: TokenInput[] = [];\r\n      for (const t of unique) {\r\n        const key = `${t.id}:${t.decimals}`;\r\n        const cached = priceTtl.get(key);\r\n        if (typeof cached === 'number') next[t.id] = cached;\r\n        else missing.push(t);\r\n      }\r\n\r\n      if (missing.length === 0) {\r\n        setPrices(next);\r\n        setLoading(false);\r\n        return;\r\n      }\r\n      setLoading(true);\r\n\r\n      // 2) Batch poolsReserves for missing tokens\r\n      const idsToQuery = missing\r\n        .map(t => t.id)\r\n        .filter(id => id !== REEF_TOKEN_ADDRESS.toLowerCase());\r\n      const batchMap = await fetchBatchReservesViaGraph(idsToQuery, signal);\r\n\r\n      // 3) Compute from batch rows; collect still-unresolved\r\n      const still: TokenInput[] = [];\r\n      for (const t of missing) {\r\n        const row = batchMap.get(t.id) ?? null;\r\n        if (row) {\r\n          const reefIs1 = (row.token1 || '').toLowerCase() === REEF_TOKEN_ADDRESS.toLowerCase();\r\n          const r1 = safeBigInt(row.reserved1);\r\n          const r2 = safeBigInt(row.reserved2);\r\n          const reefDec = 18;\r\n          const tokDec = t.decimals ?? 18;\r\n          const reserveReef = reefIs1 ? r1 : r2;\r\n          const reserveTok = reefIs1 ? r2 : r1;\r\n          // Low-liquidity guard: skip price if REEF side is too small\r\n          const reefReserveFloat = toFloatApprox(reserveReef) / Math.pow(10, reefDec);\r\n          if (!Number.isFinite(reefReserveFloat) || reefReserveFloat < MIN_REEF_RESERVE) {\r\n            next[t.id] = null;\r\n            continue;\r\n          }\r\n          const num = reserveReef * pow10(tokDec);\r\n          const den = reserveTok * pow10(reefDec);\r\n          const val = den === 0n ? null : (toFloatApprox(num) / toFloatApprox(den)) * (reefPrice.usd ?? 0);\r\n          if (typeof val === 'number' && Number.isFinite(val) && val > 0) {\r\n            next[t.id] = val;\r\n            priceTtl.set(`${t.id}:${t.decimals}`, val);\r\n            continue;\r\n          }\r\n        }\r\n        still.push(t);\r\n      }\r\n\r\n      // 4) Fallback per-token graph queries for unresolved (limit concurrency)\r\n      async function pLimitMap<T>(items: T[], limit: number, worker: (item: T, index: number) => Promise<void>) {\r\n        let index = 0;\r\n        const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {\r\n          while (index < items.length) {\r\n            const i = index++;\r\n            await worker(items[i]!, i);\r\n          }\r\n        });\r\n        await Promise.all(workers);\r\n      }\r\n      await pLimitMap(still, 4, async (t) => {\r\n        const val = await fetchTokenPriceUsd(t, reefPrice.usd, signal);\r\n        if (typeof val === 'number' && Number.isFinite(val) && val > 0) {\r\n          priceTtl.set(`${t.id}:${t.decimals}`, val);\r\n        }\r\n        next[t.id] = val ?? null;\r\n      });\r\n      if (!aborted) {\r\n        setPrices(next);\r\n        setLoading(false);\r\n      }\r\n    }\r\n    run();\r\n    return () => { aborted = true; ac.abort(); };\r\n  }, [reefPrice?.usd, uniqKey]);\r\n\r\n  return { pricesById: prices, loading: loading || reefLoading };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-token-usd-then.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1399,1402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1399,1402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4360,4363],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4360,4363],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5264,5267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5264,5267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useState } from 'react';\r\nimport type { ApolloClient, NormalizedCacheObject } from '@apollo/client';\r\nimport { reefSwapClient } from '@/reef-swap-client';\r\nimport { NEAREST_SWAP_FOR_TOKEN_DOCUMENT } from '@/data/reef-swap';\r\nimport { useReefPriceHistory } from '@/hooks/use-reef-price-history';\r\nimport { TtlCache } from '@/data/ttl-cache';\r\n\r\nexport interface UseTokenUsdThenInput {\r\n  tokenId?: string | null;\r\n  decimals?: number | null;\r\n  blockHeight?: number | null;\r\n  extrinsicIndex?: number | null;\r\n  timestamp?: string | number | null;\r\n}\r\n\r\nexport interface UseTokenUsdThenResult {\r\n  usdThenPerUnit: number | null;\r\n  loading: boolean;\r\n  error?: Error;\r\n}\r\n\r\nconst cache = new TtlCache<number>({\r\n  namespace: 'reef:token-usd-then',\r\n  defaultTtlMs: 6 * 60 * 60 * 1000,\r\n  persist: true,\r\n  maxSize: 5000,\r\n});\r\n\r\nfunction toDayUTC(ms: number): string { return new Date(ms).toISOString().slice(0, 10); }\r\n\r\nfunction toFloat(amount: unknown, decimals: number): number {\r\n  try {\r\n    const s = String(amount ?? '0');\r\n    if (!/^-?\\d+$/.test(s)) return 0;\r\n    const bi = BigInt(s);\r\n    if (decimals <= 0) return Number(bi);\r\n    const div = 10n ** BigInt(decimals);\r\n    const ip = bi / div; const fp = (bi % div).toString().padStart(decimals, '0');\r\n    return parseFloat(`${ip}.${fp}`);\r\n  } catch { return 0; }\r\n}\r\n\r\nfunction reefPerTokenFromEvent(ev: any, reefIsToken1: boolean): number | null {\r\n  const a1 = toFloat(ev?.amount1, Number(ev?.pool?.token1?.decimals ?? 18));\r\n  const a2 = toFloat(ev?.amount2, Number(ev?.pool?.token2?.decimals ?? 18));\r\n  const in1 = toFloat(ev?.amountIn1, Number(ev?.pool?.token1?.decimals ?? 18));\r\n  const in2 = toFloat(ev?.amountIn2, Number(ev?.pool?.token2?.decimals ?? 18));\r\n  // Determine direction using non-zero inputs\r\n  if (reefIsToken1) {\r\n    // TOKEN -> REEF (in2, out1)\r\n    if (in2 > 0 && a1 > 0) return a1 / in2; // REEF per TOKEN\r\n    // REEF -> TOKEN (in1, out2)\r\n    if (in1 > 0 && a2 > 0) return in1 / a2; // REEF per TOKEN\r\n  } else {\r\n    // TOKEN -> REEF (in1, out2)\r\n    if (in1 > 0 && a2 > 0) return a2 / in1;\r\n    // REEF -> TOKEN (in2, out1)\r\n    if (in2 > 0 && a1 > 0) return in2 / a1;\r\n  }\r\n  // Fallback using amounts only (less reliable)\r\n  if (reefIsToken1 && a1 > 0 && a2 > 0) return a1 / a2;\r\n  if (!reefIsToken1 && a2 > 0 && a1 > 0) return a2 / a1;\r\n  return null;\r\n}\r\n\r\nexport function useTokenUsdThenFromSwap({ tokenId, decimals, blockHeight, extrinsicIndex, timestamp }: UseTokenUsdThenInput): UseTokenUsdThenResult {\r\n  const token = (tokenId || '').toLowerCase();\r\n  const dec = Math.max(0, Number(decimals ?? 18));\r\n  const { history } = useReefPriceHistory('max');\r\n  const [usdThen, setUsdThen] = useState<number | null>(null);\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<Error | undefined>(undefined);\r\n  const bh = Number(blockHeight);\r\n  const ex = Number(extrinsicIndex);\r\n\r\n  const dayKey = useMemo(() => {\r\n    if (timestamp == null) return null;\r\n    const ms = (() => { try { const t = Date.parse(String(timestamp)); return Number.isFinite(t) ? t : NaN; } catch { return NaN; } })();\r\n    return Number.isFinite(ms) ? toDayUTC(ms) : null;\r\n  }, [timestamp]);\r\n\r\n  const cacheKey = useMemo(() => {\r\n    return token && dayKey ? `${token}:${dayKey}` : null;\r\n  }, [token, dayKey]);\r\n\r\n  useEffect(() => {\r\n    let cancelled = false;\r\n    async function run() {\r\n      try {\r\n        setError(undefined);\r\n        if (!token || token.length !== 42) { setUsdThen(null); return; }\r\n        if (!dayKey || !history || typeof history[dayKey] !== 'number') { setUsdThen(null); return; }\r\n        const reefUsdThen = history[dayKey]!;\r\n        // Cache first\r\n        if (cacheKey) {\r\n          const c = cache.get(cacheKey);\r\n          if (typeof c === 'number') { setUsdThen(c); return; }\r\n        }\r\n        // Need block/idx for strict cutoff; if missing, use a high idx at given block or skip\r\n        const validBh = Number.isFinite(bh) ? Math.trunc(bh) : undefined;\r\n        const validEx = Number.isFinite(ex) ? Math.trunc(ex) : 9999;\r\n        if (validBh == null) { setUsdThen(null); return; }\r\n        const client = reefSwapClient as ApolloClient<NormalizedCacheObject>;\r\n        const { data } = await client.query({\r\n          query: NEAREST_SWAP_FOR_TOKEN_DOCUMENT as any,\r\n          variables: { reef: '0x0000000000000000000000000000000001000000', token, bh: validBh, ex: validEx },\r\n          fetchPolicy: 'network-only',\r\n        });\r\n        const edge = (data?.poolEventsConnection?.edges ?? [])[0];\r\n        const ev = edge?.node;\r\n        if (!ev) { setUsdThen(null); return; }\r\n        const token1Id = (ev?.pool?.token1?.id || '').toLowerCase();\r\n        const reefIsToken1 = token1Id === '0x0000000000000000000000000000000001000000';\r\n        const rpt = reefPerTokenFromEvent(ev, reefIsToken1);\r\n        if (rpt == null || !(rpt > 0)) { setUsdThen(null); return; }\r\n        const usdPerToken = rpt * reefUsdThen;\r\n        if (!Number.isFinite(usdPerToken) || !(usdPerToken > 0)) { setUsdThen(null); return; }\r\n        if (!cancelled) {\r\n          setUsdThen(usdPerToken);\r\n          if (cacheKey) cache.set(cacheKey, usdPerToken);\r\n        }\r\n      } catch (e: any) {\r\n        if (!cancelled) { setUsdThen(null); setError(e instanceof Error ? e : new Error('usd then lookup failed')); }\r\n      } finally {\r\n        if (!cancelled) setLoading(false);\r\n      }\r\n    }\r\n    // Reset loading and value then run\r\n    setUsdThen(null);\r\n    setLoading(true);\r\n    run();\r\n    return () => { cancelled = true; };\r\n  }, [token, dec, bh, ex, dayKey, history, cacheKey]);\r\n\r\n  return { usdThenPerUnit: usdThen, loading, error } as const;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-tps-live.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2094,2097],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2094,2097],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":70,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":70,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[2250,2250],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3056,3059],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3056,3059],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":100,"column":13,"nodeType":"BlockStatement","messageId":"unexpected","endLine":100,"endColumn":15,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[3767,3767],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":108,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4048,4051],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4048,4051],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":108,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4068,4071],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4068,4071],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4168,4171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4168,4171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":176,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":176,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[6895,6895],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":199,"column":15,"nodeType":"BlockStatement","messageId":"unexpected","endLine":199,"endColumn":17,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[7731,7731],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useRef, useState } from 'react';\r\nimport { gql, useQuery, useSubscription } from '@apollo/client';\r\n\r\nconst LATEST_BLOCK = gql`\r\n  query LatestBlockForTps {\r\n    blocks(orderBy: height_DESC, limit: 1) { height timestamp }\r\n  }\r\n`;\r\n\r\nconst EXTRINSICS_STREAM = gql`\r\n  subscription ExtrinsicsFromHeight($fromHeight: Int!, $limit: Int!) {\r\n    extrinsics(\r\n      where: { block: { height_gt: $fromHeight } }\r\n      orderBy: [id_ASC]\r\n      limit: $limit\r\n    ) {\r\n      id\r\n      block { timestamp }\r\n    }\r\n  }\r\n`;\r\n\r\nconst TRANSFERS_STREAM = gql`\r\n  subscription TransfersFromHeight($fromHeight: Int!, $limit: Int!) {\r\n    transfers(\r\n      where: { blockHeight_gt: $fromHeight }\r\n      orderBy: [id_ASC]\r\n      limit: $limit\r\n    ) {\r\n      id\r\n      timestamp\r\n    }\r\n  }\r\n`;\r\n\r\ninterface Sample { t: number; c: number }\r\n\r\nconst STORAGE_KEY = 'tps_live_state_v2';\r\n\r\nexport function useTpsLive(windowSec = 60, source: 'extrinsics' | 'transfers' = 'extrinsics') {\r\n  const [fromHeight, setFromHeight] = useState<number | null>(null);\r\n  const [tps, setTps] = useState<number>(0);\r\n  const [perMin, setPerMin] = useState<number>(0);\r\n  const [tpsTrend, setTpsTrend] = useState<number[]>([]);\r\n  const buf = useRef<Sample[]>([]);\r\n  const lastTpsRef = useRef<number>(0);\r\n  const lastPerMinRef = useRef<number>(0);\r\n  const trendRef = useRef<number[]>([]);\r\n  // Track per-second counts for spiky visualization\r\n  const lastSecondRef = useRef<number>(Math.floor(Date.now() / 1000));\r\n  const currentSecondCountRef = useRef<number>(0);\r\n\r\n  const { refetch: refetchLatest } = useQuery(LATEST_BLOCK, {\r\n    fetchPolicy: 'network-only',\r\n    notifyOnNetworkStatusChange: false,\r\n    onCompleted: (d) => {\r\n      const h = d?.blocks?.[0]?.height as number | undefined;\r\n      if (typeof h === 'number') setFromHeight(h);\r\n    },\r\n  });\r\n\r\n  // На восстановление WS/онлайн — подтянуть последний height и тем самым пересоздать подписку\r\n  useEffect(() => {\r\n    const handler = () => {\r\n      try {\r\n        refetchLatest?.().then((res) => {\r\n          const h = (res as any)?.data?.blocks?.[0]?.height as number | undefined;\r\n          if (typeof h === 'number') setFromHeight(h);\r\n        }).catch(() => {});\r\n      } catch {}\r\n    };\r\n    window.addEventListener('ws-connected', handler as EventListener);\r\n    window.addEventListener('online', handler as EventListener);\r\n    return () => {\r\n      window.removeEventListener('ws-connected', handler as EventListener);\r\n      window.removeEventListener('online', handler as EventListener);\r\n    };\r\n  }, [refetchLatest]);\r\n\r\n  // Restore recent state from localStorage on mount\r\n  useEffect(() => {\r\n    try {\r\n      const raw = localStorage.getItem(STORAGE_KEY);\r\n      if (!raw) return;\r\n      const parsed = JSON.parse(raw) as { ts?: number; windowSec?: number; buf?: Sample[]; trend?: number[]; lastTps?: number; lastPerMin?: number };\r\n      const cutoff = Date.now() - windowSec * 1000;\r\n      const restoredBuf = Array.isArray(parsed?.buf)\r\n        ? parsed.buf.filter((s: any) => typeof s?.t === 'number' && typeof s?.c === 'number' && s.t >= cutoff)\r\n        : [];\r\n      buf.current = restoredBuf;\r\n      trendRef.current = Array.isArray(parsed?.trend) ? parsed.trend.filter((n) => typeof n === 'number').slice(-windowSec) : [];\r\n      lastTpsRef.current = typeof parsed?.lastTps === 'number' ? parsed.lastTps : 0;\r\n      lastPerMinRef.current = typeof parsed?.lastPerMin === 'number' ? parsed.lastPerMin : 0;\r\n      // seed state from restored data\r\n      const seededTps = currentTps(buf.current, windowSec);\r\n      const seededPerMin = currentCount(buf.current);\r\n      setTps(seededTps);\r\n      setPerMin(seededPerMin);\r\n      setTpsTrend([...trendRef.current]);\r\n    } catch {}\r\n  }, [windowSec]);\r\n\r\n  const streamDoc = source === 'transfers' ? TRANSFERS_STREAM : EXTRINSICS_STREAM;\r\n  useSubscription(streamDoc, {\r\n    skip: fromHeight == null,\r\n    variables: { fromHeight: fromHeight ?? 0, limit: 5 },\r\n    onData: ({ data }) => {\r\n      const payload: any = data?.data as any;\r\n      const xs = (source === 'transfers' ? payload?.transfers : payload?.extrinsics) as Array<any> | undefined;\r\n      if (!xs || xs.length === 0) return;\r\n      const now = Date.now();\r\n      const currentSecond = Math.floor(now / 1000);\r\n      \r\n      // Track per-second counts for spiky visualization\r\n      if (currentSecond !== lastSecondRef.current) {\r\n        // New second - push previous count to trend and reset\r\n        lastSecondRef.current = currentSecond;\r\n        currentSecondCountRef.current = xs.length;\r\n      } else {\r\n        // Same second - accumulate\r\n        currentSecondCountRef.current += xs.length;\r\n      }\r\n      \r\n      pushSample(buf.current, now, xs.length, windowSec);\r\n      const nextTps = currentTps(buf.current, windowSec);\r\n      const nextPerMin = currentCount(buf.current);\r\n      if (Math.abs(nextTps - lastTpsRef.current) >= 0.005) {\r\n        lastTpsRef.current = nextTps;\r\n        setTps(nextTps);\r\n      }\r\n      if (Math.abs(nextPerMin - lastPerMinRef.current) >= 1) {\r\n        lastPerMinRef.current = nextPerMin;\r\n        setPerMin(nextPerMin);\r\n      }\r\n    },\r\n    onError: () => {},\r\n  });\r\n\r\n  useEffect(() => {\r\n    let intervalId: number | null = null;\r\n    function tick() {\r\n      const now = Date.now();\r\n      const currentSecond = Math.floor(now / 1000);\r\n      const nextTps = currentTps(buf.current, windowSec);\r\n      const nextPerMin = currentCount(buf.current);\r\n      if (Math.abs(nextTps - lastTpsRef.current) >= 0.005) {\r\n        lastTpsRef.current = nextTps;\r\n        setTps(nextTps);\r\n      }\r\n      if (Math.abs(nextPerMin - lastPerMinRef.current) >= 1 || nextPerMin === 0) {\r\n        lastPerMinRef.current = nextPerMin;\r\n        setPerMin(nextPerMin);\r\n      }\r\n      \r\n      // Push per-second count to trend (shows spikes when transactions arrive)\r\n      if (currentSecond !== lastSecondRef.current) {\r\n        // Finalize previous second's count and start new\r\n        trendRef.current.push(currentSecondCountRef.current);\r\n        lastSecondRef.current = currentSecond;\r\n        currentSecondCountRef.current = 0;\r\n      } else {\r\n        // Update last value with current second's count\r\n        if (trendRef.current.length > 0) {\r\n          trendRef.current[trendRef.current.length - 1] = currentSecondCountRef.current;\r\n        } else {\r\n          trendRef.current.push(currentSecondCountRef.current);\r\n        }\r\n      }\r\n      \r\n      if (trendRef.current.length > windowSec) trendRef.current.shift();\r\n      setTpsTrend([...trendRef.current]);\r\n      // persist compact state\r\n      try {\r\n        const snapshot = { ts: Date.now(), windowSec, buf: buf.current, trend: trendRef.current, lastTps: lastTpsRef.current, lastPerMin: lastPerMinRef.current };\r\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));\r\n      } catch {}\r\n    }\r\n    function start() {\r\n      if (intervalId) window.clearInterval(intervalId);\r\n      const period = document.hidden ? 5000 : 1000;\r\n      tick();\r\n      intervalId = window.setInterval(tick, period);\r\n    }\r\n    start();\r\n    const onVis = () => start();\r\n    document.addEventListener('visibilitychange', onVis);\r\n    return () => {\r\n      if (intervalId) window.clearInterval(intervalId);\r\n      document.removeEventListener('visibilitychange', onVis);\r\n    };\r\n  }, [windowSec]);\r\n\r\n  // Save on page close\r\n  useEffect(() => {\r\n    const onUnload = () => {\r\n      try {\r\n        const snapshot = { ts: Date.now(), windowSec, buf: buf.current, trend: trendRef.current, lastTps: lastTpsRef.current, lastPerMin: lastPerMinRef.current };\r\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot));\r\n      } catch {}\r\n    };\r\n    window.addEventListener('beforeunload', onUnload);\r\n    return () => window.removeEventListener('beforeunload', onUnload);\r\n  }, [windowSec]);\r\n\r\n  return useMemo(() => ({ tps, perMin, tpsTrend }), [tps, perMin, tpsTrend]);\r\n}\r\n\r\nfunction pushSample(buf: Sample[], t: number, c: number, windowSec: number) {\r\n  buf.push({ t, c });\r\n  const cutoff = Date.now() - windowSec * 1000;\r\n  while (buf.length && buf[0].t < cutoff) buf.shift();\r\n}\r\n\r\nfunction currentTps(buf: Sample[], windowSec: number) {\r\n  const sum = buf.reduce((acc, s) => acc + s.c, 0);\r\n  return sum / windowSec;\r\n}\r\n\r\nfunction currentCount(buf: Sample[]) {\r\n  const sum = buf.reduce((acc, s) => acc + s.c, 0);\r\n  return sum;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-transaction-data-with-blocks.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":137,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5686,5689],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5686,5689],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5781,5784],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5781,5784],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'enriched' is never reassigned. Use 'const' instead.","line":146,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":146,"endColumn":17,"fix":{"range":[6010,6133],"text":"const enriched = (minReefRaw || maxReefRaw)\r\n      ? sortTransfersByAmount(mapped)\r\n      : sortTransfersByTimestamp(mapped);"}},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'metaVersion'. Either exclude it or remove the dependency array.","line":159,"column":6,"nodeType":"ArrayExpression","endLine":159,"endColumn":128,"suggestions":[{"desc":"Update the dependencies array to be: [data, resolvedAddress, resolvedEvmAddress, minReefRaw, maxReefRaw, partnersByHash, accountAddress, swapOnly]","fix":{"range":[6428,6550],"text":"[data, resolvedAddress, resolvedEvmAddress, minReefRaw, maxReefRaw, partnersByHash, accountAddress, swapOnly]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7339,7342],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7339,7342],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7344,7347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7344,7347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'list' is never reassigned. Use 'const' instead.","line":188,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":188,"endColumn":15,"fix":{"range":[7948,7994],"text":"const list = (q?.transfers || []) as Array<any>;"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":188,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":188,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7989,7992],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7989,7992],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8366,8369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8366,8369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8625,8628],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8625,8628],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8630,8633],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8630,8633],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":203,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8858,8861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8858,8861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_e' is defined but never used.","line":213,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":213,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":221,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9417,9420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9417,9420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'enriched' is never reassigned. Use 'const' instead.","line":226,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":226,"endColumn":19,"fix":{"range":[9598,9725],"text":"const enriched = (minReefRaw || maxReefRaw)\r\n        ? sortTransfersByAmount(mapped)\r\n        : sortTransfersByTimestamp(mapped);"}},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'erc20Only'. Either include it or remove the dependency array.","line":239,"column":6,"nodeType":"ArrayExpression","endLine":239,"endColumn":158,"suggestions":[{"desc":"Update the dependencies array to be: [resolvedAddress, resolvedEvmAddress, client, direction, minReefRaw, maxReefRaw, reefOnly, tokenIds, tokenMinRaw, tokenMaxRaw, erc20Only, swapOnly, accountAddress]","fix":{"range":[9985,10137],"text":"[resolvedAddress, resolvedEvmAddress, client, direction, minReefRaw, maxReefRaw, reefOnly, tokenIds, tokenMinRaw, tokenMaxRaw, erc20Only, swapOnly, accountAddress]"}}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { useQuery, ApolloError, useApolloClient } from '@apollo/client';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport type { ApolloClient, NormalizedCacheObject } from '@apollo/client';\r\nimport { PAGINATED_TRANSFERS_QUERY, PAGINATED_TRANSFERS_MIN_QUERY, TRANSFERS_POLLING_QUERY } from '../data/transfers';\r\nimport type { TransferOrderByInput, TransfersMinQueryQuery as TransfersQuery, TransfersMinQueryQueryVariables as TransfersQueryVariables } from '@/gql/graphql';\r\nimport { mapTransfersToUiTransfers, type UiTransfer } from '../data/transfer-mapper';\r\nimport { useAddressResolver } from './use-address-resolver';\r\nimport { buildTransferWhereFilter, type TransactionDirection } from '@/utils/transfer-query';\r\nimport { isValidEvmAddressFormat, isValidSubstrateAddressFormat } from '@/utils/address-helpers';\r\nimport {\r\n  ensureUniqueTransfers,\r\n  sortTransfersByAmount,\r\n  sortTransfersByTimestamp,\r\n  aggregateSwaps,\r\n  identifyMissingPartnerHashes\r\n} from '@/utils/transfer-helpers';\r\nimport { useSwapPartnerLegs } from './use-swap-partner-legs';\r\nimport { useTokenMetadataResolver } from './use-token-metadata-resolver';\r\n\r\n\r\nexport interface UseTransactionDataReturn {\r\n  transfers: UiTransfer[];\r\n  loading: boolean;\r\n  error?: ApolloError | Error;\r\n  hasMore: boolean;\r\n  totalCount?: number;\r\n  fetchMore: () => Promise<void>;\r\n  /** Fetch a specific window using offset/limit with the same filters and ordering */\r\n  fetchWindow: (offset: number, limit: number) => Promise<UiTransfer[]>;\r\n}\r\n\r\nexport function useTransactionDataWithBlocks(\r\n  accountAddress: string | null | undefined,\r\n  limit: number,\r\n  direction: TransactionDirection = 'any',\r\n  minReefRaw?: string | bigint | null,\r\n  maxReefRaw?: string | bigint | null,\r\n  reefOnly: boolean = false,\r\n  tokenIds: string[] | null = null,\r\n  tokenMinRaw: string | bigint | null = null,\r\n  tokenMaxRaw: string | bigint | null = null,\r\n  erc20Only: boolean = false,\r\n  swapOnly: boolean = false,\r\n): UseTransactionDataReturn {\r\n\r\n  const { resolveBoth } = useAddressResolver();\r\n  const [resolvedAddress, setResolvedAddress] = useState<string | null>(null);\r\n  const [resolvedEvmAddress, setResolvedEvmAddress] = useState<string | null>(null);\r\n\r\n  const [isResolvingAddress, setIsResolvingAddress] = useState(false);\r\n  const client = useApolloClient();\r\n\r\n  useEffect(() => {\r\n    if (!accountAddress) {\r\n      setResolvedAddress(null);\r\n      setResolvedEvmAddress(null);\r\n      return;\r\n    }\r\n\r\n    const input = accountAddress.trim();\r\n    if (!input) {\r\n      setResolvedAddress(null);\r\n      setResolvedEvmAddress(null);\r\n      return;\r\n    }\r\n\r\n    // Optimistic: start querying immediately using the provided address format\r\n    // (0x uses *_EvmAddress fields; SS58 uses from/to.id)\r\n    if (isValidEvmAddressFormat(input)) {\r\n      setResolvedAddress(null);\r\n      setResolvedEvmAddress(input);\r\n    } else if (isValidSubstrateAddressFormat(input)) {\r\n      setResolvedAddress(input);\r\n      setResolvedEvmAddress(null);\r\n    }\r\n\r\n    const resolveAndSet = async () => {\r\n      setIsResolvingAddress(true);\r\n      try {\r\n        // Optimized: single query returns both nativeId and evmAddress\r\n        const { nativeId, evmAddress } = await resolveBoth(input);\r\n        setResolvedAddress(nativeId);\r\n        setResolvedEvmAddress(evmAddress);\r\n      } catch (error) {\r\n        console.error('Failed to resolve address:', error);\r\n        setResolvedAddress(null); // Set to null on error to prevent invalid queries\r\n        setResolvedEvmAddress(null);\r\n      }\r\n      finally {\r\n        setIsResolvingAddress(false);\r\n      }\r\n    };\r\n\r\n    resolveAndSet();\r\n  }, [accountAddress, resolveBoth]);\r\n\r\n  const pagedDoc = ((tokenIds && tokenIds.length > 0) || reefOnly || swapOnly)\r\n    ? PAGINATED_TRANSFERS_MIN_QUERY\r\n    : PAGINATED_TRANSFERS_QUERY;\r\n\r\n  const { data, loading, error, fetchMore: apolloFetchMore } = \r\n    useQuery<TransfersQuery, TransfersQueryVariables>(\r\n      pagedDoc as unknown as TypedDocumentNode<TransfersQuery, TransfersQueryVariables>,\r\n      {\r\n        variables: {\r\n          first: limit,\r\n          where: buildTransferWhereFilter({ resolvedAddress, resolvedEvmAddress, direction, minReefRaw, maxReefRaw, reefOnly, tokenIds, tokenMinRaw, tokenMaxRaw, erc20Only, excludeSwapLegs: !swapOnly }),\r\n          orderBy: ((minReefRaw || maxReefRaw || tokenMinRaw || tokenMaxRaw) ? ['amount_ASC', 'id_ASC'] : ['timestamp_DESC', 'id_DESC']) as TransferOrderByInput[],\r\n        },\r\n        skip: !resolvedAddress && !resolvedEvmAddress,\r\n        notifyOnNetworkStatusChange: false,\r\n        fetchPolicy: 'cache-and-network',\r\n      }\r\n    );\r\n\r\n  // Extract partner legs logic\r\n  const { partnersByHash, setPartnersByHash } = useSwapPartnerLegs({ data, swapOnly, enabled: !!(resolvedAddress || resolvedEvmAddress) });\r\n  \r\n  // Extract token metadata resolving logic\r\n  const { metaVersion } = useTokenMetadataResolver({ data });\r\n\r\n  // Reset partners when address changes\r\n  useEffect(() => {\r\n    setPartnersByHash({});\r\n  }, [resolvedAddress, resolvedEvmAddress, direction, minReefRaw, maxReefRaw, reefOnly, tokenIds, tokenMinRaw, tokenMaxRaw, setPartnersByHash]);\r\n\r\n  const uiTransfers = useMemo(() => {\r\n    const edges = data?.transfersConnection.edges || [];\r\n    if (edges.length === 0) {\r\n      return [];\r\n    }\r\n\r\n    // Merge partner legs (if any) before mapping/aggregation in Swap mode only\r\n    const partnerList = Object.values(partnersByHash).flat();\r\n    const combinedEdges = swapOnly && partnerList.length > 0\r\n      ? [...(edges as unknown as Array<{ node: any }>), ...partnerList.map((n) => ({ node: n }))]\r\n      : (edges as unknown as Array<{ node: any }>);\r\n\r\n    const mapped = mapTransfersToUiTransfers(\r\n      combinedEdges,\r\n      accountAddress ?? resolvedAddress ?? resolvedEvmAddress ?? undefined\r\n    );\r\n\r\n    // Enforce global stable order matching server order\r\n    let enriched = (minReefRaw || maxReefRaw)\r\n      ? sortTransfersByAmount(mapped)\r\n      : sortTransfersByTimestamp(mapped);\r\n\r\n    // Belt-and-suspenders: ensure unique transfers by id\r\n    const unique = ensureUniqueTransfers(enriched);\r\n\r\n    if (!swapOnly) {\r\n      // All/Incoming/Outgoing: return plain transfers without building SWAP rows\r\n      return unique;\r\n    }\r\n\r\n    return aggregateSwaps(unique);\r\n  }, [data, resolvedAddress, resolvedEvmAddress, minReefRaw, maxReefRaw, partnersByHash, metaVersion, accountAddress, swapOnly]);\r\n\r\n  const fetchMore = useCallback(async () => {\r\n    if (!apolloFetchMore || !data?.transfersConnection.pageInfo.hasNextPage) return;\r\n    await apolloFetchMore({\r\n      variables: {\r\n        after: data.transfersConnection.pageInfo.endCursor,\r\n      },\r\n    });\r\n  }, [apolloFetchMore, data]);\r\n\r\n  // Fast windowed fetch by offset/limit with same where/orderBy\r\n  const fetchWindow = useCallback(async (offset: number, limit: number): Promise<UiTransfer[]> => {\r\n    if (!resolvedAddress && !resolvedEvmAddress) return [];\r\n    try {\r\n      const { data: q } = await (client as ApolloClient<NormalizedCacheObject>).query(\r\n        {\r\n          // Use polling query since it exposes offset/limit on plain list\r\n          query: TRANSFERS_POLLING_QUERY as unknown as TypedDocumentNode<any, any>,\r\n          variables: {\r\n            where: buildTransferWhereFilter({ resolvedAddress, resolvedEvmAddress, direction, minReefRaw, maxReefRaw, reefOnly, tokenIds, tokenMinRaw, tokenMaxRaw, erc20Only, excludeSwapLegs: !swapOnly }),\r\n            orderBy: ((minReefRaw || maxReefRaw || tokenMinRaw || tokenMaxRaw) ? ['amount_ASC', 'id_ASC'] : ['timestamp_DESC', 'id_DESC']) as TransferOrderByInput[],\r\n            offset: Math.max(0, Math.floor(offset) || 0),\r\n            limit: Math.max(1, Math.floor(limit) || 1),\r\n          },\r\n          fetchPolicy: 'network-only',\r\n        }\r\n      );\r\n\r\n      let list = (q?.transfers || []) as Array<any>;\r\n      // Light mode: skip partner fetch in window path to avoid extra queries\r\n      if (!swapOnly) {\r\n        try {\r\n          const missing = identifyMissingPartnerHashes(list, new Set(), { strict: true });\r\n          if (missing.length > 0) {\r\n            // Important: do NOT restrict by address here; partner legs may not involve the user\r\n            const where: any = { extrinsicHash_in: missing, reefswapAction_isNull: false };\r\n            const { data: q2 } = await (client as ApolloClient<NormalizedCacheObject>).query(\r\n              {\r\n                query: TRANSFERS_POLLING_QUERY as unknown as TypedDocumentNode<any, any>,\r\n                variables: { where, limit: Math.min(missing.length * 20, 500) },\r\n                fetchPolicy: 'network-only',\r\n              }\r\n            );\r\n            const partners = (q2?.transfers || []) as Array<any>;\r\n            if (partners.length > 0) {\r\n              const seen = new Set(list.map((n) => n?.id));\r\n              for (const p of partners) {\r\n                if (!p?.id || seen.has(p.id)) continue;\r\n                list.push(p);\r\n                seen.add(p.id);\r\n              }\r\n            }\r\n          }\r\n        } catch (_e) {\r\n          // best-effort; ignore partner errors in window mode\r\n        }\r\n      }\r\n      if (!list.length) return [];\r\n\r\n      // Map to UI model\r\n      const mapped = mapTransfersToUiTransfers(\r\n        list.map((n: any) => ({ node: n })),\r\n        accountAddress ?? resolvedAddress ?? resolvedEvmAddress ?? undefined\r\n      );\r\n      \r\n      // Enforce global order consistent with server\r\n      let enriched = (minReefRaw || maxReefRaw)\r\n        ? sortTransfersByAmount(mapped)\r\n        : sortTransfersByTimestamp(mapped);\r\n\r\n      // Unique by id\r\n      const unique = ensureUniqueTransfers(enriched);\r\n\r\n      if (!swapOnly) return unique;\r\n      return aggregateSwaps(unique);\r\n    } catch (e) {\r\n      console.warn('[tx][fetchWindow] failed', e);\r\n      return [];\r\n    }\r\n  }, [client, resolvedAddress, resolvedEvmAddress, direction, minReefRaw, maxReefRaw, reefOnly, tokenIds, tokenMinRaw, tokenMaxRaw, accountAddress, swapOnly]);\r\n\r\n  const isLoading = loading || (isResolvingAddress && !data);\r\n  const totalError = error; // Do not create a new error for the resolving state\r\n\r\n  return {\r\n    transfers: uiTransfers,\r\n    loading: isLoading,\r\n    error: totalError,\r\n    hasMore: data?.transfersConnection.pageInfo.hasNextPage || false,\r\n    totalCount: data?.transfersConnection.totalCount,\r\n    fetchMore,\r\n    fetchWindow,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-transaction-filter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[874,877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[874,877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[906,909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[906,909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[959,962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[959,962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[991,994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[991,994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1831,1834],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1831,1834],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1935,1938],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1935,1938],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2350,2353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2350,2353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":63,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2602,2605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2602,2605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2706,2709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2706,2709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":78,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":81,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3248,3251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3248,3251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3304,3307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3304,3307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3543,3546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3543,3546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3647,3650],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3647,3650],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4157,4160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4157,4160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isValidEvmAddressFormat } from '@/utils/address-helpers';\r\nimport { useMemo } from 'react';\r\nimport { UiTransfer } from '../data/transfer-mapper';\r\nimport { isReefToken, isUsdcByName, safeBigInt } from '@/utils/token-helpers';\r\nimport { isUsdcId } from '@/tokens/token-ids';\r\n\r\ninterface UseTransactionFilterProps {\r\n  initialTransactions: UiTransfer[];\r\n  tokenFilter: string;\r\n  tokenMinRaw?: string | null;\r\n  tokenMaxRaw?: string | null;\r\n  softFallbackActive: boolean;\r\n  serverTokenIds: string[] | null;\r\n  swapOnly: boolean;\r\n}\r\n\r\nexport function useTransactionFilter({\r\n  initialTransactions,\r\n  tokenFilter,\r\n  tokenMinRaw,\r\n  tokenMaxRaw,\r\n  softFallbackActive,\r\n  serverTokenIds,\r\n  swapOnly,\r\n}: UseTransactionFilterProps) {\r\n  return useMemo(() => {\r\n    const all = initialTransactions || [];\r\n    const list = swapOnly\r\n      ? all.filter(t => (t as any).method === 'swap' || (t as any).type === 'SWAP')\r\n      : all.filter(t => (t as any).method !== 'swap' && (t as any).type !== 'SWAP');\r\n    \r\n    if (tokenFilter === 'all') return list;\r\n\r\n    const addrLower = isValidEvmAddressFormat(tokenFilter) ? tokenFilter.toLowerCase() : undefined;\r\n\r\n    const minRaw = tokenMinRaw != null && tokenMinRaw !== '' ? safeBigInt(tokenMinRaw) : null;\r\n    const maxRaw = tokenMaxRaw != null && tokenMaxRaw !== '' ? safeBigInt(tokenMaxRaw) : null;\r\n    \r\n    const passesAmt = (amt: bigint): boolean => {\r\n      if (minRaw !== null && amt < minRaw) return false;\r\n      if (maxRaw !== null && amt > maxRaw) return false;\r\n      return true;\r\n    };\r\n\r\n    const useNameFallback = softFallbackActive || !serverTokenIds || serverTokenIds.length === 0;\r\n\r\n    return list.filter(t => {\r\n      if (tokenFilter === 'reef') {\r\n        if (t.method === 'swap' && t.swapInfo) {\r\n          const soldAmt = (t.swapInfo.sold as any).amountBI ?? safeBigInt(t.swapInfo.sold.amount);\r\n          const boughtAmt = (t.swapInfo.bought as any).amountBI ?? safeBigInt(t.swapInfo.bought.amount);\r\n          const soldOk = isReefToken(t.swapInfo.sold.token) && (!minRaw && !maxRaw ? true : passesAmt(soldAmt));\r\n          const boughtOk = isReefToken(t.swapInfo.bought.token) && (!minRaw && !maxRaw ? true : passesAmt(boughtAmt));\r\n          return soldOk || boughtOk;\r\n        }\r\n        if (!isReefToken(t.token)) return false;\r\n        const amt = (t as any).amountBI ?? safeBigInt(t.amount);\r\n        return (!minRaw && !maxRaw) ? true : passesAmt(amt);\r\n      }\r\n      \r\n      if (tokenFilter === 'usdc') {\r\n        if (t.method === 'swap' && t.swapInfo) {\r\n          const soldAmt = (t.swapInfo.sold as any).amountBI ?? safeBigInt(t.swapInfo.sold.amount);\r\n          const boughtAmt = (t.swapInfo.bought as any).amountBI ?? safeBigInt(t.swapInfo.bought.amount);\r\n          const soldOk = (isUsdcId(t.swapInfo.sold.token.id) || (useNameFallback && isUsdcByName(t.swapInfo.sold.token))) && (!minRaw && !maxRaw ? true : passesAmt(soldAmt));\r\n          const boughtOk = (isUsdcId(t.swapInfo.bought.token.id) || (useNameFallback && isUsdcByName(t.swapInfo.bought.token))) && (!minRaw && !maxRaw ? true : passesAmt(boughtAmt));\r\n          return soldOk || boughtOk;\r\n        }\r\n        if (!(isUsdcId(t.token.id) || (useNameFallback && isUsdcByName((t as any).token)))) return false;\r\n        const amt = (t as any).amountBI ?? safeBigInt(t.amount);\r\n        return (!minRaw && !maxRaw) ? true : passesAmt(amt);\r\n      }\r\n      \r\n      if (addrLower) {\r\n        if (t.method === 'swap' && t.swapInfo) {\r\n          const soldAmt = (t.swapInfo.sold as any).amountBI ?? safeBigInt(t.swapInfo.sold.amount);\r\n          const boughtAmt = (t.swapInfo.bought as any).amountBI ?? safeBigInt(t.swapInfo.bought.amount);\r\n          const soldOk = String(t.swapInfo.sold.token.id || '').toLowerCase() === addrLower && (!minRaw && !maxRaw ? true : passesAmt(soldAmt));\r\n          const boughtOk = String(t.swapInfo.bought.token.id || '').toLowerCase() === addrLower && (!minRaw && !maxRaw ? true : passesAmt(boughtAmt));\r\n          return soldOk || boughtOk;\r\n        }\r\n        if (String(t.token.id || '').toLowerCase() !== addrLower) return false;\r\n        const amt = (t as any).amountBI ?? safeBigInt(t.amount);\r\n        return (!minRaw && !maxRaw) ? true : passesAmt(amt);\r\n      }\r\n      \r\n      return true;\r\n    });\r\n  }, [initialTransactions, tokenFilter, tokenMinRaw, tokenMaxRaw, softFallbackActive, serverTokenIds, swapOnly]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\use-ws-status.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1477,1480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1477,1480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1744,1747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1744,1747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1973,1976],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1973,1976],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'startCountdown'. Either include it or remove the dependency array.","line":73,"column":6,"nodeType":"ArrayExpression","endLine":73,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [startCountdown]","fix":{"range":[3008,3010],"text":"[startCountdown]"}}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef, useState } from 'react';\r\n\r\nexport interface WsStatus {\r\n  text: string;\r\n  tone: 'live' | 'warning' | 'error' | 'info';\r\n}\r\n\r\nexport function useWsStatus(): WsStatus {\r\n  const [status, setStatus] = useState<WsStatus>({ text: 'Live', tone: 'live' });\r\n  const retryEndRef = useRef<number | null>(null);\r\n  const retryAttemptRef = useRef<number>(1);\r\n  const timerRef = useRef<number | null>(null);\r\n\r\n  function clearTimer() {\r\n    if (timerRef.current) {\r\n      window.clearInterval(timerRef.current);\r\n      timerRef.current = null;\r\n    }\r\n    retryEndRef.current = null;\r\n  }\r\n\r\n  function startCountdown() {\r\n    clearTimer();\r\n    timerRef.current = window.setInterval(() => {\r\n      if (retryEndRef.current == null) return;\r\n      const remaining = Math.max(0, retryEndRef.current - Date.now());\r\n      const secs = Math.max(0.1, Math.round(remaining / 100) / 10);\r\n      if (remaining <= 0) {\r\n        clearTimer();\r\n        setStatus({ text: `Reconnecting... (attempt ${retryAttemptRef.current})`, tone: 'warning' });\r\n      } else {\r\n        setStatus({ text: `Reconnecting in ${secs}s (attempt ${retryAttemptRef.current})`, tone: 'warning' });\r\n      }\r\n    }, 250);\r\n  }\r\n\r\n  useEffect(() => {\r\n    const onOpened = () => { clearTimer(); setStatus({ text: 'Live', tone: 'live' }); };\r\n    const onConnected = () => { clearTimer(); setStatus({ text: 'Live', tone: 'live' }); };\r\n    const onClosed = (e: Event) => {\r\n      const detail: any = (e as CustomEvent).detail ?? {};\r\n      const code = detail.code != null ? ` (code ${detail.code})` : '';\r\n      setStatus({ text: `WebSocket closed${code}. Reconnecting...`, tone: 'warning' });\r\n    };\r\n    const onError = (e: Event) => {\r\n      const detail: any = (e as CustomEvent).detail ?? {};\r\n      const msg = detail.message ?? 'Unknown error';\r\n      setStatus({ text: `WebSocket error: ${msg}`, tone: 'error' });\r\n    };\r\n    const onRetry = (e: Event) => {\r\n      const detail: any = (e as CustomEvent).detail ?? {};\r\n      const tries = detail.tries ?? 1;\r\n      const delayMs = detail.delayMs ?? 0;\r\n      retryAttemptRef.current = tries;\r\n      retryEndRef.current = Date.now() + delayMs;\r\n      startCountdown();\r\n    };\r\n\r\n    window.addEventListener('ws-opened', onOpened as EventListener);\r\n    window.addEventListener('ws-connected', onConnected as EventListener);\r\n    window.addEventListener('ws-closed', onClosed as EventListener);\r\n    window.addEventListener('ws-error', onError as EventListener);\r\n    window.addEventListener('ws-retry', onRetry as EventListener);\r\n\r\n    return () => {\r\n      window.removeEventListener('ws-opened', onOpened as EventListener);\r\n      window.removeEventListener('ws-connected', onConnected as EventListener);\r\n      window.removeEventListener('ws-closed', onClosed as EventListener);\r\n      window.removeEventListener('ws-error', onError as EventListener);\r\n      window.removeEventListener('ws-retry', onRetry as EventListener);\r\n      clearTimer();\r\n    };\r\n  }, []);\r\n\r\n  return status;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\usePaginationAndSorting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\useStakingRewards.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1770,1773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1770,1773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1775,1778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1775,1778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2088,2091],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2088,2091],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2093,2096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2093,2096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2307,2310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2307,2310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useMemo, useState } from 'react';\r\nimport { useQuery } from '@apollo/client';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\nimport { STAKINGS_CONNECTION_QUERY, STAKINGS_LIST_QUERY } from '@/data/staking';\r\nimport { useAddressResolver } from './use-address-resolver';\r\n\r\nexport interface UiReward {\r\n  id: string;\r\n  amount: string; // base units (REEF 18)\r\n  timestamp: string;\r\n  extrinsicHash?: string | null;\r\n  signer: string;\r\n}\r\n\r\ninterface UseStakingRewardsReturn {\r\n  rewards: UiReward[];\r\n  loading: boolean;\r\n  error?: Error;\r\n  pageIndex: number;\r\n  pageCount: number;\r\n  setPageIndex: (i: number) => void;\r\n  totalCount: number;\r\n  pageSize: number;\r\n}\r\n\r\nexport function useStakingRewards(accountAddress: string | null | undefined, pageSize = 25): UseStakingRewardsReturn {\r\n  const { resolveAddress } = useAddressResolver();\r\n  const [resolved, setResolved] = useState<string | null>(null);\r\n  const [pageIndex, setPageIndex] = useState(0);\r\n\r\n  useEffect(() => {\r\n    let cancelled = false;\r\n    async function run() {\r\n      try {\r\n        if (!accountAddress) {\r\n          setResolved(null);\r\n          setPageIndex(0);\r\n          return;\r\n        }\r\n        const native = await resolveAddress(accountAddress);\r\n        if (!cancelled) {\r\n          setResolved(native);\r\n          setPageIndex(0); // reset on address change\r\n        }\r\n      } catch {\r\n        if (!cancelled) {\r\n          setResolved(null);\r\n          setPageIndex(0);\r\n        }\r\n      }\r\n    }\r\n    run();\r\n    return () => { cancelled = true; };\r\n  }, [accountAddress, resolveAddress]);\r\n\r\n  const { data: conn, loading: connLoading, error: connError } = useQuery(\r\n    STAKINGS_CONNECTION_QUERY as unknown as TypedDocumentNode<any, any>,\r\n    { variables: { accountId: resolved as string }, skip: !resolved }\r\n  );\r\n  const totalCount: number = (conn?.stakingsConnection?.totalCount ?? 0) as number;\r\n\r\n  const offset = pageIndex * pageSize;\r\n  const { data, loading, error } = useQuery(\r\n    STAKINGS_LIST_QUERY as unknown as TypedDocumentNode<any, any>,\r\n    { variables: { accountId: resolved as string, first: pageSize, after: offset }, skip: !resolved }\r\n  );\r\n\r\n  const rewards = useMemo<UiReward[]>(() => {\r\n    const list = (data?.stakings ?? []) as Array<any>;\r\n    return list.map((s) => ({\r\n      id: s.id,\r\n      amount: s.amount,\r\n      timestamp: s.timestamp,\r\n      extrinsicHash: s?.event?.extrinsic?.hash ?? null,\r\n      signer: s?.signer?.id ?? '',\r\n    }));\r\n  }, [data]);\r\n\r\n  const pageCount = totalCount > 0 ? Math.max(1, Math.ceil(totalCount / pageSize)) : 1;\r\n\r\n  return {\r\n    rewards,\r\n    loading: loading || connLoading,\r\n    error: (error as Error) ?? (connError as Error) ?? undefined,\r\n    pageIndex,\r\n    pageCount,\r\n    setPageIndex,\r\n    totalCount,\r\n    pageSize,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\useTanstackTransactionAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\hooks\\useTransferSubscription.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":164,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6243,6246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6243,6246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":213,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8654,8657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8654,8657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":223,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9141,9144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9141,9144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":226,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9277,9280],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9277,9280],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":227,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9332,9335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9332,9335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":239,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9795,9798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9795,9798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":248,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10205,10208],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10205,10208],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { sortTransfersByTimestamp, ensureUniqueTransfers } from '@/utils/transfer-helpers';\r\nimport { useRef, useEffect, useMemo, useState } from 'react';\r\nimport { useQuery, useApolloClient } from '@apollo/client';\r\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core';\r\n// removed unused ApolloClient types\r\nimport { mapTransfersToUiTransfers, type UiTransfer } from '../data/transfer-mapper';\r\nimport {\r\n  TransferOrderByInput,\r\n  TransfersPollingQueryQuery,\r\n  TransfersPollingQueryQueryVariables,\r\n  TransfersMinQueryQuery,\r\n  TransfersMinQueryQueryVariables,\r\n} from '@/gql/graphql';\r\nimport { TRANSFERS_POLLING_QUERY, PAGINATED_TRANSFERS_QUERY } from '../data/transfers';\r\nimport { PAGINATION_CONFIG } from '../constants/pagination';\r\nimport { useAddressResolver } from './use-address-resolver';\r\nimport { buildTransferWhereFilter, type TransactionDirection } from '@/utils/transfer-query';\r\nimport { createNewItemDetector } from '@/utils/transfer-new-items';\r\n\r\nconst MAX_SEEN_IDS = 200;\r\n\r\ninterface UseTransferSubscriptionProps {\r\n  address: string | null;\r\n  onNewTransfer: (transfer: UiTransfer) => void;\r\n  isEnabled: boolean;\r\n  direction?: TransactionDirection;\r\n  minReefRaw?: string | bigint | null;\r\n  maxReefRaw?: string | bigint | null;\r\n}\r\n\r\nexport function useTransferSubscription({\r\n  address,\r\n  onNewTransfer,\r\n  isEnabled,\r\n  direction = 'any',\r\n  minReefRaw = null,\r\n  maxReefRaw = null,\r\n}: UseTransferSubscriptionProps) {\r\n  const detectorRef = useRef(createNewItemDetector<UiTransfer>({ key: (t) => t.id, max: MAX_SEEN_IDS }));\r\n  const client = useApolloClient();\r\n  const { resolveBoth } = useAddressResolver();\r\n  const [resolvedAddress, setResolvedAddress] = useState<string | null>(null);\r\n  const [resolvedEvmAddress, setResolvedEvmAddress] = useState<string | null>(null);\r\n\r\n  // Resolve input address (EVM or Substrate) to:\r\n  // - canonical native ID used in transfers.from/to.id\r\n  // - evmAddress (0x...) to leverage fromEvmAddress_eq/toEvmAddress_eq filters\r\n  useEffect(() => {\r\n    if (!address) {\r\n      setResolvedAddress(null);\r\n      setResolvedEvmAddress(null);\r\n      return;\r\n    }\r\n    let cancelled = false;\r\n    const run = async () => {\r\n      try {\r\n        // Optimized: single query returns both nativeId and evmAddress\r\n        const { nativeId, evmAddress } = await resolveBoth(address);\r\n        if (!cancelled) {\r\n          setResolvedAddress(nativeId);\r\n          setResolvedEvmAddress(evmAddress);\r\n        }\r\n      } catch (error) {\r\n        console.error('Failed to resolve address:', error);\r\n        if (!cancelled) {\r\n          setResolvedAddress(null);\r\n          setResolvedEvmAddress(null);\r\n        }\r\n      }\r\n    };\r\n    run();\r\n    return () => { cancelled = true; };\r\n  }, [address, resolveBoth]);\r\n\r\n  const queryVariables = useMemo(() => {\r\n    const where = buildTransferWhereFilter({ resolvedAddress, resolvedEvmAddress, direction, minReefRaw, maxReefRaw });\r\n    if (!where) return null;\r\n\r\n    return {\r\n      where,\r\n      orderBy: ['timestamp_DESC', 'id_DESC'] as TransferOrderByInput[],\r\n      offset: 0,\r\n      limit: PAGINATION_CONFIG.SUBSCRIPTION_FETCH_SIZE,\r\n    };\r\n  }, [resolvedAddress, resolvedEvmAddress, direction, minReefRaw, maxReefRaw]);\r\n\r\n  // Allow E2E to override polling interval via URL param ?pollMs=1000\r\n  const pollIntervalMs = useMemo(() => {\r\n    try {\r\n      const params = new URLSearchParams(window.location.search);\r\n      const raw = params.get('pollMs') ?? params.get('poll') ?? params.get('pollingMs');\r\n      const n = raw ? Number(raw) : NaN;\r\n      return Number.isFinite(n) && n > 0 ? Math.floor(n) : PAGINATION_CONFIG.POLLING_INTERVAL_MS;\r\n    } catch {\r\n      return PAGINATION_CONFIG.POLLING_INTERVAL_MS;\r\n    }\r\n  }, []);\r\n\r\n  // Clear tracking when address (input) or resolved values change\r\n  useEffect(() => {\r\n    detectorRef.current.reset();\r\n  }, [address, resolvedAddress, resolvedEvmAddress, direction, minReefRaw, maxReefRaw]);\r\n\r\n\r\n  const { data, error, startPolling, stopPolling } = useQuery<TransfersPollingQueryQuery, TransfersPollingQueryQueryVariables>(\r\n    TRANSFERS_POLLING_QUERY as unknown as TypedDocumentNode<TransfersPollingQueryQuery, TransfersPollingQueryQueryVariables>,\r\n    {\r\n      variables: queryVariables as TransfersPollingQueryQueryVariables,\r\n      skip: !isEnabled || (!resolvedAddress && !resolvedEvmAddress) || !queryVariables,\r\n      pollInterval: isEnabled ? pollIntervalMs : 0,\r\n      notifyOnNetworkStatusChange: false,\r\n      fetchPolicy: 'network-only',\r\n    }\r\n  );\r\n\r\n  // Pause/resume polling when tab visibility changes\r\n  useEffect(() => {\r\n    const canPoll = isEnabled && (!!resolvedAddress || !!resolvedEvmAddress) && !!queryVariables;\r\n    if (!canPoll) return;\r\n\r\n    const handleVisibility = () => {\r\n      if (document.hidden) {\r\n        stopPolling?.();\r\n      } else {\r\n        startPolling?.(pollIntervalMs);\r\n      }\r\n    };\r\n\r\n    document.addEventListener('visibilitychange', handleVisibility);\r\n    handleVisibility();\r\n    return () => {\r\n      document.removeEventListener('visibilitychange', handleVisibility);\r\n      stopPolling?.();\r\n    };\r\n  }, [isEnabled, resolvedAddress, resolvedEvmAddress, queryVariables, startPolling, stopPolling, pollIntervalMs]);\r\n\r\n  useEffect(() => {\r\n    if (error) {\r\n      console.error('Subscription error:', error);\r\n      return;\r\n    }\r\n\r\n    // Debug tick log removed\r\n\r\n    if (!data?.transfers || (!resolvedAddress && !resolvedEvmAddress)) return;\r\n\r\n    // Map transfers to UI format - wrap in edge structure for mapper compatibility\r\n    // Use a minimal runtime shape to avoid fragment masking type friction\r\n    const rawTransfers = (data.transfers ?? []) as Array<{\r\n      id: string;\r\n      amount: string;\r\n      timestamp: string;\r\n      success: boolean;\r\n      type: string;\r\n      signedData?: unknown;\r\n      extrinsicHash?: string | null;\r\n      from: { id: string };\r\n      to: { id: string };\r\n      token: { id: string; name: string };\r\n    }>;\r\n    const transferEdges = rawTransfers.map((transfer) => ({ node: transfer }));\r\n    const uiTransfers = ensureUniqueTransfers(\r\n      sortTransfersByTimestamp(\r\n        mapTransfersToUiTransfers(transferEdges as unknown as (any | null)[], resolvedAddress ?? resolvedEvmAddress ?? undefined)\r\n      )\r\n    );\r\n\r\n    if (uiTransfers.length === 0) return;\r\n\r\n    // Detect and notify only truly new transfers (first call primes and returns [])\r\n    const newTransfers = detectorRef.current.detectNew(uiTransfers);\r\n    const readyNewTransfers = newTransfers;\r\n\r\n    // Always reconcile the cache with the latest polled top list to ensure\r\n    // newest transfers appear even on the first tick (when detector primes)\r\n    if (PAGINATION_CONFIG.SUB_PREPEND_WITHOUT_REFETCH) {\r\n      const baseWhere = buildTransferWhereFilter({ resolvedAddress, resolvedEvmAddress, direction, minReefRaw, maxReefRaw });\r\n      const orderBy = ['timestamp_DESC', 'id_DESC'] as TransferOrderByInput[];\r\n\r\n      // Use the raw polled list as prepend candidates (already newest-first)\r\n      const candidates = rawTransfers;\r\n      // Cover timing races between address resolution variants by updating multiple where shapes.\r\n      const whereVariantsRaw = [\r\n        baseWhere,\r\n        buildTransferWhereFilter({ resolvedAddress, resolvedEvmAddress: null, direction, minReefRaw, maxReefRaw }),\r\n        buildTransferWhereFilter({ resolvedAddress: null, resolvedEvmAddress, direction, minReefRaw, maxReefRaw }),\r\n      ].filter(Boolean) as Array<Record<string, unknown>>;\r\n      const seenWhere = new Set<string>();\r\n      const whereVariants = whereVariantsRaw.filter((w) => {\r\n        const key = JSON.stringify(w);\r\n        if (seenWhere.has(key)) return false;\r\n        seenWhere.add(key);\r\n        return true;\r\n      });\r\n\r\n      for (const where of whereVariants) {\r\n        // Debug cache.reconcile prepend log removed\r\n        try {\r\n          client.cache.updateQuery<TransfersMinQueryQuery, TransfersMinQueryQueryVariables>(\r\n            {\r\n              query: PAGINATED_TRANSFERS_QUERY as unknown as TypedDocumentNode<TransfersMinQueryQuery, TransfersMinQueryQueryVariables>,\r\n              variables: {\r\n                first: PAGINATION_CONFIG.API_FETCH_PAGE_SIZE,\r\n                where,\r\n                orderBy,\r\n              },\r\n            },\r\n            (prev) => {\r\n              if (!prev?.transfersConnection) return prev;\r\n              const existingEdges = prev.transfersConnection.edges ?? [];\r\n              const existingIds = new Set<string>();\r\n              for (const e of existingEdges) {\r\n                const id = (e as any)?.node?.id as string | undefined;\r\n                if (id) existingIds.add(id);\r\n              }\r\n              // Build edges to prepend for candidates not yet present\r\n              const prependEdges = candidates\r\n                .filter((node) => !existingIds.has(node.id))\r\n                .map((node) => ({\r\n                  __typename: 'TransferEdge' as const,\r\n                  node: {\r\n                    __typename: 'Transfer' as const,\r\n                    ...(node as any),\r\n                    token: {\r\n                      __typename: 'VerifiedContract' as const,\r\n                      id: (node as any)?.token?.id,\r\n                      name: (node as any)?.token?.name,\r\n                      contractData: null, // satisfy selection set\r\n                    },\r\n                  },\r\n                }));\r\n\r\n              if (prependEdges.length === 0) return prev; // no changes\r\n\r\n              const seen = new Set<string>();\r\n              const resultEdges: typeof existingEdges = [];\r\n              // Prepend new edges first\r\n              for (const e of prependEdges) {\r\n                const id = (e as any)?.node?.id as string | undefined;\r\n                if (!id) continue;\r\n                if (!seen.has(id)) {\r\n                  seen.add(id);\r\n                  resultEdges.push(e as (typeof existingEdges)[number]);\r\n                }\r\n              }\r\n              // Then keep existing edges in order, skipping duplicates\r\n              for (const e of existingEdges) {\r\n                const id = (e as any)?.node?.id as string | undefined;\r\n                if (!id) {\r\n                  resultEdges.push(e);\r\n                  continue;\r\n                }\r\n                if (!seen.has(id)) {\r\n                  seen.add(id);\r\n                  resultEdges.push(e);\r\n                }\r\n              }\r\n              // Preserve already loaded pages: keep at least existing length, with a floor at API page size.\r\n              const max = Math.max(existingEdges.length, PAGINATION_CONFIG.API_FETCH_PAGE_SIZE);\r\n              const cappedEdges = resultEdges.slice(0, max);\r\n              return {\r\n                ...prev,\r\n                transfersConnection: {\r\n                  ...prev.transfersConnection,\r\n                  edges: cappedEdges,\r\n                },\r\n              };\r\n            }\r\n          );\r\n        } catch (e) {\r\n          console.error('[sub] updateQuery failed', e);\r\n        }\r\n      }\r\n\r\n      // Fire notifications after cache is consistent so UI can anchor to the new id immediately\r\n      for (const t of readyNewTransfers) {\r\n        onNewTransfer(t);\r\n      }\r\n    } else {\r\n      // Fallback: refetch the first page to let merge policy replace edges\r\n      // Debug refetch log removed\r\n      void client\r\n        .refetchQueries({\r\n          include: [\r\n            PAGINATED_TRANSFERS_QUERY as unknown as TypedDocumentNode<TransfersMinQueryQuery, TransfersMinQueryQueryVariables>,\r\n          ],\r\n        })\r\n        .then(() => {\r\n          for (const t of readyNewTransfers) {\r\n            onNewTransfer(t);\r\n          }\r\n        })\r\n        .catch(() => {\r\n          // Even if refetch fails, still surface the notification so user sees activity\r\n          for (const t of readyNewTransfers) {\r\n            onNewTransfer(t);\r\n          }\r\n        });\r\n    }\r\n    return undefined;\r\n  }, [data, error, onNewTransfer, resolvedAddress, resolvedEvmAddress, client, direction, minReefRaw, maxReefRaw]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\reef-explorer-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\reef-swap-client.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[561,564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[561,564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[856,859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[856,859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[947,950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[947,950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1307,1310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1307,1310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1879,1882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1879,1882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2118,2121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2118,2121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ApolloClient, InMemoryCache, HttpLink } from '@apollo/client';\r\n\r\n// Dedicated Apollo client for reef-swap Squid endpoint\r\nexport const reefSwapClient = new ApolloClient({\r\n  link: new HttpLink({ uri: 'https://squid.subsquid.io/reef-swap/graphql' }),\r\n  cache: new InMemoryCache({\r\n    typePolicies: {\r\n      Query: {\r\n        fields: {\r\n          poolEventsConnection: {\r\n            keyArgs: ['orderBy', 'where'],\r\n            merge(existing, incoming, { args }) {\r\n              if (!incoming) return existing;\r\n              const after = (args as any)?.after ?? null;\r\n              const incomingEdges = incoming?.edges ?? [];\r\n\r\n              if (after == null) {\r\n                const existingEdges = existing?.edges ?? [];\r\n                const seen = new Set<string>();\r\n                const mergedEdges: typeof incomingEdges = [] as any;\r\n                for (const e of incomingEdges) {\r\n                  const id = (e as any)?.node?.id as string | undefined;\r\n                  const key = id ? String(id) : undefined;\r\n                  if (!key || !seen.has(key)) {\r\n                    if (key) seen.add(key);\r\n                    mergedEdges.push(e);\r\n                  }\r\n                }\r\n                for (const e of existingEdges) {\r\n                  const id = (e as any)?.node?.id as string | undefined;\r\n                  const key = id ? String(id) : undefined;\r\n                  if (!key || !seen.has(key)) {\r\n                    if (key) seen.add(key);\r\n                    mergedEdges.push(e);\r\n                  }\r\n                }\r\n                return { ...incoming, edges: mergedEdges, pageInfo: incoming.pageInfo };\r\n              }\r\n\r\n              const existingEdges = existing?.edges ?? [];\r\n              const seen = new Set<string>();\r\n              for (const e of existingEdges) {\r\n                const id = (e as any)?.node?.id as string | undefined;\r\n                if (id) seen.add(String(id));\r\n              }\r\n              const mergedEdges = [...existingEdges];\r\n              for (const e of incomingEdges) {\r\n                const id = (e as any)?.node?.id as string | undefined;\r\n                const key = id ? String(id) : undefined;\r\n                if (!key || !seen.has(key)) {\r\n                  if (key) seen.add(key);\r\n                  mergedEdges.push(e);\r\n                }\r\n              }\r\n              return { ...incoming, edges: mergedEdges };\r\n            },\r\n          },\r\n        },\r\n      },\r\n    },\r\n  }),\r\n  connectToDevTools: false,\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\setup\\polyfills.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\setup\\quiet-console.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[155,158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[155,158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":4,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[177,180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[177,180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Silences known noisy console hints in development when enabled via env flag.\r\n// Enable by setting VITE_SILENCE_CONSOLE_HINTS=1 (or true)\r\n\r\nconst env: any = (import.meta as any)?.env ?? {};\r\nconst ENABLED: boolean = env?.VITE_SILENCE_CONSOLE_HINTS === '1' || env?.VITE_SILENCE_CONSOLE_HINTS === 'true';\r\n\r\nif (ENABLED && typeof window !== 'undefined') {\r\n  const patterns: RegExp[] = [\r\n    /react devtools/i,\r\n    /apollo.*devtools/i,\r\n    /@polkadot\\/util.*requires direct dependencies exactly matching version/i,\r\n    /@polkadot\\/util-crypto.*multiple versions/i,\r\n    /deprecation warning: tabReply will be removed/i,\r\n    /provider initialised/i,\r\n    /\\[page receives\\]/i,\r\n    /\\[content receives\\]/i,\r\n    /module \"buffer\" has been externalized/i,\r\n  ];\r\n\r\n  const shouldSilence = (args: unknown[]): boolean => {\r\n    try {\r\n      for (const a of args) {\r\n        const s = typeof a === 'string' ? a : (typeof a === 'object' ? JSON.stringify(a) : String(a));\r\n        if (patterns.some((re) => re.test(s))) return true;\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const orig = {\r\n    log: console.log.bind(console),\r\n    info: console.info.bind(console),\r\n    warn: console.warn.bind(console),\r\n  } as const;\r\n\r\n  console.log = (...args: unknown[]) => { if (shouldSilence(args)) return; orig.log(...args); };\r\n  console.info = (...args: unknown[]) => { if (shouldSilence(args)) return; orig.info(...args); };\r\n  console.warn = (...args: unknown[]) => { if (shouldSilence(args)) return; orig.warn(...args); };\r\n  // Never silence errors\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\stores\\use-transaction-filter-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\test-utils\\testing-library-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\test\\test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\tokens\\token-ids.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1095,1098],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1095,1098],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1699,1702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1699,1702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Token id sets and helpers shared across hooks/components\r\n\r\nconst STORAGE_AVAILABLE = typeof window !== 'undefined' && !!window.localStorage;\r\nexport const USDC_STORAGE_KEY = 'reef.session.usdc.ids.v1';\r\nexport const MRD_STORAGE_KEY = 'reef.session.mrd.ids.v1';\r\nconst IDS_TTL_MS = 7 * 24 * 60 * 60 * 1000; // 7 days\r\n\r\nexport function loadIds(key: string): string[] {\r\n  try {\r\n    if (!STORAGE_AVAILABLE) return [];\r\n    const raw = window.localStorage.getItem(key);\r\n    if (!raw) return [];\r\n    const parsed = JSON.parse(raw);\r\n    if (!parsed || !Array.isArray(parsed.ids) || typeof parsed.ts !== 'number') return [];\r\n    if (Date.now() - parsed.ts > IDS_TTL_MS) return [];\r\n    return (parsed.ids as string[]).map(s => String(s).toLowerCase()).filter(Boolean);\r\n  } catch { return []; }\r\n}\r\nexport function saveIds(key: string, ids: Set<string>) {\r\n  try {\r\n    if (!STORAGE_AVAILABLE) return;\r\n    const arr = Array.from(ids);\r\n    window.localStorage.setItem(key, JSON.stringify({ ids: arr, ts: Date.now() }));\r\n  } catch { /* ignore */ }\r\n}\r\n\r\nconst USDC_ENV_RAW = (import.meta as any)?.env?.VITE_USDC_CONTRACT_IDS as string | undefined;\r\nconst USDC_ENV = (USDC_ENV_RAW || '')\r\n  .split(',')\r\n  .map((s: string) => s.trim().toLowerCase())\r\n  .filter(Boolean);\r\nconst USDC_DEFAULTS = ['0x7922d8785d93e692bb584e659b607fa821e6a91a'];\r\nexport const USDC_ID_SET = new Set<string>(USDC_ENV.length > 0 ? USDC_ENV : USDC_DEFAULTS);\r\nexport const USDC_SESSION_SET = new Set<string>();\r\nexport const isUsdcId = (id?: string) => {\r\n  if (!id) return false;\r\n  const s = String(id).toLowerCase();\r\n  return USDC_ID_SET.has(s) || USDC_SESSION_SET.has(s);\r\n};\r\n\r\nconst MRD_ENV_RAW = (import.meta as any)?.env?.VITE_MRD_CONTRACT_IDS as string | undefined;\r\nconst MRD_ENV = (MRD_ENV_RAW || '')\r\n  .split(',')\r\n  .map((s: string) => s.trim().toLowerCase())\r\n  .filter(Boolean);\r\nconst MRD_DEFAULTS = ['0x95a2af50040b7256a4b4c405a4afd4dd573da115'];\r\nexport const MRD_ID_SET = new Set<string>(MRD_ENV.length > 0 ? MRD_ENV : MRD_DEFAULTS);\r\nexport const MRD_SESSION_SET = new Set<string>();\r\nexport const isMrdId = (id?: string) => {\r\n  if (!id) return false;\r\n  const s = String(id).toLowerCase();\r\n  return MRD_ID_SET.has(s) || MRD_SESSION_SET.has(s);\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\types\\nft.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\types\\tanstack-table-meta.d.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TData' is defined but never used.","line":5,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { RowData } from '@tanstack/table-core';\r\n\r\ndeclare module '@tanstack/table-core' {\r\n  // Extend TanStack Table meta to carry token price data for cells\r\n  interface TableMeta<TData extends RowData> {\r\n    pricesById?: Record<string, number | null>;\r\n    reefUsd?: number | null;\r\n    /** When true, TIMESTAMP header sorting is disabled (e.g., when Min REEF filter is active) */\r\n    disableTimestampSorting?: boolean;\r\n    /** When true, AMOUNT header sorting is disabled (e.g., when Min REEF filter is inactive) */\r\n    disableAmountSorting?: boolean;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\types\\tanstack-table.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\abi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\address-helpers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\address-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\data-url.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\error-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\evm-call.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1239,1242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1239,1242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1588,1591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1588,1591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Minimal EVM JSON-RPC helpers to call Reefswap Factory/Pair without external deps\r\n// NOTE: Keep lean; use fixed 4byte selectors and simple hex encoding.\r\n\r\nconst ENV = ((import.meta as unknown as { env?: Record<string, string | undefined> }).env) ?? {};\r\nconst EVM_RPC_URL: string = ENV.VITE_REEF_EVM_RPC_URL ?? 'https://rpc.reefscan.com';\r\n\r\n// UniswapV2-compatible selectors\r\nconst SELECTORS = {\r\n  getPair: '0xe6a43905', // getPair(address,address)\r\n  token0: '0x0dfe1681', // token0()\r\n  token1: '0xd21220a7', // token1()\r\n  getReserves: '0x0902f1ac', // getReserves()\r\n} as const;\r\n\r\nimport { safeBigInt } from './token-helpers';\r\n\r\n/**\r\n * Strips 0x prefix from a hex string.\r\n */\r\nfunction strip0x(h: string): string {\r\n  return h.startsWith('0x') ? h.slice(2) : h;\r\n}\r\nfunction pad32(hex: string): string {\r\n  const s = strip0x(hex).toLowerCase();\r\n  return s.padStart(64, '0');\r\n}\r\nfunction encodeAddress(addr: string): string {\r\n  const a = strip0x(addr).toLowerCase();\r\n  if (a.length !== 40) return a.padStart(40, '0').slice(-40);\r\n  return a;\r\n}\r\nfunction buildData(selector: string, params: string[]): string {\r\n  return selector + params.join('');\r\n}\r\n\r\nasync function rpcCall(method: string, params: unknown[]): Promise<any> {\r\n  const body = { jsonrpc: '2.0', id: 1, method, params };\r\n  const res = await fetch(EVM_RPC_URL, {\r\n    method: 'POST',\r\n    headers: { 'content-type': 'application/json' },\r\n    body: JSON.stringify(body),\r\n  });\r\n  if (!res.ok) throw new Error(`RPC ${method} failed: ${res.status}`);\r\n  const json = await res.json().catch(() => null) as any;\r\n  if (!json || json.error) throw new Error(`RPC error: ${JSON.stringify(json?.error ?? {})}`);\r\n  return json.result;\r\n}\r\n\r\nexport async function ethCall(to: string, data: string): Promise<string | null> {\r\n  // HTTP JSON-RPC call to configured endpoint\r\n  try {\r\n    const result = await rpcCall('eth_call', [{ to, data }, 'latest']);\r\n    return typeof result === 'string' ? result : null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function encodeGetPairData(tokenA: string, tokenB: string): string {\r\n  const a = pad32(encodeAddress(tokenA));\r\n  const b = pad32(encodeAddress(tokenB));\r\n  return buildData(SELECTORS.getPair, [a, b]);\r\n}\r\nexport const encodeToken0Data = (): string => SELECTORS.token0;\r\nexport const encodeToken1Data = (): string => SELECTORS.token1;\r\nexport const encodeGetReservesData = (): string => SELECTORS.getReserves;\r\n\r\nexport function decodeAddress(retHex: string): string | null {\r\n  try {\r\n    const s = strip0x(retHex);\r\n    if (s.length < 64) return null;\r\n    const word = s.slice(0, 64);\r\n    // address is right-aligned in 32 bytes\r\n    const addr = word.slice(24);\r\n    return '0x' + addr;\r\n  } catch { return null; }\r\n}\r\nexport function decodeGetReserves(retHex: string): { reserve0: bigint; reserve1: bigint } | null {\r\n  try {\r\n    const s = strip0x(retHex);\r\n    if (s.length < 64 * 3) return null;\r\n    const r0 = safeBigInt('0x' + s.slice(0, 64));\r\n    const r1 = safeBigInt('0x' + s.slice(64, 128));\r\n    return { reserve0: r0, reserve1: r1 };\r\n  } catch { return null; }\r\n}\r\n\r\nexport const REEF_TOKEN_ADDRESS = '0x0000000000000000000000000000000001000000';\r\n\r\n// Return factory candidates (env override first). New default first, then legacy.\r\nexport function getFactoryCandidates(): string[] {\r\n  const envFactory = ENV.VITE_REEFSWAP_FACTORY?.trim();\r\n  const list: string[] = [];\r\n  if (envFactory && /^0x[0-9a-fA-F]{40}$/.test(envFactory)) list.push(envFactory);\r\n  // New deployment (reef-chain/reefswap deployments.json)\r\n  list.push('0xe8f4D9308DC06D1D570117B1656C26F515aF22a7');\r\n  // Legacy UI factory\r\n  list.push('0x380a9033500154872813F6E1120a81ed6c0760a8');\r\n  return list;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\fees.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\ipfs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\lru.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\number.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\object.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\time.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\token-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1671,1674],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1671,1674],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getNumber, getString } from './object';\r\nimport { normalizeIpfs } from './ipfs';\r\nimport { parseTimestampToDate } from './formatters';\r\n\r\n/**\r\n * Validates if a token is REEF based on its name and decimals.\r\n */\r\nexport function isReefToken(tok?: { name?: string; decimals?: number }): boolean {\r\n  return !!tok && tok.name === 'REEF' && (tok.decimals ?? 18) === 18;\r\n}\r\n\r\n/**\r\n * Normalizes timestamps to epoch milliseconds for stable sorting.\r\n */\r\nexport function toEpochMs(ts: string | number | Date | null | undefined): number {\r\n  if (ts == null) return -Infinity;\r\n  const d = parseTimestampToDate(ts as string | number | Date);\r\n  return d ? d.getTime() : -Infinity;\r\n}\r\n\r\n/**\r\n * Converts a raw amount string to a float number based on decimals.\r\n */\r\nexport function toFloatAmount(amountStr: string, decimals: number): number {\r\n  const s = (amountStr || '').trim();\r\n  if (!/^\\d+$/.test(s)) return 0;\r\n  if (decimals === 0) return Number(s);\r\n  if (s.length <= decimals) {\r\n    const pad = s.padStart(decimals, '0');\r\n    return Number(`0.${pad}`);\r\n  }\r\n  const head = s.slice(0, s.length - decimals);\r\n  const tail = s.slice(s.length - decimals);\r\n  return Number(`${head}.${tail}`);\r\n}\r\n\r\nconst usdcNameSynonyms = new Set(['usdc', 'usdc.e', 'usd coin']);\r\n\r\n/**\r\n * Checks if a token name matches known USDC synonyms.\r\n */\r\nexport function isUsdcByName(tok?: { name?: string | null }): boolean {\r\n  const nm = (tok?.name || '').toString().toLowerCase();\r\n  return !!nm && usdcNameSynonyms.has(nm);\r\n}\r\n\r\n/**\r\n * Safely parses a value to BigInt, returning 0n on failure.\r\n * Handles absolute values if requested.\r\n */\r\nexport function safeBigInt(v: any, absolute = false): bigint {\r\n  try {\r\n    if (v == null) return 0n;\r\n    let bi = BigInt(String(v));\r\n    if (absolute && bi < 0n) bi = -bi;\r\n    return bi;\r\n  } catch {\r\n    return 0n;\r\n  }\r\n}\r\n\r\n/**\r\n * Parses token metadata from contractData JSON.\r\n */\r\nexport interface TokenMeta {\r\n  name: string;\r\n  decimals: number;\r\n  image?: string;\r\n}\r\n\r\nexport function parseTokenMetadata(\r\n  contractDataRaw: unknown,\r\n  fallbackName: string = 'TOKEN',\r\n  fallbackDecimals: number = 18\r\n): TokenMeta {\r\n  if (!contractDataRaw) return { name: fallbackName, decimals: fallbackDecimals };\r\n  try {\r\n    const cd: unknown = typeof contractDataRaw === 'string' ? JSON.parse(contractDataRaw) : contractDataRaw;\r\n    const symbol = getString(cd, ['symbol']);\r\n    const decimals = getNumber(cd, ['decimals']);\r\n    \r\n    // Extensive list of possible image fields in contract metadata\r\n    const img =\r\n      getString(cd, ['icon'])\r\n      || getString(cd, ['iconUrl'])\r\n      || getString(cd, ['iconURL'])\r\n      || getString(cd, ['icon_url'])\r\n      || getString(cd, ['logo'])\r\n      || getString(cd, ['logoURI'])\r\n      || getString(cd, ['logoUrl'])\r\n      || getString(cd, ['logoURL'])\r\n      || getString(cd, ['logo_url'])\r\n      || getString(cd, ['image'])\r\n      || getString(cd, ['imageUrl'])\r\n      || getString(cd, ['imageURL'])\r\n      || getString(cd, ['image_url'])\r\n      || getString(cd, ['metadata', 'image'])\r\n      || getString(cd, ['metadata', 'imageUrl'])\r\n      || getString(cd, ['metadata', 'imageURL'])\r\n      || getString(cd, ['metadata', 'logoURI'])\r\n      || getString(cd, ['metadata', 'logoUrl'])\r\n      || getString(cd, ['metadata', 'logoURL'])\r\n      || getString(cd, ['metadata', 'icon'])\r\n      || getString(cd, ['metadata', 'iconUrl'])\r\n      || getString(cd, ['metadata', 'iconURL'])\r\n      || undefined;\r\n      \r\n    const image = img ? normalizeIpfs(img) : undefined;\r\n    return { name: symbol || fallbackName, decimals: decimals ?? fallbackDecimals, image };\r\n  } catch {\r\n    return { name: fallbackName, decimals: fallbackDecimals };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\transfer-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[297,300],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[297,300],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[438,441],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[438,441],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[790,793],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[790,793],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-extra-boolean-cast","severity":2,"message":"Redundant Boolean call.","line":28,"column":43,"nodeType":"CallExpression","messageId":"unexpectedCall","endLine":28,"endColumn":69,"fix":{"range":[890,916],"text":"(g as any)?.isNft"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[904,907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[904,907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[974,977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[974,977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1059,1062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1059,1062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4367,4370],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4367,4370],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { UiTransfer } from '../data/transfer-mapper';\r\nimport { toEpochMs, safeBigInt } from './token-helpers';\r\n\r\nimport { getString } from './object';\r\n\r\n/**\r\n * Identifies extrinsic hashes that might have missing swap partner legs.\r\n */\r\nexport function identifyMissingPartnerHashes(\r\n  nodes: any[],\r\n  alreadyLoadedHashes: Set<string> = new Set(),\r\n  options: { strict?: boolean } = {}\r\n): string[] {\r\n  const byHash: Record<string, any[]> = {};\r\n  for (const n of nodes) {\r\n    const h = getString(n, ['extrinsicHash']);\r\n    if (!h) continue;\r\n    (byHash[h] = byHash[h] || []).push(n);\r\n  }\r\n\r\n  const missing: string[] = [];\r\n  for (const [h, arr] of Object.entries(byHash)) {\r\n    if (alreadyLoadedHashes.has(h)) continue;\r\n    \r\n    const hasFlag = arr.some((g) => Boolean((g as any)?.reefswapAction));\r\n    \r\n    if (options.strict) {\r\n      const fungible = arr.filter((g) => !Boolean((g as any)?.isNft));\r\n      const hasIn = fungible.some((g) => String((g as any)?.type) === 'INCOMING');\r\n      const hasOut = fungible.some((g) => String((g as any)?.type) === 'OUTGOING');\r\n      if (hasFlag || !(hasIn && hasOut)) missing.push(h);\r\n    } else {\r\n      if (hasFlag) missing.push(h);\r\n    }\r\n  }\r\n  return missing;\r\n}\r\n\r\n/**\r\n * Ensures a list of transfers has unique IDs.\r\n */\r\nexport function ensureUniqueTransfers(transfers: UiTransfer[]): UiTransfer[] {\r\n  const seen = new Set<string>();\r\n  const unique: UiTransfer[] = [];\r\n  for (const t of transfers) {\r\n    if (t && !seen.has(t.id)) {\r\n      seen.add(t.id);\r\n      unique.push(t);\r\n    }\r\n  }\r\n  return unique;\r\n}\r\n\r\n/**\r\n * Sorts transfers by amount (ASC) and then ID (ASC).\r\n */\r\nexport function sortTransfersByAmount(transfers: UiTransfer[]): UiTransfer[] {\r\n  return [...transfers].sort((a, b) => {\r\n    const da = a.amountBI ?? safeBigInt(a.amount);\r\n    const db = b.amountBI ?? safeBigInt(b.amount);\r\n    if (da !== db) return da < db ? -1 : 1;\r\n    if (a.id === b.id) return 0;\r\n    return a.id < b.id ? -1 : 1;\r\n  });\r\n}\r\n\r\n/**\r\n * Sorts transfers by timestamp (DESC) and then ID (DESC).\r\n */\r\nexport function sortTransfersByTimestamp(transfers: UiTransfer[]): UiTransfer[] {\r\n  return [...transfers].sort((a, b) => {\r\n    const ta = toEpochMs(a.timestamp);\r\n    const tb = toEpochMs(b.timestamp);\r\n    if (tb !== ta) return tb - ta; // newer first\r\n    if (a.id === b.id) return 0;\r\n    return a.id < b.id ? 1 : -1;\r\n  });\r\n}\r\n\r\n/**\r\n * Aggregates individual transfer legs into logical SWAP transactions.\r\n */\r\nexport function aggregateSwaps(transfers: UiTransfer[]): UiTransfer[] {\r\n  // Group by extrinsicHash to detect swaps (incoming + outgoing different tokens).\r\n  const byHash = new Map<string, UiTransfer[]>();\r\n  for (const t of transfers) {\r\n    const h = t.extrinsicHash || t.id;\r\n    const arr = byHash.get(h) || [];\r\n    arr.push(t);\r\n    byHash.set(h, arr);\r\n  }\r\n\r\n  const aggregated: UiTransfer[] = [];\r\n  for (const [hash, group] of byHash.entries()) {\r\n    const fungible = group.filter(g => !g.isNft);\r\n    const incoming = fungible.filter(g => g.type === 'INCOMING');\r\n    const outgoing = fungible.filter(g => g.type === 'OUTGOING');\r\n\r\n    if (!(incoming.length > 0 && outgoing.length > 0)) {\r\n      aggregated.push(...group);\r\n      continue;\r\n    }\r\n\r\n    // Pick the largest legs per direction by raw amount\r\n    function pickMax(list: UiTransfer[]): UiTransfer {\r\n      let best = list[0]!;\r\n      for (const it of list) {\r\n        const a = it.amountBI ?? safeBigInt(it.amount);\r\n        const b = best.amountBI ?? safeBigInt(best.amount);\r\n        if (a > b) best = it;\r\n      }\r\n      return best;\r\n    }\r\n    const maxIn = pickMax(incoming);\r\n    const maxOut = pickMax(outgoing);\r\n\r\n    // Build SWAP only if dominant tokens differ; otherwise keep individual legs\r\n    if (maxIn.token.id === maxOut.token.id) {\r\n      aggregated.push(...group);\r\n      continue;\r\n    }\r\n\r\n    const ts = maxIn.timestamp || maxOut.timestamp;\r\n    const success = group.every(g => g.success);\r\n\r\n    // Try to capture a concrete transfer id for linking\r\n    function extractTripleId(src?: string): string | undefined {\r\n      if (!src) return undefined;\r\n      const m = src.match(/0*(\\d+)-0*(\\d+)-0*(\\d+)/);\r\n      if (!m) return undefined;\r\n      return `${String(Number(m[1]))}-${String(Number(m[2]))}-${String(Number(m[3]))}`;\r\n    }\r\n    function buildFromExId(leg?: any): string | undefined {\r\n      if (!leg?.extrinsicId || leg?.eventIndex == null) return undefined;\r\n      const m = String(leg.extrinsicId).match(/0*(\\d+)-0*(\\d+)/);\r\n      if (!m) return undefined;\r\n      const event = String(Number(leg.eventIndex));\r\n      if (!Number.isFinite(Number(event))) return undefined;\r\n      return `${String(Number(m[1]))}-${String(Number(m[2]))}-${event}`;\r\n    }\r\n    const preferId = extractTripleId(maxIn.id)\r\n      ?? extractTripleId(maxOut.id)\r\n      ?? buildFromExId(maxIn)\r\n      ?? buildFromExId(maxOut);\r\n\r\n    aggregated.push({\r\n      id: `${hash}:swap`,\r\n      from: maxOut.from,\r\n      to: maxIn.to,\r\n      type: 'SWAP',\r\n      method: 'swap',\r\n      amount: maxIn.amount,\r\n      amountBI: maxIn.amountBI ?? safeBigInt(maxIn.amount),\r\n      isNft: false,\r\n      tokenId: null,\r\n      token: maxIn.token,\r\n      timestamp: ts,\r\n      success,\r\n      extrinsicHash: hash,\r\n      blockHeight: (maxIn.blockHeight ?? maxOut.blockHeight),\r\n      extrinsicIndex: (maxIn.extrinsicIndex ?? maxOut.extrinsicIndex),\r\n      eventIndex: (maxIn.eventIndex ?? maxOut.eventIndex),\r\n      extrinsicId: (maxIn.extrinsicId ?? maxOut.extrinsicId),\r\n      swapInfo: {\r\n        sold: { amount: maxOut.amount, amountBI: maxOut.amountBI ?? safeBigInt(maxOut.amount), token: maxOut.token },\r\n        bought: { amount: maxIn.amount, amountBI: maxIn.amountBI ?? safeBigInt(maxIn.amount), token: maxIn.token },\r\n        preferredTransferId: preferId,\r\n      },\r\n    });\r\n  }\r\n  return aggregated;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\transfer-new-items.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\transfer-query.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3012,3015],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3012,3015],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3531,3534],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3531,3534],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":97,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":100,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3714,3717],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3714,3717],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4080,4083],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4080,4083],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4090,4093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4090,4093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4679,4682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4679,4682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4689,4692],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4689,4692],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":102,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":105,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4850,4853],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4850,4853],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":102,"column":113,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":116,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4861,4864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4861,4864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5043,5046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5043,5046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5053,5056],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5053,5056],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5179,5182],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5179,5182],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5189,5192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5189,5192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TransferWhereInput, TransferType } from '@/gql/graphql';\r\nimport { toChecksumAddress } from '@/utils/address-helpers';\r\nimport { safeBigInt } from '@/utils/token-helpers';\r\n\r\ninterface BuildFilterParams {\r\n  resolvedAddress?: string | null;\r\n  resolvedEvmAddress?: string | null;\r\n  direction?: TransactionDirection;\r\n  /** Minimum amount for REEF (Native) in raw units (10^18). If provided, filter will include only Native transfers with amount >= this value. */\r\n  minReefRaw?: string | bigint | null;\r\n  /** Maximum amount for REEF (Native) in raw units (10^18). If provided, filter will include only Native transfers with amount <= this value. */\r\n  maxReefRaw?: string | bigint | null;\r\n  /** When true, restrict results to REEF (Native) transfers even if no amount range is provided. */\r\n  reefOnly?: boolean;\r\n  /** Restrict results to specific token contract ids (lowercased). Enables optional token amount range. */\r\n  tokenIds?: string[] | null;\r\n  /** Minimum amount for selected token (raw). Applied only when tokenIds is provided. */\r\n  tokenMinRaw?: string | bigint | null;\r\n  /** Maximum amount for selected token (raw). Applied only when tokenIds is provided. */\r\n  tokenMaxRaw?: string | bigint | null;\r\n  /** When true and tokenIds are not provided, restrict to ERC20 tokens to narrow fallback. */\r\n  erc20Only?: boolean;\r\n  /** When true, exclude swap legs from results (reefswapAction is null). */\r\n  excludeSwapLegs?: boolean;\r\n}\r\n\r\nexport type TransactionDirection = 'any' | 'incoming' | 'outgoing';\r\n\r\n// Builds a TransferWhereInput with OR over native id and EVM address.\r\n// Returns undefined if neither address is provided.\r\nexport function buildTransferWhereFilter({\r\n  resolvedAddress,\r\n  resolvedEvmAddress,\r\n  direction = 'any',\r\n  minReefRaw = null,\r\n  maxReefRaw = null,\r\n  reefOnly = false,\r\n  tokenIds = null,\r\n  tokenMinRaw = null,\r\n  tokenMaxRaw = null,\r\n  erc20Only = false,\r\n  excludeSwapLegs = false,\r\n}: BuildFilterParams): TransferWhereInput | undefined {\r\n  const orClauses: NonNullable<TransferWhereInput['OR']> = [];\r\n  const wantIncoming = direction === 'any' || direction === 'incoming';\r\n  const wantOutgoing = direction === 'any' || direction === 'outgoing';\r\n\r\n  if (resolvedAddress) {\r\n    if (wantOutgoing) orClauses.push({ from: { id_eq: resolvedAddress } });\r\n    if (wantIncoming) orClauses.push({ to: { id_eq: resolvedAddress } });\r\n  }\r\n  if (resolvedEvmAddress) {\r\n    if (wantOutgoing) orClauses.push({ fromEvmAddress_eq: resolvedEvmAddress });\r\n    if (wantIncoming) orClauses.push({ toEvmAddress_eq: resolvedEvmAddress });\r\n  }\r\n\r\n  if (orClauses.length === 0) return undefined;\r\n  const base: TransferWhereInput = { OR: orClauses } as TransferWhereInput;\r\n\r\n  const hasTokenIds = Array.isArray(tokenIds) && tokenIds.length > 0;\r\n  const hasTokenMin = tokenMinRaw != null && safeBigInt(tokenMinRaw) > 0n;\r\n  const hasTokenMax = tokenMaxRaw != null && safeBigInt(tokenMaxRaw) > 0n;\r\n\r\n  if (hasTokenIds) {\r\n    const tokenOrClauses: Array<any> = [];\r\n    const normalize0x = (v: string) => v.startsWith('0x') ? v : `0x${v}`;\r\n\r\n    for (const id of (tokenIds as string[])) {\r\n      const sRaw = String(id || '');\r\n      if (!sRaw) continue;\r\n      const s = normalize0x(sRaw);\r\n      const lower = s.toLowerCase();\r\n      const checksum = toChecksumAddress(s);\r\n      // Deduplicate variants\r\n      const variants = Array.from(new Set([s, lower, checksum]));\r\n      for (const v of variants) tokenOrClauses.push({ id_eq: v });\r\n    }\r\n    const tokenFilter: any = tokenOrClauses.length > 1 ? { OR: tokenOrClauses } : (tokenOrClauses[0] || {});\r\n    const andClauses: NonNullable<TransferWhereInput['AND']> = [base, { token: tokenFilter } as any];\r\n    if (hasTokenMin) andClauses.push({ amount_gte: safeBigInt(tokenMinRaw!).toString() });\r\n    if (hasTokenMax) andClauses.push({ amount_lte: safeBigInt(tokenMaxRaw!).toString() });\r\n    let result: TransferWhereInput = { AND: andClauses } as TransferWhereInput;\r\n    if (excludeSwapLegs) {\r\n      result = { AND: [result, { reefswapAction_isNull: true } as any] } as any;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  const hasMin = minReefRaw != null && safeBigInt(minReefRaw) > 0n;\r\n  const hasMax = maxReefRaw != null && safeBigInt(maxReefRaw) > 0n;\r\n  if (reefOnly || hasMin || hasMax) {\r\n    const andClauses: NonNullable<TransferWhereInput['AND']> = [base, { type_eq: 'Native' as TransferType }];\r\n    if (hasMin) andClauses.push({ amount_gte: safeBigInt(minReefRaw!).toString() });\r\n    let result: TransferWhereInput = { AND: andClauses } as TransferWhereInput;\r\n    if (excludeSwapLegs) {\r\n      result = { AND: [result, { reefswapAction_isNull: true } as any] } as any;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  if (erc20Only) {\r\n    const andClauses: NonNullable<TransferWhereInput['AND']> = [base, { token: { type_eq: 'ERC20' as any } } as any];\r\n    let result: TransferWhereInput = { AND: andClauses } as TransferWhereInput;\r\n    if (excludeSwapLegs) {\r\n      result = { AND: [result, { reefswapAction_isNull: true } as any] } as any;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  if (excludeSwapLegs) {\r\n    return { AND: [base, { reefswapAction_isNull: true } as any] } as any;\r\n  }\r\n  return base;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\utils\\url.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\podde\\reefExplore\\testExplore\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]